/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var __TEMPORAL__;
/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ './node_modules/@temporalio/common/lib/activity-options.js':
      /*!*****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/activity-options.js ***!
  \*****************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ActivityCancellationType = void 0;\nconst type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");\n// Avoid importing the proto implementation to reduce workflow bundle size\n// Copied from coresdk.workflow_commands.ActivityCancellationType\nvar ActivityCancellationType;\n(function (ActivityCancellationType) {\n    ActivityCancellationType[ActivityCancellationType["TRY_CANCEL"] = 0] = "TRY_CANCEL";\n    ActivityCancellationType[ActivityCancellationType["WAIT_CANCELLATION_COMPLETED"] = 1] = "WAIT_CANCELLATION_COMPLETED";\n    ActivityCancellationType[ActivityCancellationType["ABANDON"] = 2] = "ABANDON";\n})(ActivityCancellationType = exports.ActivityCancellationType || (exports.ActivityCancellationType = {}));\n(0, type_helpers_1.checkExtends)();\n//# sourceMappingURL=activity-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9hY3Rpdml0eS1vcHRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQyx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRSxnQ0FBZ0MsS0FBSztBQUN4RztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvYWN0aXZpdHktb3B0aW9ucy5qcz81MTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3R5cGUtaGVscGVyc1wiKTtcbi8vIEF2b2lkIGltcG9ydGluZyB0aGUgcHJvdG8gaW1wbGVtZW50YXRpb24gdG8gcmVkdWNlIHdvcmtmbG93IGJ1bmRsZSBzaXplXG4vLyBDb3BpZWQgZnJvbSBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZVxudmFyIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZTtcbihmdW5jdGlvbiAoQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlKSB7XG4gICAgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlW0FjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZVtcIlRSWV9DQU5DRUxcIl0gPSAwXSA9IFwiVFJZX0NBTkNFTFwiO1xuICAgIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZVtBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGVbXCJXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURURcIl0gPSAxXSA9IFwiV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEXCI7XG4gICAgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlW0FjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZVtcIkFCQU5ET05cIl0gPSAyXSA9IFwiQUJBTkRPTlwiO1xufSkoQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlID0gZXhwb3J0cy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUgfHwgKGV4cG9ydHMuQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlID0ge30pKTtcbigwLCB0eXBlX2hlbHBlcnNfMS5jaGVja0V4dGVuZHMpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eS1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/activity-options.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/converter/data-converter.js':
      /*!*************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/data-converter.js ***!
  \*************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.defaultDataConverter = exports.mapToPayloadsSync = exports.arrayFromPayloadsSync = exports.mapToPayloads = exports.arrayFromPayloads = exports.CompositeDataConverter = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@temporalio/common/lib/errors.js");\nconst types_1 = __webpack_require__(/*! ./types */ "./node_modules/@temporalio/common/lib/converter/types.js");\nconst payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/@temporalio/common/lib/converter/payload-converter.js");\nclass CompositeDataConverter {\n    constructor(...converters) {\n        this.converterByEncoding = new Map();\n        this.converters = converters;\n        for (const converter of converters) {\n            this.converterByEncoding.set(converter.encodingType, converter);\n        }\n    }\n    async toPayload(value) {\n        for (const converter of this.converters) {\n            const result = await converter.toData(value);\n            if (result !== undefined)\n                return result;\n        }\n        throw new errors_1.ValueError(`Cannot serialize ${value}`);\n    }\n    toPayloadSync(value) {\n        for (const converter of this.converters) {\n            const result = converter.toDataSync(value);\n            if (result !== undefined)\n                return result;\n        }\n        throw new errors_1.ValueError(`Cannot serialize ${value}`);\n    }\n    async fromPayload(payload) {\n        if (payload.metadata === undefined || payload.metadata === null) {\n            throw new errors_1.ValueError(\'Missing payload metadata\');\n        }\n        const encoding = (0, types_1.str)(payload.metadata[types_1.METADATA_ENCODING_KEY]);\n        const converter = this.converterByEncoding.get(encoding);\n        if (converter === undefined) {\n            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);\n        }\n        return await converter.fromData(payload);\n    }\n    fromPayloadSync(payload) {\n        if (payload.metadata === undefined || payload.metadata === null) {\n            throw new errors_1.ValueError(\'Missing payload metadata\');\n        }\n        const encoding = (0, types_1.str)(payload.metadata[types_1.METADATA_ENCODING_KEY]);\n        const converter = this.converterByEncoding.get(encoding);\n        if (converter === undefined) {\n            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);\n        }\n        return converter.fromDataSync(payload);\n    }\n    async toPayloads(...values) {\n        if (values.length === 0) {\n            return undefined;\n        }\n        return await Promise.all(values.map((value) => this.toPayload(value)));\n    }\n    toPayloadsSync(...values) {\n        if (values.length === 0) {\n            return undefined;\n        }\n        return values.map((value) => this.toPayloadSync(value));\n    }\n    async fromPayloads(index, payloads) {\n        // To make adding arguments a backwards compatible change\n        if (payloads === undefined || payloads === null || index >= payloads.length) {\n            return undefined;\n        }\n        return await this.fromPayload(payloads[index]);\n    }\n    fromPayloadsSync(index, payloads) {\n        // To make adding arguments a backwards compatible change\n        if (payloads === undefined || payloads === null || index >= payloads.length) {\n            return undefined;\n        }\n        return this.fromPayloadSync(payloads[index]);\n    }\n}\nexports.CompositeDataConverter = CompositeDataConverter;\nasync function arrayFromPayloads(converter, content) {\n    if (!content) {\n        return [];\n    }\n    return await Promise.all(content.map((payload) => converter.fromPayload(payload)));\n}\nexports.arrayFromPayloads = arrayFromPayloads;\nasync function mapToPayloads(converter, source) {\n    return Object.fromEntries(await Promise.all(Object.entries(source).map(async ([k, v]) => [k, await converter.toPayload(v)])));\n}\nexports.mapToPayloads = mapToPayloads;\nfunction arrayFromPayloadsSync(converter, content) {\n    if (!content) {\n        return [];\n    }\n    return content.map((payload) => converter.fromPayloadSync(payload));\n}\nexports.arrayFromPayloadsSync = arrayFromPayloadsSync;\nfunction mapToPayloadsSync(converter, source) {\n    return Object.fromEntries(Object.entries(source).map(([k, v]) => [k, converter.toPayloadSync(v)]));\n}\nexports.mapToPayloadsSync = mapToPayloadsSync;\nexports.defaultDataConverter = new CompositeDataConverter(new payload_converter_1.UndefinedPayloadConverter(), new payload_converter_1.BinaryPayloadConverter(), new payload_converter_1.JsonPayloadConverter());\n//# sourceMappingURL=data-converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9jb252ZXJ0ZXIvZGF0YS1jb252ZXJ0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcseUJBQXlCLEdBQUcsOEJBQThCO0FBQzdLLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFTO0FBQ2pDLDRCQUE0QixtQkFBTyxDQUFDLGlHQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL2NvbnZlcnRlci9kYXRhLWNvbnZlcnRlci5qcz81NjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0RGF0YUNvbnZlcnRlciA9IGV4cG9ydHMubWFwVG9QYXlsb2Fkc1N5bmMgPSBleHBvcnRzLmFycmF5RnJvbVBheWxvYWRzU3luYyA9IGV4cG9ydHMubWFwVG9QYXlsb2FkcyA9IGV4cG9ydHMuYXJyYXlGcm9tUGF5bG9hZHMgPSBleHBvcnRzLkNvbXBvc2l0ZURhdGFDb252ZXJ0ZXIgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBwYXlsb2FkX2NvbnZlcnRlcl8xID0gcmVxdWlyZShcIi4vcGF5bG9hZC1jb252ZXJ0ZXJcIik7XG5jbGFzcyBDb21wb3NpdGVEYXRhQ29udmVydGVyIHtcbiAgICBjb25zdHJ1Y3RvciguLi5jb252ZXJ0ZXJzKSB7XG4gICAgICAgIHRoaXMuY29udmVydGVyQnlFbmNvZGluZyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXJzID0gY29udmVydGVycztcbiAgICAgICAgZm9yIChjb25zdCBjb252ZXJ0ZXIgb2YgY29udmVydGVycykge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLnNldChjb252ZXJ0ZXIuZW5jb2RpbmdUeXBlLCBjb252ZXJ0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHRvUGF5bG9hZCh2YWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnZlcnRlciBvZiB0aGlzLmNvbnZlcnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnZlcnRlci50b0RhdGEodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoYENhbm5vdCBzZXJpYWxpemUgJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgdG9QYXlsb2FkU3luYyh2YWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnZlcnRlciBvZiB0aGlzLmNvbnZlcnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnZlcnRlci50b0RhdGFTeW5jKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKGBDYW5ub3Qgc2VyaWFsaXplICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSAoMCwgdHlwZXNfMS5zdHIpKHBheWxvYWQubWV0YWRhdGFbdHlwZXNfMS5NRVRBREFUQV9FTkNPRElOR19LRVldKTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLmdldChlbmNvZGluZyk7XG4gICAgICAgIGlmIChjb252ZXJ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRlci5mcm9tRGF0YShwYXlsb2FkKTtcbiAgICB9XG4gICAgZnJvbVBheWxvYWRTeW5jKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSAoMCwgdHlwZXNfMS5zdHIpKHBheWxvYWQubWV0YWRhdGFbdHlwZXNfMS5NRVRBREFUQV9FTkNPRElOR19LRVldKTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLmdldChlbmNvZGluZyk7XG4gICAgICAgIGlmIChjb252ZXJ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tRGF0YVN5bmMocGF5bG9hZCk7XG4gICAgfVxuICAgIGFzeW5jIHRvUGF5bG9hZHMoLi4udmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gdGhpcy50b1BheWxvYWQodmFsdWUpKSk7XG4gICAgfVxuICAgIHRvUGF5bG9hZHNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMudG9QYXlsb2FkU3luYyh2YWx1ZSkpO1xuICAgIH1cbiAgICBhc3luYyBmcm9tUGF5bG9hZHMoaW5kZXgsIHBheWxvYWRzKSB7XG4gICAgICAgIC8vIFRvIG1ha2UgYWRkaW5nIGFyZ3VtZW50cyBhIGJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZVxuICAgICAgICBpZiAocGF5bG9hZHMgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkcyA9PT0gbnVsbCB8fCBpbmRleCA+PSBwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZnJvbVBheWxvYWQocGF5bG9hZHNbaW5kZXhdKTtcbiAgICB9XG4gICAgZnJvbVBheWxvYWRzU3luYyhpbmRleCwgcGF5bG9hZHMpIHtcbiAgICAgICAgLy8gVG8gbWFrZSBhZGRpbmcgYXJndW1lbnRzIGEgYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlXG4gICAgICAgIGlmIChwYXlsb2FkcyA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWRzID09PSBudWxsIHx8IGluZGV4ID49IHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tUGF5bG9hZFN5bmMocGF5bG9hZHNbaW5kZXhdKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2l0ZURhdGFDb252ZXJ0ZXIgPSBDb21wb3NpdGVEYXRhQ29udmVydGVyO1xuYXN5bmMgZnVuY3Rpb24gYXJyYXlGcm9tUGF5bG9hZHMoY29udmVydGVyLCBjb250ZW50KSB7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGNvbnRlbnQubWFwKChwYXlsb2FkKSA9PiBjb252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCkpKTtcbn1cbmV4cG9ydHMuYXJyYXlGcm9tUGF5bG9hZHMgPSBhcnJheUZyb21QYXlsb2FkcztcbmFzeW5jIGZ1bmN0aW9uIG1hcFRvUGF5bG9hZHMoY29udmVydGVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHNvdXJjZSkubWFwKGFzeW5jIChbaywgdl0pID0+IFtrLCBhd2FpdCBjb252ZXJ0ZXIudG9QYXlsb2FkKHYpXSkpKTtcbn1cbmV4cG9ydHMubWFwVG9QYXlsb2FkcyA9IG1hcFRvUGF5bG9hZHM7XG5mdW5jdGlvbiBhcnJheUZyb21QYXlsb2Fkc1N5bmMoY29udmVydGVyLCBjb250ZW50KSB7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQubWFwKChwYXlsb2FkKSA9PiBjb252ZXJ0ZXIuZnJvbVBheWxvYWRTeW5jKHBheWxvYWQpKTtcbn1cbmV4cG9ydHMuYXJyYXlGcm9tUGF5bG9hZHNTeW5jID0gYXJyYXlGcm9tUGF5bG9hZHNTeW5jO1xuZnVuY3Rpb24gbWFwVG9QYXlsb2Fkc1N5bmMoY29udmVydGVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNvdXJjZSkubWFwKChbaywgdl0pID0+IFtrLCBjb252ZXJ0ZXIudG9QYXlsb2FkU3luYyh2KV0pKTtcbn1cbmV4cG9ydHMubWFwVG9QYXlsb2Fkc1N5bmMgPSBtYXBUb1BheWxvYWRzU3luYztcbmV4cG9ydHMuZGVmYXVsdERhdGFDb252ZXJ0ZXIgPSBuZXcgQ29tcG9zaXRlRGF0YUNvbnZlcnRlcihuZXcgcGF5bG9hZF9jb252ZXJ0ZXJfMS5VbmRlZmluZWRQYXlsb2FkQ29udmVydGVyKCksIG5ldyBwYXlsb2FkX2NvbnZlcnRlcl8xLkJpbmFyeVBheWxvYWRDb252ZXJ0ZXIoKSwgbmV3IHBheWxvYWRfY29udmVydGVyXzEuSnNvblBheWxvYWRDb252ZXJ0ZXIoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWNvbnZlcnRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/converter/data-converter.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/converter/payload-converter.js':
      /*!****************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/payload-converter.js ***!
  \****************************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BinaryPayloadConverter = exports.JsonPayloadConverter = exports.UndefinedPayloadConverter = exports.AsyncFacadePayloadConverter = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@temporalio/common/lib/errors.js");\nconst types_1 = __webpack_require__(/*! ./types */ "./node_modules/@temporalio/common/lib/converter/types.js");\nclass AsyncFacadePayloadConverter {\n    async toData(value) {\n        return this.toDataSync(value);\n    }\n    async fromData(content) {\n        return this.fromDataSync(content);\n    }\n}\nexports.AsyncFacadePayloadConverter = AsyncFacadePayloadConverter;\n/**\n * Converts between JS undefined and NULL Payload\n */\nclass UndefinedPayloadConverter extends AsyncFacadePayloadConverter {\n    constructor() {\n        super(...arguments);\n        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_NULL;\n    }\n    toDataSync(value) {\n        if (value !== undefined)\n            return undefined; // Can\'t encode\n        return {\n            metadata: {\n                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_NULL,\n            },\n        };\n    }\n    fromDataSync(_content) {\n        return undefined; // Just return undefined\n    }\n}\nexports.UndefinedPayloadConverter = UndefinedPayloadConverter;\n/**\n * Converts between non-undefined values and serialized JSON Payload\n */\nclass JsonPayloadConverter extends AsyncFacadePayloadConverter {\n    constructor() {\n        super(...arguments);\n        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_JSON;\n    }\n    toDataSync(value) {\n        if (value === undefined)\n            return undefined; // Should be encoded with the UndefinedPayloadConverter\n        return {\n            metadata: {\n                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_JSON,\n            },\n            data: (0, types_1.u8)(JSON.stringify(value)),\n        };\n    }\n    fromDataSync(content) {\n        if (content.data === undefined || content.data === null) {\n            throw new errors_1.ValueError(\'Got payload with no data\');\n        }\n        return JSON.parse((0, types_1.str)(content.data));\n    }\n}\nexports.JsonPayloadConverter = JsonPayloadConverter;\n/**\n * Converts between binary data types and RAW Payload\n */\nclass BinaryPayloadConverter extends AsyncFacadePayloadConverter {\n    constructor() {\n        super(...arguments);\n        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_RAW;\n    }\n    toDataSync(value) {\n        // TODO: support any DataView or ArrayBuffer?\n        if (!(value instanceof Uint8Array)) {\n            return undefined;\n        }\n        return {\n            metadata: {\n                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_RAW,\n            },\n            data: value,\n        };\n    }\n    fromDataSync(content) {\n        // TODO: support any DataView or ArrayBuffer?\n        return content.data;\n    }\n}\nexports.BinaryPayloadConverter = BinaryPayloadConverter;\n//# sourceMappingURL=payload-converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9jb252ZXJ0ZXIvcGF5bG9hZC1jb252ZXJ0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsNEJBQTRCLEdBQUcsaUNBQWlDLEdBQUcsbUNBQW1DO0FBQ3ZJLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvY29udmVydGVyL3BheWxvYWQtY29udmVydGVyLmpzP2M1NGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpbmFyeVBheWxvYWRDb252ZXJ0ZXIgPSBleHBvcnRzLkpzb25QYXlsb2FkQ29udmVydGVyID0gZXhwb3J0cy5VbmRlZmluZWRQYXlsb2FkQ29udmVydGVyID0gZXhwb3J0cy5Bc3luY0ZhY2FkZVBheWxvYWRDb252ZXJ0ZXIgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jbGFzcyBBc3luY0ZhY2FkZVBheWxvYWRDb252ZXJ0ZXIge1xuICAgIGFzeW5jIHRvRGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGFTeW5jKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgZnJvbURhdGEoY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRGF0YVN5bmMoY29udGVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY0ZhY2FkZVBheWxvYWRDb252ZXJ0ZXIgPSBBc3luY0ZhY2FkZVBheWxvYWRDb252ZXJ0ZXI7XG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gSlMgdW5kZWZpbmVkIGFuZCBOVUxMIFBheWxvYWRcbiAqL1xuY2xhc3MgVW5kZWZpbmVkUGF5bG9hZENvbnZlcnRlciBleHRlbmRzIEFzeW5jRmFjYWRlUGF5bG9hZENvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdUeXBlID0gdHlwZXNfMS5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX05VTEw7XG4gICAgfVxuICAgIHRvRGF0YVN5bmModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBDYW4ndCBlbmNvZGVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgW3R5cGVzXzEuTUVUQURBVEFfRU5DT0RJTkdfS0VZXTogdHlwZXNfMS5lbmNvZGluZ0tleXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZyb21EYXRhU3luYyhfY29udGVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBKdXN0IHJldHVybiB1bmRlZmluZWRcbiAgICB9XG59XG5leHBvcnRzLlVuZGVmaW5lZFBheWxvYWRDb252ZXJ0ZXIgPSBVbmRlZmluZWRQYXlsb2FkQ29udmVydGVyO1xuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIG5vbi11bmRlZmluZWQgdmFsdWVzIGFuZCBzZXJpYWxpemVkIEpTT04gUGF5bG9hZFxuICovXG5jbGFzcyBKc29uUGF5bG9hZENvbnZlcnRlciBleHRlbmRzIEFzeW5jRmFjYWRlUGF5bG9hZENvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdUeXBlID0gdHlwZXNfMS5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT047XG4gICAgfVxuICAgIHRvRGF0YVN5bmModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBTaG91bGQgYmUgZW5jb2RlZCB3aXRoIHRoZSBVbmRlZmluZWRQYXlsb2FkQ29udmVydGVyXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIFt0eXBlc18xLk1FVEFEQVRBX0VOQ09ESU5HX0tFWV06IHR5cGVzXzEuZW5jb2RpbmdLZXlzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT04sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogKDAsIHR5cGVzXzEudTgpKEpTT04uc3RyaW5naWZ5KHZhbHVlKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZyb21EYXRhU3luYyhjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50LmRhdGEgPT09IHVuZGVmaW5lZCB8fCBjb250ZW50LmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdHb3QgcGF5bG9hZCB3aXRoIG5vIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSgoMCwgdHlwZXNfMS5zdHIpKGNvbnRlbnQuZGF0YSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblBheWxvYWRDb252ZXJ0ZXIgPSBKc29uUGF5bG9hZENvbnZlcnRlcjtcbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBiaW5hcnkgZGF0YSB0eXBlcyBhbmQgUkFXIFBheWxvYWRcbiAqL1xuY2xhc3MgQmluYXJ5UGF5bG9hZENvbnZlcnRlciBleHRlbmRzIEFzeW5jRmFjYWRlUGF5bG9hZENvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdUeXBlID0gdHlwZXNfMS5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVztcbiAgICB9XG4gICAgdG9EYXRhU3luYyh2YWx1ZSkge1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFueSBEYXRhVmlldyBvciBBcnJheUJ1ZmZlcj9cbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBbdHlwZXNfMS5NRVRBREFUQV9FTkNPRElOR19LRVldOiB0eXBlc18xLmVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19SQVcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZyb21EYXRhU3luYyhjb250ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYW55IERhdGFWaWV3IG9yIEFycmF5QnVmZmVyP1xuICAgICAgICByZXR1cm4gY29udGVudC5kYXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuQmluYXJ5UGF5bG9hZENvbnZlcnRlciA9IEJpbmFyeVBheWxvYWRDb252ZXJ0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXlsb2FkLWNvbnZlcnRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/converter/payload-converter.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/converter/types.js':
      /*!****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/types.js ***!
  \****************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = exports.str = exports.u8 = void 0;\nconst encoding_1 = __webpack_require__(/*! ../encoding */ \"./node_modules/@temporalio/common/lib/encoding.js\");\n/**\n * Transform an *ascii* string into a Uint8Array\n */\nfunction u8(s) {\n    return new encoding_1.TextEncoder().encode(s);\n}\nexports.u8 = u8;\nfunction str(a) {\n    return new encoding_1.TextDecoder().decode(a);\n}\nexports.str = str;\nexports.METADATA_ENCODING_KEY = 'encoding';\nexports.encodingTypes = {\n    METADATA_ENCODING_NULL: 'binary/null',\n    METADATA_ENCODING_RAW: 'binary/plain',\n    METADATA_ENCODING_JSON: 'json/plain',\n    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',\n    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',\n};\nexports.encodingKeys = {\n    METADATA_ENCODING_NULL: u8(exports.encodingTypes.METADATA_ENCODING_NULL),\n    METADATA_ENCODING_RAW: u8(exports.encodingTypes.METADATA_ENCODING_RAW),\n    METADATA_ENCODING_JSON: u8(exports.encodingTypes.METADATA_ENCODING_JSON),\n    METADATA_ENCODING_PROTOBUF_JSON: u8(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),\n    METADATA_ENCODING_PROTOBUF: u8(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9jb252ZXJ0ZXIvdHlwZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsNkJBQTZCLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDdkcsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL2NvbnZlcnRlci90eXBlcy5qcz8wMTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGluZ0tleXMgPSBleHBvcnRzLmVuY29kaW5nVHlwZXMgPSBleHBvcnRzLk1FVEFEQVRBX0VOQ09ESU5HX0tFWSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vZW5jb2RpbmdcIik7XG4vKipcbiAqIFRyYW5zZm9ybSBhbiAqYXNjaWkqIHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICovXG5mdW5jdGlvbiB1OChzKSB7XG4gICAgcmV0dXJuIG5ldyBlbmNvZGluZ18xLlRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xufVxuZXhwb3J0cy51OCA9IHU4O1xuZnVuY3Rpb24gc3RyKGEpIHtcbiAgICByZXR1cm4gbmV3IGVuY29kaW5nXzEuVGV4dERlY29kZXIoKS5kZWNvZGUoYSk7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuTUVUQURBVEFfRU5DT0RJTkdfS0VZID0gJ2VuY29kaW5nJztcbmV4cG9ydHMuZW5jb2RpbmdUeXBlcyA9IHtcbiAgICBNRVRBREFUQV9FTkNPRElOR19OVUxMOiAnYmluYXJ5L251bGwnLFxuICAgIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogJ2JpbmFyeS9wbGFpbicsXG4gICAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogJ2pzb24vcGxhaW4nLFxuICAgIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT046ICdqc29uL3Byb3RvYnVmJyxcbiAgICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogJ2JpbmFyeS9wcm90b2J1ZicsXG59O1xuZXhwb3J0cy5lbmNvZGluZ0tleXMgPSB7XG4gICAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogdTgoZXhwb3J0cy5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX05VTEwpLFxuICAgIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogdTgoZXhwb3J0cy5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVyksXG4gICAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogdTgoZXhwb3J0cy5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT04pLFxuICAgIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT046IHU4KGV4cG9ydHMuZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OKSxcbiAgICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogdTgoZXhwb3J0cy5lbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/converter/types.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/encoding.js':
      /*!*********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/encoding.js ***!
  \*********************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          "\n// Pasted with modifications from: https://raw.githubusercontent.com/anonyco/FastestSmallestTextEncoderDecoder/master/EncoderDecoderTogether.src.js\n/* eslint no-fallthrough: 0 */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextEncoder = exports.TextDecoder = void 0;\nconst fromCharCode = String.fromCharCode;\nconst encoderRegexp = /[\\x80-\\uD7ff\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g;\nconst tmpBufferU16 = new Uint16Array(32);\nclass TextDecoder {\n    decode(inputArrayOrBuffer) {\n        const inputAs8 = inputArrayOrBuffer instanceof Uint8Array ? inputArrayOrBuffer : new Uint8Array(inputArrayOrBuffer);\n        let resultingString = '', tmpStr = '', index = 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;\n        const len = inputAs8.length | 0;\n        const lenMinus32 = (len - 32) | 0;\n        // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks\n        for (; index < len;) {\n            nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;\n            for (; pos < nextEnd; index = (index + 1) | 0, pos = (pos + 1) | 0) {\n                cp0 = inputAs8[index] & 0xff;\n                switch (cp0 >> 4) {\n                    case 15:\n                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;\n                        if (cp1 >> 6 !== 0b10 || 0b11110111 < cp0) {\n                            index = (index - 1) | 0;\n                            break;\n                        }\n                        codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);\n                        minBits = 5; // 20 ensures it never passes -> all invalid replacements\n                        cp0 = 0x100; //  keep track of th bit size\n                    case 14:\n                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;\n                        codePoint <<= 6;\n                        codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);\n                        minBits = cp1 >> 6 === 0b10 ? (minBits + 4) | 0 : 24; // 24 ensures it never passes -> all invalid replacements\n                        cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size\n                    case 13:\n                    case 12:\n                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;\n                        codePoint <<= 6;\n                        codePoint |= ((cp0 & 0b11111) << 6) | (cp1 & 0b00111111);\n                        minBits = (minBits + 7) | 0;\n                        // Now, process the code point\n                        if (index < len && cp1 >> 6 === 0b10 && codePoint >> minBits && codePoint < 0x110000) {\n                            cp0 = codePoint;\n                            codePoint = (codePoint - 0x10000) | 0;\n                            if (0 <= codePoint /*0xffff < codePoint*/) {\n                                // BMP code point\n                                //nextEnd = nextEnd - 1|0;\n                                tmp = ((codePoint >> 10) + 0xd800) | 0; // highSurrogate\n                                cp0 = ((codePoint & 0x3ff) + 0xdc00) | 0; // lowSurrogate (will be inserted later in the switch-statement)\n                                if (pos < 31) {\n                                    // notice 31 instead of 32\n                                    tmpBufferU16[pos] = tmp;\n                                    pos = (pos + 1) | 0;\n                                    tmp = -1;\n                                }\n                                else {\n                                    // else, we are at the end of the inputAs8 and let tmp0 be filled in later on\n                                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0\n                                    cp1 = tmp;\n                                    tmp = cp0;\n                                    cp0 = cp1;\n                                }\n                            }\n                            else\n                                nextEnd = (nextEnd + 1) | 0; // because we are advancing i without advancing pos\n                        }\n                        else {\n                            // invalid code point means replacing the whole thing with null replacement characters\n                            cp0 >>= 8;\n                            index = (index - cp0 - 1) | 0; // reset index  back to what it was before\n                            cp0 = 0xfffd;\n                        }\n                        // Finally, reset the variables for the next go-around\n                        minBits = 0;\n                        codePoint = 0;\n                        nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;\n                    /*case 11:\n                  case 10:\n                  case 9:\n                  case 8:\n                    codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character\n                  case 7:\n                  case 6:\n                  case 5:\n                  case 4:\n                  case 3:\n                  case 2:\n                  case 1:\n                  case 0:\n                    tmpBufferU16[pos] = cp0;\n                    continue;*/\n                    default:\n                        tmpBufferU16[pos] = cp0; // fill with invalid replacement character\n                        continue;\n                    case 11:\n                    case 10:\n                    case 9:\n                    case 8:\n                }\n                tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character\n            }\n            tmpStr += fromCharCode(tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7], tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15], tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23], tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]);\n            if (pos < 32)\n                tmpStr = tmpStr.slice(0, (pos - 32) | 0); //-(32-pos));\n            if (index < len) {\n                //fromCharCode.apply(0, tmpBufferU16 : Uint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));\n                tmpBufferU16[0] = tmp;\n                pos = ~tmp >>> 31; //tmp !== -1 ? 1 : 0;\n                tmp = -1;\n                if (tmpStr.length < resultingString.length)\n                    continue;\n            }\n            else if (tmp !== -1) {\n                tmpStr += fromCharCode(tmp);\n            }\n            resultingString += tmpStr;\n            tmpStr = '';\n        }\n        return resultingString;\n    }\n}\nexports.TextDecoder = TextDecoder;\n//////////////////////////////////////////////////////////////////////////////////////\nfunction encoderReplacer(nonAsciiChars) {\n    // make the UTF string into a binary UTF-8 encoded string\n    let point = nonAsciiChars.charCodeAt(0) | 0;\n    if (0xd800 <= point) {\n        if (point <= 0xdbff) {\n            const nextcode = nonAsciiChars.charCodeAt(1) | 0; // defaults to 0 when NaN, causing null replacement character\n            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {\n                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n                point = ((point << 10) + nextcode - 0x35fdc00) | 0;\n                if (point > 0xffff)\n                    return fromCharCode((0x1e /*0b11110*/ << 3) | (point >> 18), (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);\n            }\n            else\n                point = 65533 /*0b1111111111111101*/; //return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n        }\n        else if (point <= 0xdfff) {\n            point = 65533 /*0b1111111111111101*/; //return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n        }\n    }\n    /*if (point <= 0x007f) return nonAsciiChars;\n    else */ if (point <= 0x07ff) {\n        return fromCharCode((0x6 << 5) | (point >> 6), (0x2 << 6) | (point & 0x3f));\n    }\n    else\n        return fromCharCode((0xe /*0b1110*/ << 4) | (point >> 12), (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);\n}\nclass TextEncoder {\n    encode(inputString) {\n        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx\n        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx\n        const encodedString = inputString === void 0 ? '' : '' + inputString, len = encodedString.length | 0;\n        let result = new Uint8Array(((len << 1) + 8) | 0);\n        let tmpResult;\n        let i = 0, pos = 0, point = 0, nextcode = 0;\n        let upgradededArraySize = !Uint8Array; // normal arrays are auto-expanding\n        for (i = 0; i < len; i = (i + 1) | 0, pos = (pos + 1) | 0) {\n            point = encodedString.charCodeAt(i) | 0;\n            if (point <= 0x007f) {\n                result[pos] = point;\n            }\n            else if (point <= 0x07ff) {\n                result[pos] = (0x6 << 5) | (point >> 6);\n                result[(pos = (pos + 1) | 0)] = (0x2 << 6) | (point & 0x3f);\n            }\n            else {\n                widenCheck: {\n                    if (0xd800 <= point) {\n                        if (point <= 0xdbff) {\n                            nextcode = encodedString.charCodeAt((i = (i + 1) | 0)) | 0; // defaults to 0 when NaN, causing null replacement character\n                            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {\n                                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n                                point = ((point << 10) + nextcode - 0x35fdc00) | 0;\n                                if (point > 0xffff) {\n                                    result[pos] = (0x1e /*0b11110*/ << 3) | (point >> 18);\n                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/;\n                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;\n                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;\n                                    continue;\n                                }\n                                break widenCheck;\n                            }\n                            point = 65533 /*0b1111111111111101*/; //return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n                        }\n                        else if (point <= 0xdfff) {\n                            point = 65533 /*0b1111111111111101*/; //return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n                        }\n                    }\n                    if (!upgradededArraySize && i << 1 < pos && i << 1 < ((pos - 7) | 0)) {\n                        upgradededArraySize = true;\n                        tmpResult = new Uint8Array(len * 3);\n                        tmpResult.set(result);\n                        result = tmpResult;\n                    }\n                }\n                result[pos] = (0xe /*0b1110*/ << 4) | (point >> 12);\n                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;\n                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;\n            }\n        }\n        return Uint8Array ? result.subarray(0, pos) : result.slice(0, pos);\n    }\n    encodeInto(inputString, u8Arr) {\n        const encodedString = inputString === void 0 ? '' : ('' + inputString).replace(encoderRegexp, encoderReplacer);\n        let len = encodedString.length | 0, i = 0, char = 0, read = 0;\n        const u8ArrLen = u8Arr.length | 0;\n        const inputLength = inputString.length | 0;\n        if (u8ArrLen < len)\n            len = u8ArrLen;\n        putChars: {\n            for (; i < len; i = (i + 1) | 0) {\n                char = encodedString.charCodeAt(i) | 0;\n                switch (char >> 4) {\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                    case 6:\n                    case 7:\n                        read = (read + 1) | 0;\n                    // extension points:\n                    case 8:\n                    case 9:\n                    case 10:\n                    case 11:\n                        break;\n                    case 12:\n                    case 13:\n                        if (((i + 1) | 0) < u8ArrLen) {\n                            read = (read + 1) | 0;\n                            break;\n                        }\n                    case 14:\n                        if (((i + 2) | 0) < u8ArrLen) {\n                            //if (!(char === 0xEF && encodedString.substr(i+1|0,2) === \"\\xBF\\xBD\"))\n                            read = (read + 1) | 0;\n                            break;\n                        }\n                    case 15:\n                        if (((i + 3) | 0) < u8ArrLen) {\n                            read = (read + 1) | 0;\n                            break;\n                        }\n                    default:\n                        break putChars;\n                }\n                //read = read + ((char >> 6) !== 2) |0;\n                u8Arr[i] = char;\n            }\n        }\n        return { written: i, read: inputLength < read ? inputLength : read };\n    }\n}\nexports.TextEncoder = TextEncoder;\n//# sourceMappingURL=encoding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9lbmNvZGluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0Esa0RBQWtELHdCQUF3QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL2VuY29kaW5nLmpzPzg2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBQYXN0ZWQgd2l0aCBtb2RpZmljYXRpb25zIGZyb206IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hbm9ueWNvL0Zhc3Rlc3RTbWFsbGVzdFRleHRFbmNvZGVyRGVjb2Rlci9tYXN0ZXIvRW5jb2RlckRlY29kZXJUb2dldGhlci5zcmMuanNcbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogMCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0RW5jb2RlciA9IGV4cG9ydHMuVGV4dERlY29kZXIgPSB2b2lkIDA7XG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuY29uc3QgZW5jb2RlclJlZ2V4cCA9IC9bXFx4ODAtXFx1RDdmZlxcdURDMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXT8vZztcbmNvbnN0IHRtcEJ1ZmZlclUxNiA9IG5ldyBVaW50MTZBcnJheSgzMik7XG5jbGFzcyBUZXh0RGVjb2RlciB7XG4gICAgZGVjb2RlKGlucHV0QXJyYXlPckJ1ZmZlcikge1xuICAgICAgICBjb25zdCBpbnB1dEFzOCA9IGlucHV0QXJyYXlPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dEFycmF5T3JCdWZmZXIgOiBuZXcgVWludDhBcnJheShpbnB1dEFycmF5T3JCdWZmZXIpO1xuICAgICAgICBsZXQgcmVzdWx0aW5nU3RyaW5nID0gJycsIHRtcFN0ciA9ICcnLCBpbmRleCA9IDAsIG5leHRFbmQgPSAwLCBjcDAgPSAwLCBjb2RlUG9pbnQgPSAwLCBtaW5CaXRzID0gMCwgY3AxID0gMCwgcG9zID0gMCwgdG1wID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbiA9IGlucHV0QXM4Lmxlbmd0aCB8IDA7XG4gICAgICAgIGNvbnN0IGxlbk1pbnVzMzIgPSAobGVuIC0gMzIpIHwgMDtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRtcCByZXByZXNlbnRzIHRoZSAybmQgaGFsZiBvZiBhIHN1cnJvZ2F0ZSBwYWlyIGluY2FzZSBhIHN1cnJvZ2F0ZSBnZXRzIGRpdmlkZWQgYmV0d2VlbiBibG9ja3NcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuOykge1xuICAgICAgICAgICAgbmV4dEVuZCA9IGluZGV4IDw9IGxlbk1pbnVzMzIgPyAzMiA6IChsZW4gLSBpbmRleCkgfCAwO1xuICAgICAgICAgICAgZm9yICg7IHBvcyA8IG5leHRFbmQ7IGluZGV4ID0gKGluZGV4ICsgMSkgfCAwLCBwb3MgPSAocG9zICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgY3AwID0gaW5wdXRBczhbaW5kZXhdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNwMCA+PiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcDEgPSBpbnB1dEFzOFsoaW5kZXggPSAoaW5kZXggKyAxKSB8IDApXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3AxID4+IDYgIT09IDBiMTAgfHwgMGIxMTExMDExMSA8IGNwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKChjcDAgJiAwYjExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5CaXRzID0gNTsgLy8gMjAgZW5zdXJlcyBpdCBuZXZlciBwYXNzZXMgLT4gYWxsIGludmFsaWQgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjcDAgPSAweDEwMDsgLy8gIGtlZXAgdHJhY2sgb2YgdGggYml0IHNpemVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5CaXRzID0gY3AxID4+IDYgPT09IDBiMTAgPyAobWluQml0cyArIDQpIHwgMCA6IDI0OyAvLyAyNCBlbnN1cmVzIGl0IG5ldmVyIHBhc3NlcyAtPiBhbGwgaW52YWxpZCByZXBsYWNlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwMCA9IChjcDAgKyAweDEwMCkgJiAweDMwMDsgLy8ga2VlcCB0cmFjayBvZiB0aCBiaXQgc2l6ZVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3AxID0gaW5wdXRBczhbKGluZGV4ID0gKGluZGV4ICsgMSkgfCAwKV0gJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50IDw8PSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50IHw9ICgoY3AwICYgMGIxMTExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5CaXRzID0gKG1pbkJpdHMgKyA3KSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3csIHByb2Nlc3MgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbiAmJiBjcDEgPj4gNiA9PT0gMGIxMCAmJiBjb2RlUG9pbnQgPj4gbWluQml0cyAmJiBjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMCA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoY29kZVBvaW50IC0gMHgxMDAwMCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGNvZGVQb2ludCAvKjB4ZmZmZiA8IGNvZGVQb2ludCovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV4dEVuZCA9IG5leHRFbmQgLSAxfDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9ICgoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMCkgfCAwOyAvLyBoaWdoU3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMCA9ICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSB8IDA7IC8vIGxvd1N1cnJvZ2F0ZSAod2lsbCBiZSBpbnNlcnRlZCBsYXRlciBpbiB0aGUgc3dpdGNoLXN0YXRlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA8IDMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RpY2UgMzEgaW5zdGVhZCBvZiAzMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSAocG9zICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlLCB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXRBczggYW5kIGxldCB0bXAwIGJlIGZpbGxlZCBpbiBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSB0aGF0IGNwMSBpcyBiZWluZyB1c2VkIGFzIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciB0aGUgc3dhcHBpbmcgb2YgdG1wIHdpdGggY3AwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDEgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBjcDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDAgPSBjcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0RW5kID0gKG5leHRFbmQgKyAxKSB8IDA7IC8vIGJlY2F1c2Ugd2UgYXJlIGFkdmFuY2luZyBpIHdpdGhvdXQgYWR2YW5jaW5nIHBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCBjb2RlIHBvaW50IG1lYW5zIHJlcGxhY2luZyB0aGUgd2hvbGUgdGhpbmcgd2l0aCBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDAgPj49IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggLSBjcDAgLSAxKSB8IDA7IC8vIHJlc2V0IGluZGV4ICBiYWNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMCA9IDB4ZmZmZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHJlc2V0IHRoZSB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGdvLWFyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQml0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEVuZCA9IGluZGV4IDw9IGxlbk1pbnVzMzIgPyAzMiA6IChsZW4gLSBpbmRleCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAvKmNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPyBjb2RlUG9pbnQgPSAwIDogY3AwID0gMHhmZmZkOyAvLyBmaWxsIHdpdGggaW52YWxpZCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSBjcDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyovXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IGNwMDsgLy8gZmlsbCB3aXRoIGludmFsaWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclUxNltwb3NdID0gMHhmZmZkOyAvLyBmaWxsIHdpdGggaW52YWxpZCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcFN0ciArPSBmcm9tQ2hhckNvZGUodG1wQnVmZmVyVTE2WzBdLCB0bXBCdWZmZXJVMTZbMV0sIHRtcEJ1ZmZlclUxNlsyXSwgdG1wQnVmZmVyVTE2WzNdLCB0bXBCdWZmZXJVMTZbNF0sIHRtcEJ1ZmZlclUxNls1XSwgdG1wQnVmZmVyVTE2WzZdLCB0bXBCdWZmZXJVMTZbN10sIHRtcEJ1ZmZlclUxNls4XSwgdG1wQnVmZmVyVTE2WzldLCB0bXBCdWZmZXJVMTZbMTBdLCB0bXBCdWZmZXJVMTZbMTFdLCB0bXBCdWZmZXJVMTZbMTJdLCB0bXBCdWZmZXJVMTZbMTNdLCB0bXBCdWZmZXJVMTZbMTRdLCB0bXBCdWZmZXJVMTZbMTVdLCB0bXBCdWZmZXJVMTZbMTZdLCB0bXBCdWZmZXJVMTZbMTddLCB0bXBCdWZmZXJVMTZbMThdLCB0bXBCdWZmZXJVMTZbMTldLCB0bXBCdWZmZXJVMTZbMjBdLCB0bXBCdWZmZXJVMTZbMjFdLCB0bXBCdWZmZXJVMTZbMjJdLCB0bXBCdWZmZXJVMTZbMjNdLCB0bXBCdWZmZXJVMTZbMjRdLCB0bXBCdWZmZXJVMTZbMjVdLCB0bXBCdWZmZXJVMTZbMjZdLCB0bXBCdWZmZXJVMTZbMjddLCB0bXBCdWZmZXJVMTZbMjhdLCB0bXBCdWZmZXJVMTZbMjldLCB0bXBCdWZmZXJVMTZbMzBdLCB0bXBCdWZmZXJVMTZbMzFdKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCAzMilcbiAgICAgICAgICAgICAgICB0bXBTdHIgPSB0bXBTdHIuc2xpY2UoMCwgKHBvcyAtIDMyKSB8IDApOyAvLy0oMzItcG9zKSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAvL2Zyb21DaGFyQ29kZS5hcHBseSgwLCB0bXBCdWZmZXJVMTYgOiBVaW50OEFycmF5ID8gIHRtcEJ1ZmZlclUxNi5zdWJhcnJheSgwLHBvcykgOiB0bXBCdWZmZXJVMTYuc2xpY2UoMCxwb3MpKTtcbiAgICAgICAgICAgICAgICB0bXBCdWZmZXJVMTZbMF0gPSB0bXA7XG4gICAgICAgICAgICAgICAgcG9zID0gfnRtcCA+Pj4gMzE7IC8vdG1wICE9PSAtMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHRtcCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmICh0bXBTdHIubGVuZ3RoIDwgcmVzdWx0aW5nU3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0bXAgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdG1wU3RyICs9IGZyb21DaGFyQ29kZSh0bXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0aW5nU3RyaW5nICs9IHRtcFN0cjtcbiAgICAgICAgICAgIHRtcFN0ciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdTdHJpbmc7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0RGVjb2RlciA9IFRleHREZWNvZGVyO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGVuY29kZXJSZXBsYWNlcihub25Bc2NpaUNoYXJzKSB7XG4gICAgLy8gbWFrZSB0aGUgVVRGIHN0cmluZyBpbnRvIGEgYmluYXJ5IFVURi04IGVuY29kZWQgc3RyaW5nXG4gICAgbGV0IHBvaW50ID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDApIHwgMDtcbiAgICBpZiAoMHhkODAwIDw9IHBvaW50KSB7XG4gICAgICAgIGlmIChwb2ludCA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRjb2RlID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDEpIHwgMDsgLy8gZGVmYXVsdHMgdG8gMCB3aGVuIE5hTiwgY2F1c2luZyBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKDB4ZGMwMCA8PSBuZXh0Y29kZSAmJiBuZXh0Y29kZSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gKChwb2ludCA8PCAxMCkgKyBuZXh0Y29kZSAtIDB4MzVmZGMwMCkgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCA+IDB4ZmZmZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZSgoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCksICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDEyKSAmIDB4M2YpIC8qMGIwMDExMTExMSovLCAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovLCAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9pbnQgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qaWYgKHBvaW50IDw9IDB4MDA3ZikgcmV0dXJuIG5vbkFzY2lpQ2hhcnM7XG4gICAgZWxzZSAqLyBpZiAocG9pbnQgPD0gMHgwN2ZmKSB7XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KSwgKDB4MiA8PCA2KSB8IChwb2ludCAmIDB4M2YpKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKCgweGUgLyowYjExMTAqLyA8PCA0KSB8IChwb2ludCA+PiAxMiksICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi8sICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqLyk7XG59XG5jbGFzcyBUZXh0RW5jb2RlciB7XG4gICAgZW5jb2RlKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIC8vIDB4YzAgPT4gMGIxMTAwMDAwMDsgMHhmZiA9PiAwYjExMTExMTExOyAweGMwLTB4ZmYgPT4gMGIxMXh4eHh4eFxuICAgICAgICAvLyAweDgwID0+IDBiMTAwMDAwMDA7IDB4YmYgPT4gMGIxMDExMTExMTsgMHg4MC0weGJmID0+IDBiMTB4eHh4eHhcbiAgICAgICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IGlucHV0U3RyaW5nID09PSB2b2lkIDAgPyAnJyA6ICcnICsgaW5wdXRTdHJpbmcsIGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoIHwgMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCgobGVuIDw8IDEpICsgOCkgfCAwKTtcbiAgICAgICAgbGV0IHRtcFJlc3VsdDtcbiAgICAgICAgbGV0IGkgPSAwLCBwb3MgPSAwLCBwb2ludCA9IDAsIG5leHRjb2RlID0gMDtcbiAgICAgICAgbGV0IHVwZ3JhZGVkZWRBcnJheVNpemUgPSAhVWludDhBcnJheTsgLy8gbm9ybWFsIGFycmF5cyBhcmUgYXV0by1leHBhbmRpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSA9IChpICsgMSkgfCAwLCBwb3MgPSAocG9zICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBwb2ludCA9IGVuY29kZWRTdHJpbmcuY2hhckNvZGVBdChpKSB8IDA7XG4gICAgICAgICAgICBpZiAocG9pbnQgPD0gMHgwMDdmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSBwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50IDw9IDB4MDdmZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0gKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KTtcbiAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgPDwgNikgfCAocG9pbnQgJiAweDNmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZGVuQ2hlY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRjb2RlID0gZW5jb2RlZFN0cmluZy5jaGFyQ29kZUF0KChpID0gKGkgKyAxKSB8IDApKSB8IDA7IC8vIGRlZmF1bHRzIHRvIDAgd2hlbiBOYU4sIGNhdXNpbmcgbnVsbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMHhkYzAwIDw9IG5leHRjb2RlICYmIG5leHRjb2RlIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9ICgocG9pbnQgPDwgMTApICsgbmV4dGNvZGUgLSAweDM1ZmRjMDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcG9zXSA9ICgweDFlIC8qMGIxMTExMCovIDw8IDMpIHwgKHBvaW50ID4+IDE4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFsocG9zID0gKHBvcyArIDEpIHwgMCldID0gKDB4MiAvKjBiMTAqLyA8PCA2KSB8ICgocG9pbnQgPj4gMTIpICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHdpZGVuQ2hlY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBncmFkZWRlZEFycmF5U2l6ZSAmJiBpIDw8IDEgPCBwb3MgJiYgaSA8PCAxIDwgKChwb3MgLSA3KSB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGdyYWRlZGVkQXJyYXlTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbiAqIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wUmVzdWx0LnNldChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG1wUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0gKDB4ZSAvKjBiMTExMCovIDw8IDQpIHwgKHBvaW50ID4+IDEyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkgPyByZXN1bHQuc3ViYXJyYXkoMCwgcG9zKSA6IHJlc3VsdC5zbGljZSgwLCBwb3MpO1xuICAgIH1cbiAgICBlbmNvZGVJbnRvKGlucHV0U3RyaW5nLCB1OEFycikge1xuICAgICAgICBjb25zdCBlbmNvZGVkU3RyaW5nID0gaW5wdXRTdHJpbmcgPT09IHZvaWQgMCA/ICcnIDogKCcnICsgaW5wdXRTdHJpbmcpLnJlcGxhY2UoZW5jb2RlclJlZ2V4cCwgZW5jb2RlclJlcGxhY2VyKTtcbiAgICAgICAgbGV0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoIHwgMCwgaSA9IDAsIGNoYXIgPSAwLCByZWFkID0gMDtcbiAgICAgICAgY29uc3QgdThBcnJMZW4gPSB1OEFyci5sZW5ndGggfCAwO1xuICAgICAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0U3RyaW5nLmxlbmd0aCB8IDA7XG4gICAgICAgIGlmICh1OEFyckxlbiA8IGxlbilcbiAgICAgICAgICAgIGxlbiA9IHU4QXJyTGVuO1xuICAgICAgICBwdXRDaGFyczoge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgPSAoaSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBlbmNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSkgfCAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhciA+PiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBleHRlbnNpb24gcG9pbnRzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoaSArIDEpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQgPSAocmVhZCArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGkgKyAyKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmICghKGNoYXIgPT09IDB4RUYgJiYgZW5jb2RlZFN0cmluZy5zdWJzdHIoaSsxfDAsMikgPT09IFwiXFx4QkZcXHhCRFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChpICsgMykgfCAwKSA8IHU4QXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcHV0Q2hhcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vcmVhZCA9IHJlYWQgKyAoKGNoYXIgPj4gNikgIT09IDIpIHwwO1xuICAgICAgICAgICAgICAgIHU4QXJyW2ldID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB3cml0dGVuOiBpLCByZWFkOiBpbnB1dExlbmd0aCA8IHJlYWQgPyBpbnB1dExlbmd0aCA6IHJlYWQgfTtcbiAgICB9XG59XG5leHBvcnRzLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/encoding.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/errors.js':
      /*!*******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/errors.js ***!
  \*******************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorMessage = exports.IllegalStateError = exports.DataConverterError = exports.ValueError = void 0;\nclass ValueError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ValueError';\n    }\n}\nexports.ValueError = ValueError;\nclass DataConverterError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DataConverterError';\n    }\n}\nexports.DataConverterError = DataConverterError;\n/**\n * Used in different parts of the project to signal that something unexpected has happened\n */\nclass IllegalStateError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'IllegalStateError';\n    }\n}\nexports.IllegalStateError = IllegalStateError;\n/**\n * Get error message from an Error or string or return undefined\n */\nfunction errorMessage(err) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err instanceof Error) {\n        return err.message;\n    }\n    return undefined;\n}\nexports.errorMessage = errorMessage;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9lcnJvcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEdBQUcsa0JBQWtCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL2Vycm9ycy5qcz9lZWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lcnJvck1lc3NhZ2UgPSBleHBvcnRzLklsbGVnYWxTdGF0ZUVycm9yID0gZXhwb3J0cy5EYXRhQ29udmVydGVyRXJyb3IgPSBleHBvcnRzLlZhbHVlRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVmFsdWVFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZUVycm9yID0gVmFsdWVFcnJvcjtcbmNsYXNzIERhdGFDb252ZXJ0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RhdGFDb252ZXJ0ZXJFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhQ29udmVydGVyRXJyb3IgPSBEYXRhQ29udmVydGVyRXJyb3I7XG4vKipcbiAqIFVzZWQgaW4gZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBwcm9qZWN0IHRvIHNpZ25hbCB0aGF0IHNvbWV0aGluZyB1bmV4cGVjdGVkIGhhcyBoYXBwZW5lZFxuICovXG5jbGFzcyBJbGxlZ2FsU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0lsbGVnYWxTdGF0ZUVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLklsbGVnYWxTdGF0ZUVycm9yID0gSWxsZWdhbFN0YXRlRXJyb3I7XG4vKipcbiAqIEdldCBlcnJvciBtZXNzYWdlIGZyb20gYW4gRXJyb3Igb3Igc3RyaW5nIG9yIHJldHVybiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycikge1xuICAgIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/errors.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/failure.js':
      /*!********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/failure.js ***!
  \********************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.rootCause = exports.failureToError = exports.failureToErrorInner = exports.optionalFailureToOptionalError = exports.ensureTemporalFailure = exports.errorToFailure = exports.cutoffStackTrace = exports.optionalErrorToOptionalFailure = exports.ChildWorkflowFailure = exports.ActivityFailure = exports.TimeoutFailure = exports.TerminatedFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ServerFailure = exports.TemporalFailure = exports.RetryState = exports.TimeoutType = exports.FAILURE_SOURCE = void 0;\nconst data_converter_1 = __webpack_require__(/*! ./converter/data-converter */ "./node_modules/@temporalio/common/lib/converter/data-converter.js");\nconst type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");\nexports.FAILURE_SOURCE = \'TypeScriptSDK\';\n// Avoid importing the proto implementation to reduce workflow bundle size\n// Copied from temporal.api.enums.v1.TimeoutType\nvar TimeoutType;\n(function (TimeoutType) {\n    TimeoutType[TimeoutType["TIMEOUT_TYPE_UNSPECIFIED"] = 0] = "TIMEOUT_TYPE_UNSPECIFIED";\n    TimeoutType[TimeoutType["TIMEOUT_TYPE_START_TO_CLOSE"] = 1] = "TIMEOUT_TYPE_START_TO_CLOSE";\n    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_START"] = 2] = "TIMEOUT_TYPE_SCHEDULE_TO_START";\n    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_CLOSE"] = 3] = "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE";\n    TimeoutType[TimeoutType["TIMEOUT_TYPE_HEARTBEAT"] = 4] = "TIMEOUT_TYPE_HEARTBEAT";\n})(TimeoutType = exports.TimeoutType || (exports.TimeoutType = {}));\n(0, type_helpers_1.checkExtends)();\n// Avoid importing the proto implementation to reduce workflow bundle size\n// Copied from temporal.api.enums.v1.RetryState\nvar RetryState;\n(function (RetryState) {\n    RetryState[RetryState["RETRY_STATE_UNSPECIFIED"] = 0] = "RETRY_STATE_UNSPECIFIED";\n    RetryState[RetryState["RETRY_STATE_IN_PROGRESS"] = 1] = "RETRY_STATE_IN_PROGRESS";\n    RetryState[RetryState["RETRY_STATE_NON_RETRYABLE_FAILURE"] = 2] = "RETRY_STATE_NON_RETRYABLE_FAILURE";\n    RetryState[RetryState["RETRY_STATE_TIMEOUT"] = 3] = "RETRY_STATE_TIMEOUT";\n    RetryState[RetryState["RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED"] = 4] = "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED";\n    RetryState[RetryState["RETRY_STATE_RETRY_POLICY_NOT_SET"] = 5] = "RETRY_STATE_RETRY_POLICY_NOT_SET";\n    RetryState[RetryState["RETRY_STATE_INTERNAL_SERVER_ERROR"] = 6] = "RETRY_STATE_INTERNAL_SERVER_ERROR";\n    RetryState[RetryState["RETRY_STATE_CANCEL_REQUESTED"] = 7] = "RETRY_STATE_CANCEL_REQUESTED";\n})(RetryState = exports.RetryState || (exports.RetryState = {}));\n(0, type_helpers_1.checkExtends)();\n/**\n * Represents failures that can cross Workflow and Activity boundaries.\n *\n * Only exceptions that extend this class will be propagated to the caller.\n *\n * **Never extend this class or any of its derivatives.** They are to be used by the SDK code\n * only. Throw an instance {@link ApplicationFailure} to pass application specific errors between\n * Workflows and Activities.\n *\n * Any unhandled exception thrown by an Activity or Workflow will be converted to an instance of\n * {@link ApplicationFailure}.\n */\nclass TemporalFailure extends Error {\n    constructor(message, cause) {\n        super(message ?? undefined);\n        this.cause = cause;\n        this.name = \'TemporalFailure\';\n    }\n}\nexports.TemporalFailure = TemporalFailure;\n/** Exceptions originated at the Temporal service. */\nclass ServerFailure extends TemporalFailure {\n    constructor(message, nonRetryable, cause) {\n        super(message, cause);\n        this.nonRetryable = nonRetryable;\n        this.name = \'ServerFailure\';\n    }\n}\nexports.ServerFailure = ServerFailure;\n/**\n * Application failure is used to communicate application specific failures between Workflows and\n * Activities.\n *\n * Throw this exception to have full control over type and details if the exception delivered to\n * the caller workflow or client.\n *\n * Any unhandled exception which doesn\'t extend {@link TemporalFailure} is converted to an\n * instance of this class before being returned to a caller.\n *\n * The {@link type} property is used by {@link io.temporal.common.RetryOptions} to determine if\n * an instance of this exception is non retryable. Another way to avoid retrying an exception of\n * this type is by setting {@link nonRetryable} flag to `true`.\n *\n * The conversion of an exception that doesn\'t extend {@link TemporalFailure} to an\n * ApplicationFailure is done as following:\n *\n * - type is set to the exception full type name.\n * - message is set to the exception message\n * - nonRetryable is set to false\n * - details are set to null\n * - stack trace is copied from the original exception\n */\nclass ApplicationFailure extends TemporalFailure {\n    constructor(message, type, nonRetryable, details, cause) {\n        super(message, cause);\n        this.type = type;\n        this.nonRetryable = nonRetryable;\n        this.details = details;\n        this.name = \'ApplicationFailure\';\n    }\n    /**\n     * New ApplicationFailure with {@link nonRetryable} flag set to false. Note that this\n     * exception still can be not retried by the service if its type is included into doNotRetry\n     * property of the correspondent retry policy.\n     *\n     * @param message optional error message\n     * @param type optional error type that is used by {@link RetryOptions.nonRetryableErrorTypes}.\n     * @param details optional details about the failure. They are serialized using the same approach\n     *     as arguments and results.\n     */\n    static retryable(message, type, ...details) {\n        return new this(message, type ?? \'Error\', false, details);\n    }\n    /**\n     * New ApplicationFailure with {@link nonRetryable} flag set to true.\n     *\n     * It means that this exception is not going to be retried even if it is not included into\n     * retry policy doNotRetry list.\n     *\n     * @param message optional error message\n     * @param type optional error type\n     * @param details optional details about the failure. They are serialized using the same approach\n     *     as arguments and results.\n     */\n    static nonRetryable(message, type, ...details) {\n        return new this(message, type ?? \'Error\', true, details);\n    }\n}\nexports.ApplicationFailure = ApplicationFailure;\n/**\n * Used as the cause for when a Workflow or Activity has been cancelled\n */\nclass CancelledFailure extends TemporalFailure {\n    constructor(message, details = [], cause) {\n        super(message, cause);\n        this.details = details;\n        this.name = \'CancelledFailure\';\n    }\n}\nexports.CancelledFailure = CancelledFailure;\n/**\n * Used as the cause for when a Workflow has been terminated\n */\nclass TerminatedFailure extends TemporalFailure {\n    constructor(message, cause) {\n        super(message, cause);\n        this.name = \'TerminatedFailure\';\n    }\n}\nexports.TerminatedFailure = TerminatedFailure;\n/**\n * Used to represent timeouts of Activities and Workflows\n */\nclass TimeoutFailure extends TemporalFailure {\n    constructor(message, lastHeartbeatDetails, timeoutType) {\n        super(message);\n        this.lastHeartbeatDetails = lastHeartbeatDetails;\n        this.timeoutType = timeoutType;\n        this.name = \'TimeoutFailure\';\n    }\n}\nexports.TimeoutFailure = TimeoutFailure;\n/**\n * Contains information about an activity failure. Always contains the original reason for the\n * failure as its cause. For example if an activity timed out the cause is {@link TimeoutFailure}.\n *\n * This exception is expected to be thrown only by the framework code.\n */\nclass ActivityFailure extends TemporalFailure {\n    constructor(activityType, activityId, retryState, identity, cause) {\n        super(\'Activity execution failed\', cause);\n        this.activityType = activityType;\n        this.activityId = activityId;\n        this.retryState = retryState;\n        this.identity = identity;\n    }\n}\nexports.ActivityFailure = ActivityFailure;\n/**\n * Contains information about an child workflow failure. Always contains the original reason for the\n * failure as its cause. For example if a child workflow was terminated the cause is {@link TerminatedFailure}.\n *\n * This exception is expected to be thrown only by the framework code.\n */\nclass ChildWorkflowFailure extends TemporalFailure {\n    constructor(namespace, execution, workflowType, retryState, cause) {\n        super(\'Child Workflow execution failed\', cause);\n        this.namespace = namespace;\n        this.execution = execution;\n        this.workflowType = workflowType;\n        this.retryState = retryState;\n    }\n}\nexports.ChildWorkflowFailure = ChildWorkflowFailure;\n/**\n * Converts an error to a Failure proto message if defined or returns undefined\n */\nasync function optionalErrorToOptionalFailure(err, dataConverter) {\n    return err ? await errorToFailure(err, dataConverter) : undefined;\n}\nexports.optionalErrorToOptionalFailure = optionalErrorToOptionalFailure;\n/**\n * Stack traces will be cutoff when on of these patterns is matched\n */\nconst CUTTOFF_STACK_PATTERNS = [\n    /** Activity execution */\n    /\\s+at Activity\\.execute \\(.*[\\\\/]worker[\\\\/](?:src|lib)[\\\\/]activity\\.[jt]s:\\d+:\\d+\\)/,\n    /** Workflow activation */\n    /\\s+at Activator\\.\\S+NextHandler \\(webpack-internal:\\/\\/\\/.*\\/internals\\.[jt]s:\\d+:\\d+\\)/,\n];\n/**\n * Cuts out the framework part of a stack trace, leaving only user code entries\n */\nfunction cutoffStackTrace(stack) {\n    const lines = (stack ?? \'\').split(/\\r?\\n/);\n    const acc = Array();\n    lineLoop: for (const line of lines) {\n        for (const pattern of CUTTOFF_STACK_PATTERNS) {\n            if (pattern.test(line))\n                break lineLoop;\n        }\n        acc.push(line);\n    }\n    return acc.join(\'\\n\');\n}\nexports.cutoffStackTrace = cutoffStackTrace;\n/**\n * Converts a caught error to a Failure proto message\n */\nasync function errorToFailure(err, dataConverter) {\n    if (err instanceof TemporalFailure) {\n        if (err.failure)\n            return err.failure;\n        const base = {\n            message: err.message,\n            stackTrace: cutoffStackTrace(err.stack),\n            cause: await optionalErrorToOptionalFailure(err.cause, dataConverter),\n            source: exports.FAILURE_SOURCE,\n        };\n        if (err instanceof ActivityFailure) {\n            return {\n                ...base,\n                activityFailureInfo: {\n                    ...err,\n                    activityType: { name: err.activityType },\n                },\n            };\n        }\n        if (err instanceof ChildWorkflowFailure) {\n            return {\n                ...base,\n                childWorkflowExecutionFailureInfo: {\n                    ...err,\n                    workflowExecution: err.execution,\n                    workflowType: { name: err.workflowType },\n                },\n            };\n        }\n        if (err instanceof ApplicationFailure) {\n            return {\n                ...base,\n                applicationFailureInfo: {\n                    type: err.type,\n                    nonRetryable: err.nonRetryable,\n                    details: err.details && err.details.length\n                        ? { payloads: await dataConverter.toPayloads(...err.details) }\n                        : undefined,\n                },\n            };\n        }\n        if (err instanceof CancelledFailure) {\n            return {\n                ...base,\n                canceledFailureInfo: {\n                    details: err.details && err.details.length\n                        ? { payloads: await dataConverter.toPayloads(...err.details) }\n                        : undefined,\n                },\n            };\n        }\n        if (err instanceof TimeoutFailure) {\n            return {\n                ...base,\n                timeoutFailureInfo: {\n                    timeoutType: err.timeoutType,\n                    lastHeartbeatDetails: err.lastHeartbeatDetails\n                        ? { payloads: await dataConverter.toPayloads(err.lastHeartbeatDetails) }\n                        : undefined,\n                },\n            };\n        }\n        if (err instanceof TerminatedFailure) {\n            return {\n                ...base,\n                terminatedFailureInfo: {},\n            };\n        }\n        if (err instanceof ServerFailure) {\n            return {\n                ...base,\n                serverFailureInfo: { nonRetryable: err.nonRetryable },\n            };\n        }\n        // Just a TemporalFailure\n        return base;\n    }\n    const base = {\n        source: exports.FAILURE_SOURCE,\n    };\n    if (err instanceof Error) {\n        return { ...base, message: err.message ?? \'\', stackTrace: cutoffStackTrace(err.stack) };\n    }\n    if (typeof err === \'string\') {\n        return { ...base, message: err };\n    }\n    return { ...base, message: String(err) };\n}\nexports.errorToFailure = errorToFailure;\n/**\n * If `err` is an Error it is turned into an `ApplicationFailure`.\n *\n * If `err` was already a `TemporalFailure`, returns the original error.\n *\n * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.\n */\nfunction ensureTemporalFailure(err) {\n    if (err instanceof TemporalFailure) {\n        return err;\n    }\n    else if (err instanceof Error) {\n        const failure = new ApplicationFailure(err.message, err.name, false);\n        failure.stack = err.stack;\n        return failure;\n    }\n    else {\n        const failure = new ApplicationFailure(String(err), undefined, false);\n        failure.stack = \'\';\n        return failure;\n    }\n}\nexports.ensureTemporalFailure = ensureTemporalFailure;\n/**\n * Converts a Failure proto message to a JS Error object if defined or returns undefined.\n */\nasync function optionalFailureToOptionalError(failure, dataConverter) {\n    return failure ? await failureToError(failure, dataConverter) : undefined;\n}\nexports.optionalFailureToOptionalError = optionalFailureToOptionalError;\n/**\n * Converts a Failure proto message to a JS Error object.\n *\n * Does not set common properties, that is done in {@link failureToError}.\n */\nasync function failureToErrorInner(failure, dataConverter) {\n    if (failure.applicationFailureInfo) {\n        return new ApplicationFailure(failure.message ?? undefined, failure.applicationFailureInfo.type, Boolean(failure.applicationFailureInfo.nonRetryable), await (0, data_converter_1.arrayFromPayloads)(dataConverter, failure.applicationFailureInfo.details?.payloads), await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.serverFailureInfo) {\n        return new ServerFailure(failure.message ?? undefined, Boolean(failure.serverFailureInfo.nonRetryable), await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.timeoutFailureInfo) {\n        return new TimeoutFailure(failure.message ?? undefined, await dataConverter.fromPayloads(0, failure.timeoutFailureInfo.lastHeartbeatDetails?.payloads), failure.timeoutFailureInfo.timeoutType ?? TimeoutType.TIMEOUT_TYPE_UNSPECIFIED);\n    }\n    if (failure.terminatedFailureInfo) {\n        return new TerminatedFailure(failure.message ?? undefined, await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.canceledFailureInfo) {\n        return new CancelledFailure(failure.message ?? undefined, await (0, data_converter_1.arrayFromPayloads)(dataConverter, failure.canceledFailureInfo.details?.payloads), await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.resetWorkflowFailureInfo) {\n        return new ApplicationFailure(failure.message ?? undefined, \'ResetWorkflow\', false, await (0, data_converter_1.arrayFromPayloads)(dataConverter, failure.resetWorkflowFailureInfo.lastHeartbeatDetails?.payloads), await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.childWorkflowExecutionFailureInfo) {\n        const { namespace, workflowType, workflowExecution, retryState } = failure.childWorkflowExecutionFailureInfo;\n        if (!(workflowType?.name && workflowExecution)) {\n            throw new TypeError(\'Missing attributes on childWorkflowExecutionFailureInfo\');\n        }\n        return new ChildWorkflowFailure(namespace ?? undefined, workflowExecution, workflowType.name, retryState ?? RetryState.RETRY_STATE_UNSPECIFIED, await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    if (failure.activityFailureInfo) {\n        if (!failure.activityFailureInfo.activityType?.name) {\n            throw new TypeError(\'Missing activityType?.name on activityFailureInfo\');\n        }\n        return new ActivityFailure(failure.activityFailureInfo.activityType.name, failure.activityFailureInfo.activityId ?? undefined, failure.activityFailureInfo.retryState ?? RetryState.RETRY_STATE_UNSPECIFIED, failure.activityFailureInfo.identity ?? undefined, await optionalFailureToOptionalError(failure.cause, dataConverter));\n    }\n    return new TemporalFailure(failure.message ?? undefined, await optionalFailureToOptionalError(failure.cause, dataConverter));\n}\nexports.failureToErrorInner = failureToErrorInner;\n/**\n * Converts a Failure proto message to a JS Error object.\n */\nasync function failureToError(failure, dataConverter) {\n    const err = await failureToErrorInner(failure, dataConverter);\n    err.stack = failure.stackTrace ?? \'\';\n    err.failure = failure;\n    return err;\n}\nexports.failureToError = failureToError;\n/**\n * Get the root cause (string) of given error `err`.\n *\n * In case `err` is a {@link TemporalFailure}, recurse the cause chain and return the root\'s message.\n * Otherwise, return `err.message`.\n */\nfunction rootCause(err) {\n    if (err instanceof TemporalFailure) {\n        return err.cause ? rootCause(err.cause) : err.message;\n    }\n    if (err instanceof Error) {\n        return err.message;\n    }\n    if (typeof err === \'string\') {\n        return err;\n    }\n    return undefined;\n}\nexports.rootCause = rootCause;\n//# sourceMappingURL=failure.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9mYWlsdXJlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLDJCQUEyQixHQUFHLHNDQUFzQyxHQUFHLDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLHNDQUFzQyxHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQjtBQUMxZ0IseUJBQXlCLG1CQUFPLENBQUMscUdBQTRCO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLDZFQUFnQjtBQUMvQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsbUJBQW1CLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0EsUUFBUSxZQUFZLHFCQUFxQix1Q0FBdUM7QUFDaEY7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0EsdURBQXVELHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwwQ0FBMEM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSw0RUFBNEUscUJBQXFCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esc0ZBQXNGLHdCQUF3QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9mYWlsdXJlLmpzP2FhNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJvb3RDYXVzZSA9IGV4cG9ydHMuZmFpbHVyZVRvRXJyb3IgPSBleHBvcnRzLmZhaWx1cmVUb0Vycm9ySW5uZXIgPSBleHBvcnRzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvciA9IGV4cG9ydHMuZW5zdXJlVGVtcG9yYWxGYWlsdXJlID0gZXhwb3J0cy5lcnJvclRvRmFpbHVyZSA9IGV4cG9ydHMuY3V0b2ZmU3RhY2tUcmFjZSA9IGV4cG9ydHMub3B0aW9uYWxFcnJvclRvT3B0aW9uYWxGYWlsdXJlID0gZXhwb3J0cy5DaGlsZFdvcmtmbG93RmFpbHVyZSA9IGV4cG9ydHMuQWN0aXZpdHlGYWlsdXJlID0gZXhwb3J0cy5UaW1lb3V0RmFpbHVyZSA9IGV4cG9ydHMuVGVybWluYXRlZEZhaWx1cmUgPSBleHBvcnRzLkNhbmNlbGxlZEZhaWx1cmUgPSBleHBvcnRzLkFwcGxpY2F0aW9uRmFpbHVyZSA9IGV4cG9ydHMuU2VydmVyRmFpbHVyZSA9IGV4cG9ydHMuVGVtcG9yYWxGYWlsdXJlID0gZXhwb3J0cy5SZXRyeVN0YXRlID0gZXhwb3J0cy5UaW1lb3V0VHlwZSA9IGV4cG9ydHMuRkFJTFVSRV9TT1VSQ0UgPSB2b2lkIDA7XG5jb25zdCBkYXRhX2NvbnZlcnRlcl8xID0gcmVxdWlyZShcIi4vY29udmVydGVyL2RhdGEtY29udmVydGVyXCIpO1xuY29uc3QgdHlwZV9oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90eXBlLWhlbHBlcnNcIik7XG5leHBvcnRzLkZBSUxVUkVfU09VUkNFID0gJ1R5cGVTY3JpcHRTREsnO1xuLy8gQXZvaWQgaW1wb3J0aW5nIHRoZSBwcm90byBpbXBsZW1lbnRhdGlvbiB0byByZWR1Y2Ugd29ya2Zsb3cgYnVuZGxlIHNpemVcbi8vIENvcGllZCBmcm9tIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5UaW1lb3V0VHlwZVxudmFyIFRpbWVvdXRUeXBlO1xuKGZ1bmN0aW9uIChUaW1lb3V0VHlwZSkge1xuICAgIFRpbWVvdXRUeXBlW1RpbWVvdXRUeXBlW1wiVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlRJTUVPVVRfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIFRpbWVvdXRUeXBlW1RpbWVvdXRUeXBlW1wiVElNRU9VVF9UWVBFX1NUQVJUX1RPX0NMT1NFXCJdID0gMV0gPSBcIlRJTUVPVVRfVFlQRV9TVEFSVF9UT19DTE9TRVwiO1xuICAgIFRpbWVvdXRUeXBlW1RpbWVvdXRUeXBlW1wiVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX1NUQVJUXCJdID0gMl0gPSBcIlRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19TVEFSVFwiO1xuICAgIFRpbWVvdXRUeXBlW1RpbWVvdXRUeXBlW1wiVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX0NMT1NFXCJdID0gM10gPSBcIlRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19DTE9TRVwiO1xuICAgIFRpbWVvdXRUeXBlW1RpbWVvdXRUeXBlW1wiVElNRU9VVF9UWVBFX0hFQVJUQkVBVFwiXSA9IDRdID0gXCJUSU1FT1VUX1RZUEVfSEVBUlRCRUFUXCI7XG59KShUaW1lb3V0VHlwZSA9IGV4cG9ydHMuVGltZW91dFR5cGUgfHwgKGV4cG9ydHMuVGltZW91dFR5cGUgPSB7fSkpO1xuKDAsIHR5cGVfaGVscGVyc18xLmNoZWNrRXh0ZW5kcykoKTtcbi8vIEF2b2lkIGltcG9ydGluZyB0aGUgcHJvdG8gaW1wbGVtZW50YXRpb24gdG8gcmVkdWNlIHdvcmtmbG93IGJ1bmRsZSBzaXplXG4vLyBDb3BpZWQgZnJvbSB0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZVxudmFyIFJldHJ5U3RhdGU7XG4oZnVuY3Rpb24gKFJldHJ5U3RhdGUpIHtcbiAgICBSZXRyeVN0YXRlW1JldHJ5U3RhdGVbXCJSRVRSWV9TVEFURV9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJSRVRSWV9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIFJldHJ5U3RhdGVbUmV0cnlTdGF0ZVtcIlJFVFJZX1NUQVRFX0lOX1BST0dSRVNTXCJdID0gMV0gPSBcIlJFVFJZX1NUQVRFX0lOX1BST0dSRVNTXCI7XG4gICAgUmV0cnlTdGF0ZVtSZXRyeVN0YXRlW1wiUkVUUllfU1RBVEVfTk9OX1JFVFJZQUJMRV9GQUlMVVJFXCJdID0gMl0gPSBcIlJFVFJZX1NUQVRFX05PTl9SRVRSWUFCTEVfRkFJTFVSRVwiO1xuICAgIFJldHJ5U3RhdGVbUmV0cnlTdGF0ZVtcIlJFVFJZX1NUQVRFX1RJTUVPVVRcIl0gPSAzXSA9IFwiUkVUUllfU1RBVEVfVElNRU9VVFwiO1xuICAgIFJldHJ5U3RhdGVbUmV0cnlTdGF0ZVtcIlJFVFJZX1NUQVRFX01BWElNVU1fQVRURU1QVFNfUkVBQ0hFRFwiXSA9IDRdID0gXCJSRVRSWV9TVEFURV9NQVhJTVVNX0FUVEVNUFRTX1JFQUNIRURcIjtcbiAgICBSZXRyeVN0YXRlW1JldHJ5U3RhdGVbXCJSRVRSWV9TVEFURV9SRVRSWV9QT0xJQ1lfTk9UX1NFVFwiXSA9IDVdID0gXCJSRVRSWV9TVEFURV9SRVRSWV9QT0xJQ1lfTk9UX1NFVFwiO1xuICAgIFJldHJ5U3RhdGVbUmV0cnlTdGF0ZVtcIlJFVFJZX1NUQVRFX0lOVEVSTkFMX1NFUlZFUl9FUlJPUlwiXSA9IDZdID0gXCJSRVRSWV9TVEFURV9JTlRFUk5BTF9TRVJWRVJfRVJST1JcIjtcbiAgICBSZXRyeVN0YXRlW1JldHJ5U3RhdGVbXCJSRVRSWV9TVEFURV9DQU5DRUxfUkVRVUVTVEVEXCJdID0gN10gPSBcIlJFVFJZX1NUQVRFX0NBTkNFTF9SRVFVRVNURURcIjtcbn0pKFJldHJ5U3RhdGUgPSBleHBvcnRzLlJldHJ5U3RhdGUgfHwgKGV4cG9ydHMuUmV0cnlTdGF0ZSA9IHt9KSk7XG4oMCwgdHlwZV9oZWxwZXJzXzEuY2hlY2tFeHRlbmRzKSgpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGZhaWx1cmVzIHRoYXQgY2FuIGNyb3NzIFdvcmtmbG93IGFuZCBBY3Rpdml0eSBib3VuZGFyaWVzLlxuICpcbiAqIE9ubHkgZXhjZXB0aW9ucyB0aGF0IGV4dGVuZCB0aGlzIGNsYXNzIHdpbGwgYmUgcHJvcGFnYXRlZCB0byB0aGUgY2FsbGVyLlxuICpcbiAqICoqTmV2ZXIgZXh0ZW5kIHRoaXMgY2xhc3Mgb3IgYW55IG9mIGl0cyBkZXJpdmF0aXZlcy4qKiBUaGV5IGFyZSB0byBiZSB1c2VkIGJ5IHRoZSBTREsgY29kZVxuICogb25seS4gVGhyb3cgYW4gaW5zdGFuY2Uge0BsaW5rIEFwcGxpY2F0aW9uRmFpbHVyZX0gdG8gcGFzcyBhcHBsaWNhdGlvbiBzcGVjaWZpYyBlcnJvcnMgYmV0d2VlblxuICogV29ya2Zsb3dzIGFuZCBBY3Rpdml0aWVzLlxuICpcbiAqIEFueSB1bmhhbmRsZWQgZXhjZXB0aW9uIHRocm93biBieSBhbiBBY3Rpdml0eSBvciBXb3JrZmxvdyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnN0YW5jZSBvZlxuICoge0BsaW5rIEFwcGxpY2F0aW9uRmFpbHVyZX0uXG4gKi9cbmNsYXNzIFRlbXBvcmFsRmFpbHVyZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RlbXBvcmFsRmFpbHVyZSc7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wb3JhbEZhaWx1cmUgPSBUZW1wb3JhbEZhaWx1cmU7XG4vKiogRXhjZXB0aW9ucyBvcmlnaW5hdGVkIGF0IHRoZSBUZW1wb3JhbCBzZXJ2aWNlLiAqL1xuY2xhc3MgU2VydmVyRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbm9uUmV0cnlhYmxlLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMubm9uUmV0cnlhYmxlID0gbm9uUmV0cnlhYmxlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU2VydmVyRmFpbHVyZSc7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJGYWlsdXJlID0gU2VydmVyRmFpbHVyZTtcbi8qKlxuICogQXBwbGljYXRpb24gZmFpbHVyZSBpcyB1c2VkIHRvIGNvbW11bmljYXRlIGFwcGxpY2F0aW9uIHNwZWNpZmljIGZhaWx1cmVzIGJldHdlZW4gV29ya2Zsb3dzIGFuZFxuICogQWN0aXZpdGllcy5cbiAqXG4gKiBUaHJvdyB0aGlzIGV4Y2VwdGlvbiB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHR5cGUgYW5kIGRldGFpbHMgaWYgdGhlIGV4Y2VwdGlvbiBkZWxpdmVyZWQgdG9cbiAqIHRoZSBjYWxsZXIgd29ya2Zsb3cgb3IgY2xpZW50LlxuICpcbiAqIEFueSB1bmhhbmRsZWQgZXhjZXB0aW9uIHdoaWNoIGRvZXNuJ3QgZXh0ZW5kIHtAbGluayBUZW1wb3JhbEZhaWx1cmV9IGlzIGNvbnZlcnRlZCB0byBhblxuICogaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBiZWZvcmUgYmVpbmcgcmV0dXJuZWQgdG8gYSBjYWxsZXIuXG4gKlxuICogVGhlIHtAbGluayB0eXBlfSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IHtAbGluayBpby50ZW1wb3JhbC5jb21tb24uUmV0cnlPcHRpb25zfSB0byBkZXRlcm1pbmUgaWZcbiAqIGFuIGluc3RhbmNlIG9mIHRoaXMgZXhjZXB0aW9uIGlzIG5vbiByZXRyeWFibGUuIEFub3RoZXIgd2F5IHRvIGF2b2lkIHJldHJ5aW5nIGFuIGV4Y2VwdGlvbiBvZlxuICogdGhpcyB0eXBlIGlzIGJ5IHNldHRpbmcge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyB0byBgdHJ1ZWAuXG4gKlxuICogVGhlIGNvbnZlcnNpb24gb2YgYW4gZXhjZXB0aW9uIHRoYXQgZG9lc24ndCBleHRlbmQge0BsaW5rIFRlbXBvcmFsRmFpbHVyZX0gdG8gYW5cbiAqIEFwcGxpY2F0aW9uRmFpbHVyZSBpcyBkb25lIGFzIGZvbGxvd2luZzpcbiAqXG4gKiAtIHR5cGUgaXMgc2V0IHRvIHRoZSBleGNlcHRpb24gZnVsbCB0eXBlIG5hbWUuXG4gKiAtIG1lc3NhZ2UgaXMgc2V0IHRvIHRoZSBleGNlcHRpb24gbWVzc2FnZVxuICogLSBub25SZXRyeWFibGUgaXMgc2V0IHRvIGZhbHNlXG4gKiAtIGRldGFpbHMgYXJlIHNldCB0byBudWxsXG4gKiAtIHN0YWNrIHRyYWNlIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBleGNlcHRpb25cbiAqL1xuY2xhc3MgQXBwbGljYXRpb25GYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGUsIGRldGFpbHMsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5ub25SZXRyeWFibGUgPSBub25SZXRyeWFibGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBcHBsaWNhdGlvbkZhaWx1cmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZXcgQXBwbGljYXRpb25GYWlsdXJlIHdpdGgge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyBzZXQgdG8gZmFsc2UuIE5vdGUgdGhhdCB0aGlzXG4gICAgICogZXhjZXB0aW9uIHN0aWxsIGNhbiBiZSBub3QgcmV0cmllZCBieSB0aGUgc2VydmljZSBpZiBpdHMgdHlwZSBpcyBpbmNsdWRlZCBpbnRvIGRvTm90UmV0cnlcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGUgY29ycmVzcG9uZGVudCByZXRyeSBwb2xpY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBvcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHR5cGUgb3B0aW9uYWwgZXJyb3IgdHlwZSB0aGF0IGlzIHVzZWQgYnkge0BsaW5rIFJldHJ5T3B0aW9ucy5ub25SZXRyeWFibGVFcnJvclR5cGVzfS5cbiAgICAgKiBAcGFyYW0gZGV0YWlscyBvcHRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlLiBUaGV5IGFyZSBzZXJpYWxpemVkIHVzaW5nIHRoZSBzYW1lIGFwcHJvYWNoXG4gICAgICogICAgIGFzIGFyZ3VtZW50cyBhbmQgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmV0cnlhYmxlKG1lc3NhZ2UsIHR5cGUsIC4uLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUgPz8gJ0Vycm9yJywgZmFsc2UsIGRldGFpbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZXcgQXBwbGljYXRpb25GYWlsdXJlIHdpdGgge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyBzZXQgdG8gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEl0IG1lYW5zIHRoYXQgdGhpcyBleGNlcHRpb24gaXMgbm90IGdvaW5nIHRvIGJlIHJldHJpZWQgZXZlbiBpZiBpdCBpcyBub3QgaW5jbHVkZWQgaW50b1xuICAgICAqIHJldHJ5IHBvbGljeSBkb05vdFJldHJ5IGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBvcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHR5cGUgb3B0aW9uYWwgZXJyb3IgdHlwZVxuICAgICAqIEBwYXJhbSBkZXRhaWxzIG9wdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUuIFRoZXkgYXJlIHNlcmlhbGl6ZWQgdXNpbmcgdGhlIHNhbWUgYXBwcm9hY2hcbiAgICAgKiAgICAgYXMgYXJndW1lbnRzIGFuZCByZXN1bHRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBub25SZXRyeWFibGUobWVzc2FnZSwgdHlwZSwgLi4uZGV0YWlscykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMobWVzc2FnZSwgdHlwZSA/PyAnRXJyb3InLCB0cnVlLCBkZXRhaWxzKTtcbiAgICB9XG59XG5leHBvcnRzLkFwcGxpY2F0aW9uRmFpbHVyZSA9IEFwcGxpY2F0aW9uRmFpbHVyZTtcbi8qKlxuICogVXNlZCBhcyB0aGUgY2F1c2UgZm9yIHdoZW4gYSBXb3JrZmxvdyBvciBBY3Rpdml0eSBoYXMgYmVlbiBjYW5jZWxsZWRcbiAqL1xuY2xhc3MgQ2FuY2VsbGVkRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IFtdLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDYW5jZWxsZWRGYWlsdXJlJztcbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxlZEZhaWx1cmUgPSBDYW5jZWxsZWRGYWlsdXJlO1xuLyoqXG4gKiBVc2VkIGFzIHRoZSBjYXVzZSBmb3Igd2hlbiBhIFdvcmtmbG93IGhhcyBiZWVuIHRlcm1pbmF0ZWRcbiAqL1xuY2xhc3MgVGVybWluYXRlZEZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rlcm1pbmF0ZWRGYWlsdXJlJztcbiAgICB9XG59XG5leHBvcnRzLlRlcm1pbmF0ZWRGYWlsdXJlID0gVGVybWluYXRlZEZhaWx1cmU7XG4vKipcbiAqIFVzZWQgdG8gcmVwcmVzZW50IHRpbWVvdXRzIG9mIEFjdGl2aXRpZXMgYW5kIFdvcmtmbG93c1xuICovXG5jbGFzcyBUaW1lb3V0RmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbGFzdEhlYXJ0YmVhdERldGFpbHMsIHRpbWVvdXRUeXBlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxhc3RIZWFydGJlYXREZXRhaWxzID0gbGFzdEhlYXJ0YmVhdERldGFpbHM7XG4gICAgICAgIHRoaXMudGltZW91dFR5cGUgPSB0aW1lb3V0VHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRGYWlsdXJlJztcbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRGYWlsdXJlID0gVGltZW91dEZhaWx1cmU7XG4vKipcbiAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGFuIGFjdGl2aXR5IGZhaWx1cmUuIEFsd2F5cyBjb250YWlucyB0aGUgb3JpZ2luYWwgcmVhc29uIGZvciB0aGVcbiAqIGZhaWx1cmUgYXMgaXRzIGNhdXNlLiBGb3IgZXhhbXBsZSBpZiBhbiBhY3Rpdml0eSB0aW1lZCBvdXQgdGhlIGNhdXNlIGlzIHtAbGluayBUaW1lb3V0RmFpbHVyZX0uXG4gKlxuICogVGhpcyBleGNlcHRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgdGhyb3duIG9ubHkgYnkgdGhlIGZyYW1ld29yayBjb2RlLlxuICovXG5jbGFzcyBBY3Rpdml0eUZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2aXR5VHlwZSwgYWN0aXZpdHlJZCwgcmV0cnlTdGF0ZSwgaWRlbnRpdHksIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKCdBY3Rpdml0eSBleGVjdXRpb24gZmFpbGVkJywgY2F1c2UpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VHlwZSA9IGFjdGl2aXR5VHlwZTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUlkID0gYWN0aXZpdHlJZDtcbiAgICAgICAgdGhpcy5yZXRyeVN0YXRlID0gcmV0cnlTdGF0ZTtcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIH1cbn1cbmV4cG9ydHMuQWN0aXZpdHlGYWlsdXJlID0gQWN0aXZpdHlGYWlsdXJlO1xuLyoqXG4gKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhbiBjaGlsZCB3b3JrZmxvdyBmYWlsdXJlLiBBbHdheXMgY29udGFpbnMgdGhlIG9yaWdpbmFsIHJlYXNvbiBmb3IgdGhlXG4gKiBmYWlsdXJlIGFzIGl0cyBjYXVzZS4gRm9yIGV4YW1wbGUgaWYgYSBjaGlsZCB3b3JrZmxvdyB3YXMgdGVybWluYXRlZCB0aGUgY2F1c2UgaXMge0BsaW5rIFRlcm1pbmF0ZWRGYWlsdXJlfS5cbiAqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyBleHBlY3RlZCB0byBiZSB0aHJvd24gb25seSBieSB0aGUgZnJhbWV3b3JrIGNvZGUuXG4gKi9cbmNsYXNzIENoaWxkV29ya2Zsb3dGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lc3BhY2UsIGV4ZWN1dGlvbiwgd29ya2Zsb3dUeXBlLCByZXRyeVN0YXRlLCBjYXVzZSkge1xuICAgICAgICBzdXBlcignQ2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGZhaWxlZCcsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uID0gZXhlY3V0aW9uO1xuICAgICAgICB0aGlzLndvcmtmbG93VHlwZSA9IHdvcmtmbG93VHlwZTtcbiAgICAgICAgdGhpcy5yZXRyeVN0YXRlID0gcmV0cnlTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLkNoaWxkV29ya2Zsb3dGYWlsdXJlID0gQ2hpbGRXb3JrZmxvd0ZhaWx1cmU7XG4vKipcbiAqIENvbnZlcnRzIGFuIGVycm9yIHRvIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIGlmIGRlZmluZWQgb3IgcmV0dXJucyB1bmRlZmluZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gb3B0aW9uYWxFcnJvclRvT3B0aW9uYWxGYWlsdXJlKGVyciwgZGF0YUNvbnZlcnRlcikge1xuICAgIHJldHVybiBlcnIgPyBhd2FpdCBlcnJvclRvRmFpbHVyZShlcnIsIGRhdGFDb252ZXJ0ZXIpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5vcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUgPSBvcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmU7XG4vKipcbiAqIFN0YWNrIHRyYWNlcyB3aWxsIGJlIGN1dG9mZiB3aGVuIG9uIG9mIHRoZXNlIHBhdHRlcm5zIGlzIG1hdGNoZWRcbiAqL1xuY29uc3QgQ1VUVE9GRl9TVEFDS19QQVRURVJOUyA9IFtcbiAgICAvKiogQWN0aXZpdHkgZXhlY3V0aW9uICovXG4gICAgL1xccythdCBBY3Rpdml0eVxcLmV4ZWN1dGUgXFwoLipbXFxcXC9dd29ya2VyW1xcXFwvXSg/OnNyY3xsaWIpW1xcXFwvXWFjdGl2aXR5XFwuW2p0XXM6XFxkKzpcXGQrXFwpLyxcbiAgICAvKiogV29ya2Zsb3cgYWN0aXZhdGlvbiAqL1xuICAgIC9cXHMrYXQgQWN0aXZhdG9yXFwuXFxTK05leHRIYW5kbGVyIFxcKHdlYnBhY2staW50ZXJuYWw6XFwvXFwvXFwvLipcXC9pbnRlcm5hbHNcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuXTtcbi8qKlxuICogQ3V0cyBvdXQgdGhlIGZyYW1ld29yayBwYXJ0IG9mIGEgc3RhY2sgdHJhY2UsIGxlYXZpbmcgb25seSB1c2VyIGNvZGUgZW50cmllc1xuICovXG5mdW5jdGlvbiBjdXRvZmZTdGFja1RyYWNlKHN0YWNrKSB7XG4gICAgY29uc3QgbGluZXMgPSAoc3RhY2sgPz8gJycpLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgY29uc3QgYWNjID0gQXJyYXkoKTtcbiAgICBsaW5lTG9vcDogZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBDVVRUT0ZGX1NUQUNLX1BBVFRFUk5TKSB7XG4gICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGxpbmUpKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxpbmVMb29wO1xuICAgICAgICB9XG4gICAgICAgIGFjYy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjLmpvaW4oJ1xcbicpO1xufVxuZXhwb3J0cy5jdXRvZmZTdGFja1RyYWNlID0gY3V0b2ZmU3RhY2tUcmFjZTtcbi8qKlxuICogQ29udmVydHMgYSBjYXVnaHQgZXJyb3IgdG8gYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXJyb3JUb0ZhaWx1cmUoZXJyLCBkYXRhQ29udmVydGVyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgICAgICBpZiAoZXJyLmZhaWx1cmUpXG4gICAgICAgICAgICByZXR1cm4gZXJyLmZhaWx1cmU7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrVHJhY2U6IGN1dG9mZlN0YWNrVHJhY2UoZXJyLnN0YWNrKSxcbiAgICAgICAgICAgIGNhdXNlOiBhd2FpdCBvcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoZXJyLmNhdXNlLCBkYXRhQ29udmVydGVyKSxcbiAgICAgICAgICAgIHNvdXJjZTogZXhwb3J0cy5GQUlMVVJFX1NPVVJDRSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEFjdGl2aXR5RmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5RmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXJyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6IHsgbmFtZTogZXJyLmFjdGl2aXR5VHlwZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDaGlsZFdvcmtmbG93RmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAuLi5lcnIsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtmbG93RXhlY3V0aW9uOiBlcnIuZXhlY3V0aW9uLFxuICAgICAgICAgICAgICAgICAgICB3b3JrZmxvd1R5cGU6IHsgbmFtZTogZXJyLndvcmtmbG93VHlwZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBBcHBsaWNhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbkZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGVyci50eXBlLFxuICAgICAgICAgICAgICAgICAgICBub25SZXRyeWFibGU6IGVyci5ub25SZXRyeWFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVyci5kZXRhaWxzICYmIGVyci5kZXRhaWxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHBheWxvYWRzOiBhd2FpdCBkYXRhQ29udmVydGVyLnRvUGF5bG9hZHMoLi4uZXJyLmRldGFpbHMpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYW5jZWxsZWRGYWlsdXJlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgICAgICAgY2FuY2VsZWRGYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnIuZGV0YWlscyAmJiBlcnIuZGV0YWlscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBwYXlsb2FkczogYXdhaXQgZGF0YUNvbnZlcnRlci50b1BheWxvYWRzKC4uLmVyci5kZXRhaWxzKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGltZW91dEZhaWx1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0RmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFR5cGU6IGVyci50aW1lb3V0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEhlYXJ0YmVhdERldGFpbHM6IGVyci5sYXN0SGVhcnRiZWF0RGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHBheWxvYWRzOiBhd2FpdCBkYXRhQ29udmVydGVyLnRvUGF5bG9hZHMoZXJyLmxhc3RIZWFydGJlYXREZXRhaWxzKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGVybWluYXRlZEZhaWx1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkRmFpbHVyZUluZm86IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU2VydmVyRmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgIHNlcnZlckZhaWx1cmVJbmZvOiB7IG5vblJldHJ5YWJsZTogZXJyLm5vblJldHJ5YWJsZSB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKdXN0IGEgVGVtcG9yYWxGYWlsdXJlXG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBjb25zdCBiYXNlID0ge1xuICAgICAgICBzb3VyY2U6IGV4cG9ydHMuRkFJTFVSRV9TT1VSQ0UsXG4gICAgfTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogZXJyLm1lc3NhZ2UgPz8gJycsIHN0YWNrVHJhY2U6IGN1dG9mZlN0YWNrVHJhY2UoZXJyLnN0YWNrKSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogZXJyIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmJhc2UsIG1lc3NhZ2U6IFN0cmluZyhlcnIpIH07XG59XG5leHBvcnRzLmVycm9yVG9GYWlsdXJlID0gZXJyb3JUb0ZhaWx1cmU7XG4vKipcbiAqIElmIGBlcnJgIGlzIGFuIEVycm9yIGl0IGlzIHR1cm5lZCBpbnRvIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgLlxuICpcbiAqIElmIGBlcnJgIHdhcyBhbHJlYWR5IGEgYFRlbXBvcmFsRmFpbHVyZWAsIHJldHVybnMgdGhlIG9yaWdpbmFsIGVycm9yLlxuICpcbiAqIE90aGVyd2lzZSByZXR1cm5zIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGggYFN0cmluZyhlcnIpYCBhcyB0aGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlVGVtcG9yYWxGYWlsdXJlKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IG5ldyBBcHBsaWNhdGlvbkZhaWx1cmUoZXJyLm1lc3NhZ2UsIGVyci5uYW1lLCBmYWxzZSk7XG4gICAgICAgIGZhaWx1cmUuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IG5ldyBBcHBsaWNhdGlvbkZhaWx1cmUoU3RyaW5nKGVyciksIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBmYWlsdXJlLnN0YWNrID0gJyc7XG4gICAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zdXJlVGVtcG9yYWxGYWlsdXJlID0gZW5zdXJlVGVtcG9yYWxGYWlsdXJlO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdCBpZiBkZWZpbmVkIG9yIHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBvcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZSwgZGF0YUNvbnZlcnRlcikge1xuICAgIHJldHVybiBmYWlsdXJlID8gYXdhaXQgZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSwgZGF0YUNvbnZlcnRlcikgOiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvciA9IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcjtcbi8qKlxuICogQ29udmVydHMgYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UgdG8gYSBKUyBFcnJvciBvYmplY3QuXG4gKlxuICogRG9lcyBub3Qgc2V0IGNvbW1vbiBwcm9wZXJ0aWVzLCB0aGF0IGlzIGRvbmUgaW4ge0BsaW5rIGZhaWx1cmVUb0Vycm9yfS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmFpbHVyZVRvRXJyb3JJbm5lcihmYWlsdXJlLCBkYXRhQ29udmVydGVyKSB7XG4gICAgaWYgKGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mbykge1xuICAgICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLCBmYWlsdXJlLmFwcGxpY2F0aW9uRmFpbHVyZUluZm8udHlwZSwgQm9vbGVhbihmYWlsdXJlLmFwcGxpY2F0aW9uRmFpbHVyZUluZm8ubm9uUmV0cnlhYmxlKSwgYXdhaXQgKDAsIGRhdGFfY29udmVydGVyXzEuYXJyYXlGcm9tUGF5bG9hZHMpKGRhdGFDb252ZXJ0ZXIsIGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksIGF3YWl0IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBkYXRhQ29udmVydGVyKSk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnNlcnZlckZhaWx1cmVJbmZvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyRmFpbHVyZShmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLCBCb29sZWFuKGZhaWx1cmUuc2VydmVyRmFpbHVyZUluZm8ubm9uUmV0cnlhYmxlKSwgYXdhaXQgb3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIGRhdGFDb252ZXJ0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUudGltZW91dEZhaWx1cmVJbmZvKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEZhaWx1cmUoZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCwgYXdhaXQgZGF0YUNvbnZlcnRlci5mcm9tUGF5bG9hZHMoMCwgZmFpbHVyZS50aW1lb3V0RmFpbHVyZUluZm8ubGFzdEhlYXJ0YmVhdERldGFpbHM/LnBheWxvYWRzKSwgZmFpbHVyZS50aW1lb3V0RmFpbHVyZUluZm8udGltZW91dFR5cGUgPz8gVGltZW91dFR5cGUuVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUudGVybWluYXRlZEZhaWx1cmVJbmZvKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVybWluYXRlZEZhaWx1cmUoZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCwgYXdhaXQgb3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIGRhdGFDb252ZXJ0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuY2FuY2VsZWRGYWlsdXJlSW5mbykge1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGxlZEZhaWx1cmUoZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCwgYXdhaXQgKDAsIGRhdGFfY29udmVydGVyXzEuYXJyYXlGcm9tUGF5bG9hZHMpKGRhdGFDb252ZXJ0ZXIsIGZhaWx1cmUuY2FuY2VsZWRGYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksIGF3YWl0IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBkYXRhQ29udmVydGVyKSk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnJlc2V0V29ya2Zsb3dGYWlsdXJlSW5mbykge1xuICAgICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLCAnUmVzZXRXb3JrZmxvdycsIGZhbHNlLCBhd2FpdCAoMCwgZGF0YV9jb252ZXJ0ZXJfMS5hcnJheUZyb21QYXlsb2FkcykoZGF0YUNvbnZlcnRlciwgZmFpbHVyZS5yZXNldFdvcmtmbG93RmFpbHVyZUluZm8ubGFzdEhlYXJ0YmVhdERldGFpbHM/LnBheWxvYWRzKSwgYXdhaXQgb3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIGRhdGFDb252ZXJ0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuY2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZXNwYWNlLCB3b3JrZmxvd1R5cGUsIHdvcmtmbG93RXhlY3V0aW9uLCByZXRyeVN0YXRlIH0gPSBmYWlsdXJlLmNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbztcbiAgICAgICAgaWYgKCEod29ya2Zsb3dUeXBlPy5uYW1lICYmIHdvcmtmbG93RXhlY3V0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhdHRyaWJ1dGVzIG9uIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUobmFtZXNwYWNlID8/IHVuZGVmaW5lZCwgd29ya2Zsb3dFeGVjdXRpb24sIHdvcmtmbG93VHlwZS5uYW1lLCByZXRyeVN0YXRlID8/IFJldHJ5U3RhdGUuUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQsIGF3YWl0IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBkYXRhQ29udmVydGVyKSk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8pIHtcbiAgICAgICAgaWYgKCFmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlUeXBlPy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFjdGl2aXR5VHlwZT8ubmFtZSBvbiBhY3Rpdml0eUZhaWx1cmVJbmZvJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY3Rpdml0eUZhaWx1cmUoZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLmFjdGl2aXR5VHlwZS5uYW1lLCBmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlJZCA/PyB1bmRlZmluZWQsIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5yZXRyeVN0YXRlID8/IFJldHJ5U3RhdGUuUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQsIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5pZGVudGl0eSA/PyB1bmRlZmluZWQsIGF3YWl0IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBkYXRhQ29udmVydGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVtcG9yYWxGYWlsdXJlKGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsIGF3YWl0IG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBkYXRhQ29udmVydGVyKSk7XG59XG5leHBvcnRzLmZhaWx1cmVUb0Vycm9ySW5uZXIgPSBmYWlsdXJlVG9FcnJvcklubmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSwgZGF0YUNvbnZlcnRlcikge1xuICAgIGNvbnN0IGVyciA9IGF3YWl0IGZhaWx1cmVUb0Vycm9ySW5uZXIoZmFpbHVyZSwgZGF0YUNvbnZlcnRlcik7XG4gICAgZXJyLnN0YWNrID0gZmFpbHVyZS5zdGFja1RyYWNlID8/ICcnO1xuICAgIGVyci5mYWlsdXJlID0gZmFpbHVyZTtcbiAgICByZXR1cm4gZXJyO1xufVxuZXhwb3J0cy5mYWlsdXJlVG9FcnJvciA9IGZhaWx1cmVUb0Vycm9yO1xuLyoqXG4gKiBHZXQgdGhlIHJvb3QgY2F1c2UgKHN0cmluZykgb2YgZ2l2ZW4gZXJyb3IgYGVycmAuXG4gKlxuICogSW4gY2FzZSBgZXJyYCBpcyBhIHtAbGluayBUZW1wb3JhbEZhaWx1cmV9LCByZWN1cnNlIHRoZSBjYXVzZSBjaGFpbiBhbmQgcmV0dXJuIHRoZSByb290J3MgbWVzc2FnZS5cbiAqIE90aGVyd2lzZSwgcmV0dXJuIGBlcnIubWVzc2FnZWAuXG4gKi9cbmZ1bmN0aW9uIHJvb3RDYXVzZShlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGVtcG9yYWxGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiBlcnIuY2F1c2UgPyByb290Q2F1c2UoZXJyLmNhdXNlKSA6IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMucm9vdENhdXNlID0gcm9vdENhdXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFpbHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/failure.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/index.js':
      /*!******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/index.js ***!
  \******************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * Common library for both isolated Workflow and normal non-Workflow code\n *\n * @module\n */\n__exportStar(__webpack_require__(/*! ./activity-options */ "./node_modules/@temporalio/common/lib/activity-options.js"), exports);\n__exportStar(__webpack_require__(/*! ./converter/data-converter */ "./node_modules/@temporalio/common/lib/converter/data-converter.js"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/@temporalio/common/lib/errors.js"), exports);\n__exportStar(__webpack_require__(/*! ./failure */ "./node_modules/@temporalio/common/lib/failure.js"), exports);\n__exportStar(__webpack_require__(/*! ./interceptors */ "./node_modules/@temporalio/common/lib/interceptors.js"), exports);\n__exportStar(__webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/common/lib/interfaces.js"), exports);\n__exportStar(__webpack_require__(/*! ./retry-policy */ "./node_modules/@temporalio/common/lib/retry-policy.js"), exports);\n__exportStar(__webpack_require__(/*! ./time */ "./node_modules/@temporalio/common/lib/time.js"), exports);\n__exportStar(__webpack_require__(/*! ./tls-config */ "./node_modules/@temporalio/common/lib/tls-config.js"), exports);\n__exportStar(__webpack_require__(/*! ./workflow-handle */ "./node_modules/@temporalio/common/lib/workflow-handle.js"), exports);\n__exportStar(__webpack_require__(/*! ./workflow-options */ "./node_modules/@temporalio/common/lib/workflow-options.js"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ "./node_modules/@temporalio/common/lib/utils.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHFHQUE0QjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsaUVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHlFQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDZEQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx5RUFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsbUZBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW5kZXguanM/MTU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb21tb24gbGlicmFyeSBmb3IgYm90aCBpc29sYXRlZCBXb3JrZmxvdyBhbmQgbm9ybWFsIG5vbi1Xb3JrZmxvdyBjb2RlXG4gKlxuICogQG1vZHVsZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWN0aXZpdHktb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydGVyL2RhdGEtY29udmVydGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZhaWx1cmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVyY2VwdG9yc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJmYWNlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cnktcG9saWN5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90bHMtY29uZmlnXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93b3JrZmxvdy1oYW5kbGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dvcmtmbG93LW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/index.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/interceptors.js':
      /*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/interceptors.js ***!
  \*************************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.composeInterceptors = void 0;\n/**\n * Composes all interceptor methods into a single function\n *\n * @param interceptors a list of interceptors\n * @param method the name of the interceptor method to compose\n * @param next the original function to be executed at the end of the interception chain\n */\nfunction composeInterceptors(interceptors, method, next) {\n    for (let i = interceptors.length - 1; i >= 0; --i) {\n        const interceptor = interceptors[i];\n        if (interceptor[method] !== undefined) {\n            const prev = next;\n            // We loose type safety here because Typescript can\'t deduce that interceptor[method] is a function that returns\n            // the same type as Next<I, M>\n            next = ((input) => interceptor[method](input, prev));\n        }\n    }\n    return next;\n}\nexports.composeInterceptors = composeInterceptors;\n//# sourceMappingURL=interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmNlcHRvcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVyY2VwdG9ycy5qcz9hN2E5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wb3NlSW50ZXJjZXB0b3JzID0gdm9pZCAwO1xuLyoqXG4gKiBDb21wb3NlcyBhbGwgaW50ZXJjZXB0b3IgbWV0aG9kcyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGludGVyY2VwdG9ycyBhIGxpc3Qgb2YgaW50ZXJjZXB0b3JzXG4gKiBAcGFyYW0gbWV0aG9kIHRoZSBuYW1lIG9mIHRoZSBpbnRlcmNlcHRvciBtZXRob2QgdG8gY29tcG9zZVxuICogQHBhcmFtIG5leHQgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IHRoZSBlbmQgb2YgdGhlIGludGVyY2VwdGlvbiBjaGFpblxuICovXG5mdW5jdGlvbiBjb21wb3NlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9ycywgbWV0aG9kLCBuZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IGludGVyY2VwdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IGludGVyY2VwdG9yc1tpXTtcbiAgICAgICAgaWYgKGludGVyY2VwdG9yW21ldGhvZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IG5leHQ7XG4gICAgICAgICAgICAvLyBXZSBsb29zZSB0eXBlIHNhZmV0eSBoZXJlIGJlY2F1c2UgVHlwZXNjcmlwdCBjYW4ndCBkZWR1Y2UgdGhhdCBpbnRlcmNlcHRvclttZXRob2RdIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSB0eXBlIGFzIE5leHQ8SSwgTT5cbiAgICAgICAgICAgIG5leHQgPSAoKGlucHV0KSA9PiBpbnRlcmNlcHRvclttZXRob2RdKGlucHV0LCBwcmV2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG59XG5leHBvcnRzLmNvbXBvc2VJbnRlcmNlcHRvcnMgPSBjb21wb3NlSW50ZXJjZXB0b3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/interceptors.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/interfaces.js':
      /*!***********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/interfaces.js ***!
  \***********************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=interfaces.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmZhY2VzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJmYWNlcy5qcz8yYzZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/interfaces.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/retry-policy.js':
      /*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/retry-policy.js ***!
  \*************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compileRetryPolicy = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@temporalio/common/lib/index.js\");\nconst time_1 = __webpack_require__(/*! ./time */ \"./node_modules/@temporalio/common/lib/time.js\");\n/**\n * Turns a TS RetryPolicy into a proto compatible RetryPolicy\n */\nfunction compileRetryPolicy(retryPolicy) {\n    if (retryPolicy.backoffCoefficient != null && retryPolicy.backoffCoefficient <= 0) {\n        throw new _1.ValueError('RetryPolicy.backoffCoefficient must be greater than 0');\n    }\n    if (retryPolicy.maximumAttempts != null && retryPolicy.maximumAttempts <= 0) {\n        throw new _1.ValueError('RetryPolicy.maximumAttempts must be greater than 0');\n    }\n    const maximumInterval = (0, time_1.msOptionalToNumber)(retryPolicy.maximumInterval);\n    const initialInterval = (0, time_1.msToNumber)(retryPolicy.initialInterval ?? 1000);\n    if (maximumInterval === 0) {\n        throw new _1.ValueError('RetryPolicy.maximumInterval cannot be 0');\n    }\n    if (initialInterval === 0) {\n        throw new _1.ValueError('RetryPolicy.initialInterval cannot be 0');\n    }\n    if (maximumInterval != null && maximumInterval < initialInterval) {\n        throw new _1.ValueError('RetryPolicy.maximumInterval cannot be less than its initialInterval');\n    }\n    return {\n        maximumAttempts: retryPolicy.maximumAttempts,\n        initialInterval: (0, time_1.msToTs)(initialInterval),\n        maximumInterval: (0, time_1.msOptionalToTs)(maximumInterval),\n        backoffCoefficient: retryPolicy.backoffCoefficient,\n        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes,\n    };\n}\nexports.compileRetryPolicy = compileRetryPolicy;\n//# sourceMappingURL=retry-policy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9yZXRyeS1wb2xpY3kuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLFdBQVcsbUJBQU8sQ0FBQyx5REFBRztBQUN0QixlQUFlLG1CQUFPLENBQUMsNkRBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vbGliL3JldHJ5LXBvbGljeS5qcz81ZGU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21waWxlUmV0cnlQb2xpY3kgPSB2b2lkIDA7XG5jb25zdCBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4vdGltZVwiKTtcbi8qKlxuICogVHVybnMgYSBUUyBSZXRyeVBvbGljeSBpbnRvIGEgcHJvdG8gY29tcGF0aWJsZSBSZXRyeVBvbGljeVxuICovXG5mdW5jdGlvbiBjb21waWxlUmV0cnlQb2xpY3kocmV0cnlQb2xpY3kpIHtcbiAgICBpZiAocmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50ICE9IG51bGwgJiYgcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IF8xLlZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIGlmIChyZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgIT0gbnVsbCAmJiByZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgXzEuVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG4gICAgY29uc3QgbWF4aW11bUludGVydmFsID0gKDAsIHRpbWVfMS5tc09wdGlvbmFsVG9OdW1iZXIpKHJldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCk7XG4gICAgY29uc3QgaW5pdGlhbEludGVydmFsID0gKDAsIHRpbWVfMS5tc1RvTnVtYmVyKShyZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwgPz8gMTAwMCk7XG4gICAgaWYgKG1heGltdW1JbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgXzEuVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsIGNhbm5vdCBiZSAwJyk7XG4gICAgfVxuICAgIGlmIChpbml0aWFsSW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IF8xLlZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCBjYW5ub3QgYmUgMCcpO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUludGVydmFsICE9IG51bGwgJiYgbWF4aW11bUludGVydmFsIDwgaW5pdGlhbEludGVydmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBfMS5WYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwgY2Fubm90IGJlIGxlc3MgdGhhbiBpdHMgaW5pdGlhbEludGVydmFsJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heGltdW1BdHRlbXB0czogcmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzLFxuICAgICAgICBpbml0aWFsSW50ZXJ2YWw6ICgwLCB0aW1lXzEubXNUb1RzKShpbml0aWFsSW50ZXJ2YWwpLFxuICAgICAgICBtYXhpbXVtSW50ZXJ2YWw6ICgwLCB0aW1lXzEubXNPcHRpb25hbFRvVHMpKG1heGltdW1JbnRlcnZhbCksXG4gICAgICAgIGJhY2tvZmZDb2VmZmljaWVudDogcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50LFxuICAgICAgICBub25SZXRyeWFibGVFcnJvclR5cGVzOiByZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzLFxuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVSZXRyeVBvbGljeSA9IGNvbXBpbGVSZXRyeVBvbGljeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5LXBvbGljeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/retry-policy.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/time.js':
      /*!*****************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/time.js ***!
  \*****************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          '\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.msToNumber = exports.msOptionalToNumber = exports.msOptionalToTs = exports.msToTs = exports.msNumberToTs = exports.tsToMs = exports.optionalTsToMs = void 0;\nconst long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ "./node_modules/ms/index.js"));\nconst errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@temporalio/common/lib/errors.js");\n/**\n * Lossy conversion function from Timestamp to number due to possible overflow.\n * If ts is null or undefined returns undefined.\n */\nfunction optionalTsToMs(ts) {\n    if (ts === undefined || ts === null) {\n        return undefined;\n    }\n    return tsToMs(ts);\n}\nexports.optionalTsToMs = optionalTsToMs;\n/**\n * Lossy conversion function from Timestamp to number due to possible overflow\n */\nfunction tsToMs(ts) {\n    if (ts === undefined || ts === null) {\n        throw new Error(`Expected timestamp, got ${ts}`);\n    }\n    const { seconds, nanos } = ts;\n    return (seconds || long_1.default.UZERO)\n        .mul(1000)\n        .add(Math.floor((nanos || 0) / 1000000))\n        .toNumber();\n}\nexports.tsToMs = tsToMs;\nfunction msNumberToTs(millis) {\n    const seconds = Math.floor(millis / 1000);\n    const nanos = (millis % 1000) * 1000000;\n    if (Number.isNaN(seconds) || Number.isNaN(nanos)) {\n        throw new errors_1.ValueError(`Invalid millis ${millis}`);\n    }\n    return { seconds: long_1.default.fromNumber(seconds), nanos };\n}\nexports.msNumberToTs = msNumberToTs;\nfunction msToTs(str) {\n    if (typeof str === \'number\') {\n        return msNumberToTs(str);\n    }\n    return msNumberToTs((0, ms_1.default)(str));\n}\nexports.msToTs = msToTs;\nfunction msOptionalToTs(str) {\n    if (str === undefined)\n        return undefined;\n    if (typeof str === \'number\') {\n        return msNumberToTs(str);\n    }\n    return msNumberToTs((0, ms_1.default)(str));\n}\nexports.msOptionalToTs = msOptionalToTs;\nfunction msOptionalToNumber(val) {\n    if (val === undefined)\n        return undefined;\n    return msToNumber(val);\n}\nexports.msOptionalToNumber = msOptionalToNumber;\nfunction msToNumber(val) {\n    if (typeof val === \'number\') {\n        return val;\n    }\n    return (0, ms_1.default)(val);\n}\nexports.msToNumber = msToNumber;\n//# sourceMappingURL=time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxzQkFBc0I7QUFDMUosK0JBQStCLG1CQUFPLENBQUMsNkNBQU07QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsc0NBQUk7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxHQUFHO0FBQ3REO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdGltZS5qcz9jMGUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tc1RvTnVtYmVyID0gZXhwb3J0cy5tc09wdGlvbmFsVG9OdW1iZXIgPSBleHBvcnRzLm1zT3B0aW9uYWxUb1RzID0gZXhwb3J0cy5tc1RvVHMgPSBleHBvcnRzLm1zTnVtYmVyVG9UcyA9IGV4cG9ydHMudHNUb01zID0gZXhwb3J0cy5vcHRpb25hbFRzVG9NcyA9IHZvaWQgMDtcbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93LlxuICogSWYgdHMgaXMgbnVsbCBvciB1bmRlZmluZWQgcmV0dXJucyB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsVHNUb01zKHRzKSB7XG4gICAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRzVG9Ncyh0cyk7XG59XG5leHBvcnRzLm9wdGlvbmFsVHNUb01zID0gb3B0aW9uYWxUc1RvTXM7XG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvd1xuICovXG5mdW5jdGlvbiB0c1RvTXModHMpIHtcbiAgICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRpbWVzdGFtcCwgZ290ICR7dHN9YCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc2Vjb25kcywgbmFub3MgfSA9IHRzO1xuICAgIHJldHVybiAoc2Vjb25kcyB8fCBsb25nXzEuZGVmYXVsdC5VWkVSTylcbiAgICAgICAgLm11bCgxMDAwKVxuICAgICAgICAuYWRkKE1hdGguZmxvb3IoKG5hbm9zIHx8IDApIC8gMTAwMDAwMCkpXG4gICAgICAgIC50b051bWJlcigpO1xufVxuZXhwb3J0cy50c1RvTXMgPSB0c1RvTXM7XG5mdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzKSB7XG4gICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzIC8gMTAwMCk7XG4gICAgY29uc3QgbmFub3MgPSAobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oc2Vjb25kcykgfHwgTnVtYmVyLmlzTmFOKG5hbm9zKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihgSW52YWxpZCBtaWxsaXMgJHttaWxsaXN9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlY29uZHM6IGxvbmdfMS5kZWZhdWx0LmZyb21OdW1iZXIoc2Vjb25kcyksIG5hbm9zIH07XG59XG5leHBvcnRzLm1zTnVtYmVyVG9UcyA9IG1zTnVtYmVyVG9UcztcbmZ1bmN0aW9uIG1zVG9UcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1zTnVtYmVyVG9UcyhzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gbXNOdW1iZXJUb1RzKCgwLCBtc18xLmRlZmF1bHQpKHN0cikpO1xufVxuZXhwb3J0cy5tc1RvVHMgPSBtc1RvVHM7XG5mdW5jdGlvbiBtc09wdGlvbmFsVG9UcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBtc051bWJlclRvVHMoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zTnVtYmVyVG9UcygoMCwgbXNfMS5kZWZhdWx0KShzdHIpKTtcbn1cbmV4cG9ydHMubXNPcHRpb25hbFRvVHMgPSBtc09wdGlvbmFsVG9UcztcbmZ1bmN0aW9uIG1zT3B0aW9uYWxUb051bWJlcih2YWwpIHtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1zVG9OdW1iZXIodmFsKTtcbn1cbmV4cG9ydHMubXNPcHRpb25hbFRvTnVtYmVyID0gbXNPcHRpb25hbFRvTnVtYmVyO1xuZnVuY3Rpb24gbXNUb051bWJlcih2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBtc18xLmRlZmF1bHQpKHZhbCk7XG59XG5leHBvcnRzLm1zVG9OdW1iZXIgPSBtc1RvTnVtYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/time.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/tls-config.js':
      /*!***********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/tls-config.js ***!
  \***********************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.normalizeTlsConfig = void 0;\n/**\n * Normalize {@link TLSConfigOption} by turning false and null to undefined and true to and empty object\n */\nfunction normalizeTlsConfig(tls) {\n    return typeof tls === \'object\' ? (tls === null ? undefined : tls) : tls ? {} : undefined;\n}\nexports.normalizeTlsConfig = normalizeTlsConfig;\n//# sourceMappingURL=tls-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90bHMtY29uZmlnLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQjtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90bHMtY29uZmlnLmpzPzQ0NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZVRsc0NvbmZpZyA9IHZvaWQgMDtcbi8qKlxuICogTm9ybWFsaXplIHtAbGluayBUTFNDb25maWdPcHRpb259IGJ5IHR1cm5pbmcgZmFsc2UgYW5kIG51bGwgdG8gdW5kZWZpbmVkIGFuZCB0cnVlIHRvIGFuZCBlbXB0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVGxzQ29uZmlnKHRscykge1xuICAgIHJldHVybiB0eXBlb2YgdGxzID09PSAnb2JqZWN0JyA/ICh0bHMgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0bHMpIDogdGxzID8ge30gOiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLm5vcm1hbGl6ZVRsc0NvbmZpZyA9IG5vcm1hbGl6ZVRsc0NvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRscy1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/tls-config.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/type-helpers.js':
      /*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/type-helpers.js ***!
  \*************************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.checkExtends = void 0;\n/** Verify that an type _Copy extends _Orig */\nfunction checkExtends() {\n    // noop, just type check\n}\nexports.checkExtends = checkExtends;\n//# sourceMappingURL=type-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90eXBlLWhlbHBlcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzLmpzP2MxZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrRXh0ZW5kcyA9IHZvaWQgMDtcbi8qKiBWZXJpZnkgdGhhdCBhbiB0eXBlIF9Db3B5IGV4dGVuZHMgX09yaWcgKi9cbmZ1bmN0aW9uIGNoZWNrRXh0ZW5kcygpIHtcbiAgICAvLyBub29wLCBqdXN0IHR5cGUgY2hlY2tcbn1cbmV4cG9ydHMuY2hlY2tFeHRlbmRzID0gY2hlY2tFeHRlbmRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/type-helpers.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/utils.js':
      /*!******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/utils.js ***!
  \******************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.filterNullAndUndefined = void 0;\n/**\n * Helper to prevent undefined and null values overriding defaults when merging maps\n */\nfunction filterNullAndUndefined(obj) {\n    return Object.fromEntries(Object.entries(obj).filter(([_k, v]) => v != null));\n}\nexports.filterNullAndUndefined = filterNullAndUndefined;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdXRpbHMuanM/ZDkzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmlsdGVyTnVsbEFuZFVuZGVmaW5lZCA9IHZvaWQgMDtcbi8qKlxuICogSGVscGVyIHRvIHByZXZlbnQgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcyBvdmVycmlkaW5nIGRlZmF1bHRzIHdoZW4gbWVyZ2luZyBtYXBzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlck51bGxBbmRVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW19rLCB2XSkgPT4gdiAhPSBudWxsKSk7XG59XG5leHBvcnRzLmZpbHRlck51bGxBbmRVbmRlZmluZWQgPSBmaWx0ZXJOdWxsQW5kVW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/utils.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/workflow-handle.js':
      /*!****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/workflow-handle.js ***!
  \****************************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=workflow-handle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1oYW5kbGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1oYW5kbGUuanM/NThkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtmbG93LWhhbmRsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/workflow-handle.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/common/lib/workflow-options.js':
      /*!*****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/workflow-options.js ***!
  \*****************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.compileWorkflowOptions = exports.WorkflowIdReusePolicy = void 0;\nconst time_1 = __webpack_require__(/*! ./time */ "./node_modules/@temporalio/common/lib/time.js");\nconst type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");\n// Avoid importing the proto implementation to reduce workflow bundle size\n// Copied from coresdk.common.WorkflowIdReusePolicy\nvar WorkflowIdReusePolicy;\n(function (WorkflowIdReusePolicy) {\n    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED"] = 0] = "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED";\n    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE"] = 1] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE";\n    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY"] = 2] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY";\n    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE"] = 3] = "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE";\n})(WorkflowIdReusePolicy = exports.WorkflowIdReusePolicy || (exports.WorkflowIdReusePolicy = {}));\n(0, type_helpers_1.checkExtends)();\nfunction compileWorkflowOptions(options) {\n    const { workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout, ...rest } = options;\n    return {\n        ...rest,\n        workflowExecutionTimeout: workflowExecutionTimeout ? (0, time_1.msToTs)(workflowExecutionTimeout) : undefined,\n        workflowRunTimeout: workflowRunTimeout ? (0, time_1.msToTs)(workflowRunTimeout) : undefined,\n        workflowTaskTimeout: workflowTaskTimeout ? (0, time_1.msToTs)(workflowTaskTimeout) : undefined,\n    };\n}\nexports.compileWorkflowOptions = compileWorkflowOptions;\n//# sourceMappingURL=workflow-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1vcHRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLDZCQUE2QjtBQUM5RCxlQUFlLG1CQUFPLENBQUMsNkRBQVE7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsNkVBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RCw2QkFBNkIsS0FBSztBQUMvRjtBQUNBO0FBQ0EsWUFBWSw2RUFBNkU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1vcHRpb25zLmpzP2FlOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBpbGVXb3JrZmxvd09wdGlvbnMgPSBleHBvcnRzLldvcmtmbG93SWRSZXVzZVBvbGljeSA9IHZvaWQgMDtcbmNvbnN0IHRpbWVfMSA9IHJlcXVpcmUoXCIuL3RpbWVcIik7XG5jb25zdCB0eXBlX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3R5cGUtaGVscGVyc1wiKTtcbi8vIEF2b2lkIGltcG9ydGluZyB0aGUgcHJvdG8gaW1wbGVtZW50YXRpb24gdG8gcmVkdWNlIHdvcmtmbG93IGJ1bmRsZSBzaXplXG4vLyBDb3BpZWQgZnJvbSBjb3Jlc2RrLmNvbW1vbi5Xb3JrZmxvd0lkUmV1c2VQb2xpY3lcbnZhciBXb3JrZmxvd0lkUmV1c2VQb2xpY3k7XG4oZnVuY3Rpb24gKFdvcmtmbG93SWRSZXVzZVBvbGljeSkge1xuICAgIFdvcmtmbG93SWRSZXVzZVBvbGljeVtXb3JrZmxvd0lkUmV1c2VQb2xpY3lbXCJXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1VOU1BFQ0lGSUVEXCI7XG4gICAgV29ya2Zsb3dJZFJldXNlUG9saWN5W1dvcmtmbG93SWRSZXVzZVBvbGljeVtcIldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEVcIl0gPSAxXSA9IFwiV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURVwiO1xuICAgIFdvcmtmbG93SWRSZXVzZVBvbGljeVtXb3JrZmxvd0lkUmV1c2VQb2xpY3lbXCJXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZXCJdID0gMl0gPSBcIldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFlcIjtcbiAgICBXb3JrZmxvd0lkUmV1c2VQb2xpY3lbV29ya2Zsb3dJZFJldXNlUG9saWN5W1wiV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEVcIl0gPSAzXSA9IFwiV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEVcIjtcbn0pKFdvcmtmbG93SWRSZXVzZVBvbGljeSA9IGV4cG9ydHMuV29ya2Zsb3dJZFJldXNlUG9saWN5IHx8IChleHBvcnRzLldvcmtmbG93SWRSZXVzZVBvbGljeSA9IHt9KSk7XG4oMCwgdHlwZV9oZWxwZXJzXzEuY2hlY2tFeHRlbmRzKSgpO1xuZnVuY3Rpb24gY29tcGlsZVdvcmtmbG93T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQsIHdvcmtmbG93UnVuVGltZW91dCwgd29ya2Zsb3dUYXNrVGltZW91dCwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQ6IHdvcmtmbG93RXhlY3V0aW9uVGltZW91dCA/ICgwLCB0aW1lXzEubXNUb1RzKSh3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQpIDogdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6IHdvcmtmbG93UnVuVGltZW91dCA/ICgwLCB0aW1lXzEubXNUb1RzKSh3b3JrZmxvd1J1blRpbWVvdXQpIDogdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd1Rhc2tUaW1lb3V0OiB3b3JrZmxvd1Rhc2tUaW1lb3V0ID8gKDAsIHRpbWVfMS5tc1RvVHMpKHdvcmtmbG93VGFza1RpbWVvdXQpIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVXb3JrZmxvd09wdGlvbnMgPSBjb21waWxlV29ya2Zsb3dPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2Zsb3ctb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/common/lib/workflow-options.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/alea.js':
      /*!*******************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/alea.js ***!
  \*******************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\n// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Mash = exports.alea = void 0;\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Taken and modified from https://github.com/davidbau/seedrandom/blob/released/lib/alea.js\nclass Alea {\n    constructor(seed) {\n        const mash = new Mash();\n        // Apply the seeding algorithm from Baagoe.\n        this.c = 1;\n        this.s0 = mash.mash([32]);\n        this.s1 = mash.mash([32]);\n        this.s2 = mash.mash([32]);\n        this.s0 -= mash.mash(seed);\n        if (this.s0 < 0) {\n            this.s0 += 1;\n        }\n        this.s1 -= mash.mash(seed);\n        if (this.s1 < 0) {\n            this.s1 += 1;\n        }\n        this.s2 -= mash.mash(seed);\n        if (this.s2 < 0) {\n            this.s2 += 1;\n        }\n    }\n    next() {\n        const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\n        this.s0 = this.s1;\n        this.s1 = this.s2;\n        return (this.s2 = t - (this.c = t | 0));\n    }\n}\nfunction alea(seed) {\n    const xg = new Alea(seed);\n    return xg.next.bind(xg);\n}\nexports.alea = alea;\nclass Mash {\n    constructor() {\n        this.n = 0xefc8249d;\n    }\n    mash(data) {\n        let { n } = this;\n        for (let i = 0; i < data.length; i++) {\n            n += data[i];\n            let h = 0.02519603282416938 * n;\n            n = h >>> 0;\n            h -= n;\n            h *= n;\n            n = h >>> 0;\n            h -= n;\n            n += h * 0x100000000; // 2^32\n        }\n        this.n = n;\n        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    }\n}\nexports.Mash = Mash;\n//# sourceMappingURL=alea.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2FsZWEuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2FsZWEuanM/YWI4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hc2ggPSBleHBvcnRzLmFsZWEgPSB2b2lkIDA7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8vIFRha2VuIGFuZCBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJhdS9zZWVkcmFuZG9tL2Jsb2IvcmVsZWFzZWQvbGliL2FsZWEuanNcbmNsYXNzIEFsZWEge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgY29uc3QgbWFzaCA9IG5ldyBNYXNoKCk7XG4gICAgICAgIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgICAgICAgdGhpcy5jID0gMTtcbiAgICAgICAgdGhpcy5zMCA9IG1hc2gubWFzaChbMzJdKTtcbiAgICAgICAgdGhpcy5zMSA9IG1hc2gubWFzaChbMzJdKTtcbiAgICAgICAgdGhpcy5zMiA9IG1hc2gubWFzaChbMzJdKTtcbiAgICAgICAgdGhpcy5zMCAtPSBtYXNoLm1hc2goc2VlZCk7XG4gICAgICAgIGlmICh0aGlzLnMwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zMCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuczEgLT0gbWFzaC5tYXNoKHNlZWQpO1xuICAgICAgICBpZiAodGhpcy5zMSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuczEgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnMyIC09IG1hc2gubWFzaChzZWVkKTtcbiAgICAgICAgaWYgKHRoaXMuczIgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnMyICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgdCA9IDIwOTE2MzkgKiB0aGlzLnMwICsgdGhpcy5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICAgICAgdGhpcy5zMCA9IHRoaXMuczE7XG4gICAgICAgIHRoaXMuczEgPSB0aGlzLnMyO1xuICAgICAgICByZXR1cm4gKHRoaXMuczIgPSB0IC0gKHRoaXMuYyA9IHQgfCAwKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWxlYShzZWVkKSB7XG4gICAgY29uc3QgeGcgPSBuZXcgQWxlYShzZWVkKTtcbiAgICByZXR1cm4geGcubmV4dC5iaW5kKHhnKTtcbn1cbmV4cG9ydHMuYWxlYSA9IGFsZWE7XG5jbGFzcyBNYXNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uID0gMHhlZmM4MjQ5ZDtcbiAgICB9XG4gICAgbWFzaChkYXRhKSB7XG4gICAgICAgIGxldCB7IG4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbiArPSBkYXRhW2ldO1xuICAgICAgICAgICAgbGV0IGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICAgICAgaCAtPSBuO1xuICAgICAgICAgICAgaCAqPSBuO1xuICAgICAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgICAgICBoIC09IG47XG4gICAgICAgICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgICAgICB9XG4gICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIH1cbn1cbmV4cG9ydHMuTWFzaCA9IE1hc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGVhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/alea.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/cancellation-scope.js':
      /*!*********************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/cancellation-scope.js ***!
  \*********************************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          '\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === "m") throw new TypeError("Private method is not writable");\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CancellationScope_cancelRequested;\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.registerSleepImplementation = exports.ROOT_SCOPE = exports.RootCancellationScope = exports.storage = exports.CancellationScope = exports.AsyncLocalStorage = void 0;\nconst common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");\n// AsyncLocalStorage is injected via vm module into global scope.\n// In case Workflow code is imported in Node.js context, replace with an empty class.\nexports.AsyncLocalStorage = globalThis.AsyncLocalStorage ?? class {\n};\n/** Magic symbol used to create the root scope - intentionally not exported */\nconst NO_PARENT = Symbol(\'NO_PARENT\');\n/**\n * In the SDK, Workflows are represented internally by a tree of scopes where the `execute` function runs in the root scope.\n * Cancellation propagates from outer scopes to inner ones and is handled by catching {@link CancelledFailure}s\n * thrown by cancellable operations (see below).\n *\n * Scopes are created using the `CancellationScope` constructor or the static helper methods\n * {@link cancellable}, {@link nonCancellable} and {@link withTimeout}.\n *\n * When a `CancellationScope` is cancelled, it will propagate cancellation any child scopes and any cancellable\n * operations created within it, such as:\n *\n * - Activities\n * - Child Workflows\n * - Timers (created with the {@link sleep} function)\n * - {@link Trigger}s\n *\n * @example\n *\n * ```ts\n * await CancellationScope.cancellable(async () => {\n *   const promise = someActivity();\n *   CancellationScope.current().cancel(); // Cancels the activity\n *   await promise; // Throws CancelledFailure\n * });\n * ```\n *\n * @example\n *\n * ```ts\n * const scope = new CancellationScope();\n * const promise = scope.run(someActivity);\n * scope.cancel(); // Cancels the activity\n * await promise; // Throws CancelledFailure\n * ```\n */\nclass CancellationScope {\n    constructor(options) {\n        _CancellationScope_cancelRequested.set(this, false);\n        this.timeout = options?.timeout;\n        this.cancellable = options?.cancellable ?? true;\n        this.cancelRequested = new Promise((_, reject) => {\n            // Typescript does not understand that the Promise executor runs synchronously\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.reject = (err) => {\n                __classPrivateFieldSet(this, _CancellationScope_cancelRequested, true, "f");\n                reject(err);\n            };\n        });\n        // Avoid unhandled rejections\n        this.cancelRequested.catch(() => undefined);\n        if (options?.parent !== NO_PARENT) {\n            this.parent = options?.parent || CancellationScope.current();\n            __classPrivateFieldSet(this, _CancellationScope_cancelRequested, __classPrivateFieldGet(this.parent, _CancellationScope_cancelRequested, "f"), "f");\n            this.parent.cancelRequested.catch((err) => {\n                this.reject(err);\n            });\n        }\n    }\n    get consideredCancelled() {\n        return __classPrivateFieldGet(this, _CancellationScope_cancelRequested, "f") && this.cancellable;\n    }\n    /**\n     * Activate the scope as current and run  `fn`\n     *\n     * Any timers, Activities, Triggers and CancellationScopes created in the body of `fn`\n     * automatically link their cancellation to this scope.\n     *\n     * @return the result of `fn`\n     */\n    run(fn) {\n        return exports.storage.run(this, this.runInContext.bind(this, fn));\n    }\n    /**\n     * Method that runs a function in AsyncLocalStorage context.\n     *\n     * Could have been written as anonymous function, made into a method for improved stack traces.\n     */\n    async runInContext(fn) {\n        if (this.timeout) {\n            sleep(this.timeout).then(() => this.cancel());\n        }\n        return await fn();\n    }\n    /**\n     * Request to cancel the scope and linked children\n     */\n    cancel() {\n        this.reject(new common_1.CancelledFailure(\'Cancellation scope cancelled\'));\n    }\n    /**\n     * Get the current "active" scope\n     */\n    static current() {\n        return exports.storage.getStore() ?? exports.ROOT_SCOPE;\n    }\n    /** Alias to `new CancellationScope({ cancellable: true }).run(fn)` */\n    static cancellable(fn) {\n        return new this({ cancellable: true }).run(fn);\n    }\n    /** Alias to `new CancellationScope({ cancellable: false }).run(fn)` */\n    static nonCancellable(fn) {\n        return new this({ cancellable: false }).run(fn);\n    }\n    /** Alias to `new CancellationScope({ cancellable: true, timeout }).run(fn)` */\n    static withTimeout(timeout, fn) {\n        return new this({ cancellable: true, timeout }).run(fn);\n    }\n}\nexports.CancellationScope = CancellationScope;\n_CancellationScope_cancelRequested = new WeakMap();\n/**\n * This is exported so it can be disposed in the worker interface\n */\nexports.storage = new exports.AsyncLocalStorage();\nclass RootCancellationScope extends CancellationScope {\n    cancel() {\n        this.reject(new common_1.CancelledFailure(\'Workflow cancelled\'));\n    }\n}\nexports.RootCancellationScope = RootCancellationScope;\n/** There can only be one of these */\nexports.ROOT_SCOPE = new RootCancellationScope({ cancellable: true, parent: NO_PARENT });\n/** This function is here to avoid a circular dependency between this module and workflow.ts */\nlet sleep = (_) => {\n    throw new common_1.IllegalStateError(\'Workflow has not been properly initialized\');\n};\nfunction registerSleepImplementation(fn) {\n    sleep = fn;\n}\nexports.registerSleepImplementation = registerSleepImplementation;\n//# sourceMappingURL=cancellation-scope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2NhbmNlbGxhdGlvbi1zY29wZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyxrQkFBa0IsR0FBRyw2QkFBNkIsR0FBRyxlQUFlLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCO0FBQ2xLLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFvQjtBQUM3QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsdUJBQXVCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLEtBQUssa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLE1BQU0sY0FBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0Msb0JBQW9CO0FBQ3BCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxrQkFBa0IsK0JBQStCLHNDQUFzQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9saWIvY2FuY2VsbGF0aW9uLXNjb3BlLmpzP2VjZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NhbmNlbGxhdGlvblNjb3BlX2NhbmNlbFJlcXVlc3RlZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJTbGVlcEltcGxlbWVudGF0aW9uID0gZXhwb3J0cy5ST09UX1NDT1BFID0gZXhwb3J0cy5Sb290Q2FuY2VsbGF0aW9uU2NvcGUgPSBleHBvcnRzLnN0b3JhZ2UgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNjb3BlID0gZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkB0ZW1wb3JhbGlvL2NvbW1vblwiKTtcbi8vIEFzeW5jTG9jYWxTdG9yYWdlIGlzIGluamVjdGVkIHZpYSB2bSBtb2R1bGUgaW50byBnbG9iYWwgc2NvcGUuXG4vLyBJbiBjYXNlIFdvcmtmbG93IGNvZGUgaXMgaW1wb3J0ZWQgaW4gTm9kZS5qcyBjb250ZXh0LCByZXBsYWNlIHdpdGggYW4gZW1wdHkgY2xhc3MuXG5leHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlID0gZ2xvYmFsVGhpcy5Bc3luY0xvY2FsU3RvcmFnZSA/PyBjbGFzcyB7XG59O1xuLyoqIE1hZ2ljIHN5bWJvbCB1c2VkIHRvIGNyZWF0ZSB0aGUgcm9vdCBzY29wZSAtIGludGVudGlvbmFsbHkgbm90IGV4cG9ydGVkICovXG5jb25zdCBOT19QQVJFTlQgPSBTeW1ib2woJ05PX1BBUkVOVCcpO1xuLyoqXG4gKiBJbiB0aGUgU0RLLCBXb3JrZmxvd3MgYXJlIHJlcHJlc2VudGVkIGludGVybmFsbHkgYnkgYSB0cmVlIG9mIHNjb3BlcyB3aGVyZSB0aGUgYGV4ZWN1dGVgIGZ1bmN0aW9uIHJ1bnMgaW4gdGhlIHJvb3Qgc2NvcGUuXG4gKiBDYW5jZWxsYXRpb24gcHJvcGFnYXRlcyBmcm9tIG91dGVyIHNjb3BlcyB0byBpbm5lciBvbmVzIGFuZCBpcyBoYW5kbGVkIGJ5IGNhdGNoaW5nIHtAbGluayBDYW5jZWxsZWRGYWlsdXJlfXNcbiAqIHRocm93biBieSBjYW5jZWxsYWJsZSBvcGVyYXRpb25zIChzZWUgYmVsb3cpLlxuICpcbiAqIFNjb3BlcyBhcmUgY3JlYXRlZCB1c2luZyB0aGUgYENhbmNlbGxhdGlvblNjb3BlYCBjb25zdHJ1Y3RvciBvciB0aGUgc3RhdGljIGhlbHBlciBtZXRob2RzXG4gKiB7QGxpbmsgY2FuY2VsbGFibGV9LCB7QGxpbmsgbm9uQ2FuY2VsbGFibGV9IGFuZCB7QGxpbmsgd2l0aFRpbWVvdXR9LlxuICpcbiAqIFdoZW4gYSBgQ2FuY2VsbGF0aW9uU2NvcGVgIGlzIGNhbmNlbGxlZCwgaXQgd2lsbCBwcm9wYWdhdGUgY2FuY2VsbGF0aW9uIGFueSBjaGlsZCBzY29wZXMgYW5kIGFueSBjYW5jZWxsYWJsZVxuICogb3BlcmF0aW9ucyBjcmVhdGVkIHdpdGhpbiBpdCwgc3VjaCBhczpcbiAqXG4gKiAtIEFjdGl2aXRpZXNcbiAqIC0gQ2hpbGQgV29ya2Zsb3dzXG4gKiAtIFRpbWVycyAoY3JlYXRlZCB3aXRoIHRoZSB7QGxpbmsgc2xlZXB9IGZ1bmN0aW9uKVxuICogLSB7QGxpbmsgVHJpZ2dlcn1zXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogYXdhaXQgQ2FuY2VsbGF0aW9uU2NvcGUuY2FuY2VsbGFibGUoYXN5bmMgKCkgPT4ge1xuICogICBjb25zdCBwcm9taXNlID0gc29tZUFjdGl2aXR5KCk7XG4gKiAgIENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKS5jYW5jZWwoKTsgLy8gQ2FuY2VscyB0aGUgYWN0aXZpdHlcbiAqICAgYXdhaXQgcHJvbWlzZTsgLy8gVGhyb3dzIENhbmNlbGxlZEZhaWx1cmVcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc2NvcGUgPSBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoKTtcbiAqIGNvbnN0IHByb21pc2UgPSBzY29wZS5ydW4oc29tZUFjdGl2aXR5KTtcbiAqIHNjb3BlLmNhbmNlbCgpOyAvLyBDYW5jZWxzIHRoZSBhY3Rpdml0eVxuICogYXdhaXQgcHJvbWlzZTsgLy8gVGhyb3dzIENhbmNlbGxlZEZhaWx1cmVcbiAqIGBgYFxuICovXG5jbGFzcyBDYW5jZWxsYXRpb25TY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBfQ2FuY2VsbGF0aW9uU2NvcGVfY2FuY2VsUmVxdWVzdGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnM/LnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuY2FuY2VsbGFibGUgPSBvcHRpb25zPy5jYW5jZWxsYWJsZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVzY3JpcHQgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGF0IHRoZSBQcm9taXNlIGV4ZWN1dG9yIHJ1bnMgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2FuY2VsbGF0aW9uU2NvcGVfY2FuY2VsUmVxdWVzdGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgICAgdGhpcy5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnBhcmVudCAhPT0gTk9fUEFSRU5UKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnM/LnBhcmVudCB8fCBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DYW5jZWxsYXRpb25TY29wZV9jYW5jZWxSZXF1ZXN0ZWQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcy5wYXJlbnQsIF9DYW5jZWxsYXRpb25TY29wZV9jYW5jZWxSZXF1ZXN0ZWQsIFwiZlwiKSwgXCJmXCIpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnNpZGVyZWRDYW5jZWxsZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DYW5jZWxsYXRpb25TY29wZV9jYW5jZWxSZXF1ZXN0ZWQsIFwiZlwiKSAmJiB0aGlzLmNhbmNlbGxhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgc2NvcGUgYXMgY3VycmVudCBhbmQgcnVuICBgZm5gXG4gICAgICpcbiAgICAgKiBBbnkgdGltZXJzLCBBY3Rpdml0aWVzLCBUcmlnZ2VycyBhbmQgQ2FuY2VsbGF0aW9uU2NvcGVzIGNyZWF0ZWQgaW4gdGhlIGJvZHkgb2YgYGZuYFxuICAgICAqIGF1dG9tYXRpY2FsbHkgbGluayB0aGVpciBjYW5jZWxsYXRpb24gdG8gdGhpcyBzY29wZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiBgZm5gXG4gICAgICovXG4gICAgcnVuKGZuKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnN0b3JhZ2UucnVuKHRoaXMsIHRoaXMucnVuSW5Db250ZXh0LmJpbmQodGhpcywgZm4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcnVucyBhIGZ1bmN0aW9uIGluIEFzeW5jTG9jYWxTdG9yYWdlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBDb3VsZCBoYXZlIGJlZW4gd3JpdHRlbiBhcyBhbm9ueW1vdXMgZnVuY3Rpb24sIG1hZGUgaW50byBhIG1ldGhvZCBmb3IgaW1wcm92ZWQgc3RhY2sgdHJhY2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkluQ29udGV4dChmbikge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICBzbGVlcCh0aGlzLnRpbWVvdXQpLnRoZW4oKCkgPT4gdGhpcy5jYW5jZWwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gY2FuY2VsIHRoZSBzY29wZSBhbmQgbGlua2VkIGNoaWxkcmVuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLnJlamVjdChuZXcgY29tbW9uXzEuQ2FuY2VsbGVkRmFpbHVyZSgnQ2FuY2VsbGF0aW9uIHNjb3BlIGNhbmNlbGxlZCcpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IFwiYWN0aXZlXCIgc2NvcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc3RvcmFnZS5nZXRTdG9yZSgpID8/IGV4cG9ydHMuUk9PVF9TQ09QRTtcbiAgICB9XG4gICAgLyoqIEFsaWFzIHRvIGBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoeyBjYW5jZWxsYWJsZTogdHJ1ZSB9KS5ydW4oZm4pYCAqL1xuICAgIHN0YXRpYyBjYW5jZWxsYWJsZShmbikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogdHJ1ZSB9KS5ydW4oZm4pO1xuICAgIH1cbiAgICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiBmYWxzZSB9KS5ydW4oZm4pYCAqL1xuICAgIHN0YXRpYyBub25DYW5jZWxsYWJsZShmbikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogZmFsc2UgfSkucnVuKGZuKTtcbiAgICB9XG4gICAgLyoqIEFsaWFzIHRvIGBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoeyBjYW5jZWxsYWJsZTogdHJ1ZSwgdGltZW91dCB9KS5ydW4oZm4pYCAqL1xuICAgIHN0YXRpYyB3aXRoVGltZW91dCh0aW1lb3V0LCBmbikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogdHJ1ZSwgdGltZW91dCB9KS5ydW4oZm4pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uU2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZTtcbl9DYW5jZWxsYXRpb25TY29wZV9jYW5jZWxSZXF1ZXN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGlzIGlzIGV4cG9ydGVkIHNvIGl0IGNhbiBiZSBkaXNwb3NlZCBpbiB0aGUgd29ya2VyIGludGVyZmFjZVxuICovXG5leHBvcnRzLnN0b3JhZ2UgPSBuZXcgZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuY2xhc3MgUm9vdENhbmNlbGxhdGlvblNjb3BlIGV4dGVuZHMgQ2FuY2VsbGF0aW9uU2NvcGUge1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5yZWplY3QobmV3IGNvbW1vbl8xLkNhbmNlbGxlZEZhaWx1cmUoJ1dvcmtmbG93IGNhbmNlbGxlZCcpKTtcbiAgICB9XG59XG5leHBvcnRzLlJvb3RDYW5jZWxsYXRpb25TY29wZSA9IFJvb3RDYW5jZWxsYXRpb25TY29wZTtcbi8qKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgb2YgdGhlc2UgKi9cbmV4cG9ydHMuUk9PVF9TQ09QRSA9IG5ldyBSb290Q2FuY2VsbGF0aW9uU2NvcGUoeyBjYW5jZWxsYWJsZTogdHJ1ZSwgcGFyZW50OiBOT19QQVJFTlQgfSk7XG4vKiogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIGF2b2lkIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgbW9kdWxlIGFuZCB3b3JrZmxvdy50cyAqL1xubGV0IHNsZWVwID0gKF8pID0+IHtcbiAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoJ1dvcmtmbG93IGhhcyBub3QgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZCcpO1xufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbihmbikge1xuICAgIHNsZWVwID0gZm47XG59XG5leHBvcnRzLnJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbiA9IHJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbGxhdGlvbi1zY29wZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/cancellation-scope.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/errors.js':
      /*!*********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/errors.js ***!
  \*********************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCancellation = exports.WorkflowExecutionAlreadyStartedError = exports.DeterminismViolationError = exports.WorkflowError = void 0;\nconst common_1 = __webpack_require__(/*! @temporalio/common */ \"./node_modules/@temporalio/common/lib/index.js\");\n/**\n * Base class for all workflow errors\n */\nclass WorkflowError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'WorkflowError';\n    }\n}\nexports.WorkflowError = WorkflowError;\n/**\n * Thrown in workflow when it trys to do something that non-deterministic such as construct a WeakMap()\n */\nclass DeterminismViolationError extends WorkflowError {\n    constructor() {\n        super(...arguments);\n        this.name = 'DeterminismViolationError';\n    }\n}\nexports.DeterminismViolationError = DeterminismViolationError;\n/**\n * This exception is thrown in the following cases:\n *  - Workflow with the same WorkflowId is currently running\n *  - There is a closed workflow with the same ID and the {@link WorkflowOptions.workflowIdReusePolicy}\n *    is `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`\n *  - There is successfully closed workflow with the same ID and the {@link WorkflowOptions.workflowIdReusePolicy}\n *    is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`\n *  - {@link Workflow.execute} is called *more than once* on a handle created through {@link createChildWorkflowHandle} and the\n *    {@link WorkflowOptions.workflowIdReusePolicy} is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE`\n */\nclass WorkflowExecutionAlreadyStartedError extends WorkflowError {\n    constructor(message, workflowId, workflowType) {\n        super(message);\n        this.workflowId = workflowId;\n        this.workflowType = workflowType;\n        this.name = 'ChildWorkflowExecutionAlreadyStartedError';\n    }\n}\nexports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError;\n/**\n * Returns whether provided `err` is caused by cancellation\n */\nfunction isCancellation(err) {\n    return (err instanceof common_1.CancelledFailure ||\n        ((err instanceof common_1.ActivityFailure || err instanceof common_1.ChildWorkflowFailure) && isCancellation(err.cause)));\n}\nexports.isCancellation = isCancellation;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2Vycm9ycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyw0Q0FBNEMsR0FBRyxpQ0FBaUMsR0FBRyxxQkFBcUI7QUFDakksaUJBQWlCLG1CQUFPLENBQUMsMEVBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsT0FBTyx3QkFBd0Isd0RBQXdELGlDQUFpQztBQUN4SCxPQUFPLDZDQUE2QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2Vycm9ycy5qcz80NWZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0NhbmNlbGxhdGlvbiA9IGV4cG9ydHMuV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yID0gZXhwb3J0cy5EZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yID0gZXhwb3J0cy5Xb3JrZmxvd0Vycm9yID0gdm9pZCAwO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiQHRlbXBvcmFsaW8vY29tbW9uXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgd29ya2Zsb3cgZXJyb3JzXG4gKi9cbmNsYXNzIFdvcmtmbG93RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXb3JrZmxvd0Vycm9yJztcbiAgICB9XG59XG5leHBvcnRzLldvcmtmbG93RXJyb3IgPSBXb3JrZmxvd0Vycm9yO1xuLyoqXG4gKiBUaHJvd24gaW4gd29ya2Zsb3cgd2hlbiBpdCB0cnlzIHRvIGRvIHNvbWV0aGluZyB0aGF0IG5vbi1kZXRlcm1pbmlzdGljIHN1Y2ggYXMgY29uc3RydWN0IGEgV2Vha01hcCgpXG4gKi9cbmNsYXNzIERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IgZXh0ZW5kcyBXb3JrZmxvd0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RldGVybWluaXNtVmlvbGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydHMuRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciA9IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3I7XG4vKipcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICogIC0gV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBXb3JrZmxvd0lkIGlzIGN1cnJlbnRseSBydW5uaW5nXG4gKiAgLSBUaGVyZSBpcyBhIGNsb3NlZCB3b3JrZmxvdyB3aXRoIHRoZSBzYW1lIElEIGFuZCB0aGUge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9XG4gKiAgICBpcyBgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEVgXG4gKiAgLSBUaGVyZSBpcyBzdWNjZXNzZnVsbHkgY2xvc2VkIHdvcmtmbG93IHdpdGggdGhlIHNhbWUgSUQgYW5kIHRoZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeX1cbiAqICAgIGlzIGBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZYFxuICogIC0ge0BsaW5rIFdvcmtmbG93LmV4ZWN1dGV9IGlzIGNhbGxlZCAqbW9yZSB0aGFuIG9uY2UqIG9uIGEgaGFuZGxlIGNyZWF0ZWQgdGhyb3VnaCB7QGxpbmsgY3JlYXRlQ2hpbGRXb3JrZmxvd0hhbmRsZX0gYW5kIHRoZVxuICogICAge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9IGlzIGBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFYFxuICovXG5jbGFzcyBXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3IgZXh0ZW5kcyBXb3JrZmxvd0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB3b3JrZmxvd0lkLCB3b3JrZmxvd1R5cGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMud29ya2Zsb3dJZCA9IHdvcmtmbG93SWQ7XG4gICAgICAgIHRoaXMud29ya2Zsb3dUeXBlID0gd29ya2Zsb3dUeXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydHMuV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yID0gV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgcHJvdmlkZWQgYGVycmAgaXMgY2F1c2VkIGJ5IGNhbmNlbGxhdGlvblxuICovXG5mdW5jdGlvbiBpc0NhbmNlbGxhdGlvbihlcnIpIHtcbiAgICByZXR1cm4gKGVyciBpbnN0YW5jZW9mIGNvbW1vbl8xLkNhbmNlbGxlZEZhaWx1cmUgfHxcbiAgICAgICAgKChlcnIgaW5zdGFuY2VvZiBjb21tb25fMS5BY3Rpdml0eUZhaWx1cmUgfHwgZXJyIGluc3RhbmNlb2YgY29tbW9uXzEuQ2hpbGRXb3JrZmxvd0ZhaWx1cmUpICYmIGlzQ2FuY2VsbGF0aW9uKGVyci5jYXVzZSkpKTtcbn1cbmV4cG9ydHMuaXNDYW5jZWxsYXRpb24gPSBpc0NhbmNlbGxhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/errors.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/index.js':
      /*!********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/index.js ***!
  \********************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          '\n/**\n * This library provides tools required for authoring workflows.\n *\n * ## Usage\n * See the [tutorial](https://docs.temporal.io/docs/typescript/hello-world#workflows) for writing your first workflow.\n *\n * ### Timers\n *\n * The recommended way of scheduling timers is by using the {@link sleep} function.\n * We\'ve replaced `setTimeout` and `clearTimeout` with deterministic versions so these are also usable but have a limitation that they don\'t play well with [cancellation scopes](https://docs.temporal.io/docs/typescript/workflow-scopes-and-cancellation).\n *\n * <!--SNIPSTART typescript-sleep-workflow-->\n * <!--SNIPEND-->\n *\n * ### Activities\n *\n * To schedule Activities, use {@link proxyActivities} to obtain an Activity function and call.\n *\n * <!--SNIPSTART typescript-schedule-activity-workflow-->\n * <!--SNIPEND-->\n *\n * ### Signals and Queries\n *\n * To add signal handlers to a Workflow, add a signals property to the exported `workflow` object.\n * Signal handlers can return either `void` or `Promise<void>`, you may schedule activities and timers from a signal handler.\n *\n * To add query handlers to a Workflow, add a queries property to the exported `workflow` object.\n * Query handlers must **not** mutate any variables or generate any commands (like Activities or Timers), they run synchronously and thus **must** return a `Promise`.\n *\n * #### Interface\n *\n * <!--SNIPSTART typescript-workflow-signal-interface-->\n * <!--SNIPEND-->\n *\n * #### Implementation\n *\n * <!--SNIPSTART typescript-workflow-signal-implementation-->\n * <!--SNIPEND-->\n *\n * ### Deterministic built-ins\n * It is safe to call `Math.random()` and `Date()` in workflow code as they are replaced with deterministic versions. We also provide a deterministic {@link uuid4} function for convenience.\n *\n * ### [Cancellation and scopes](https://docs.temporal.io/docs/typescript/workflow-scopes-and-cancellation)\n * - {@link CancellationScope}\n * - {@link Trigger}\n *\n * ### [Sinks](https://docs.temporal.io/docs/typescript/sinks)\n * - {@link Sinks}\n *\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Trigger = exports.CancellationScope = exports.ROOT_SCOPE = exports.AsyncLocalStorage = exports.ParentClosePolicy = exports.ChildWorkflowCancellationType = exports.ValueError = exports.TimeoutFailure = exports.TerminatedFailure = exports.TemporalFailure = exports.ServerFailure = exports.ChildWorkflowFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ActivityFailure = exports.WorkflowIdReusePolicy = exports.defaultDataConverter = exports.IllegalStateError = exports.rootCause = exports.ActivityCancellationType = void 0;\nvar common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");\nObject.defineProperty(exports, "ActivityCancellationType", ({ enumerable: true, get: function () { return common_1.ActivityCancellationType; } }));\nObject.defineProperty(exports, "rootCause", ({ enumerable: true, get: function () { return common_1.rootCause; } }));\nObject.defineProperty(exports, "IllegalStateError", ({ enumerable: true, get: function () { return common_1.IllegalStateError; } }));\nObject.defineProperty(exports, "defaultDataConverter", ({ enumerable: true, get: function () { return common_1.defaultDataConverter; } }));\nObject.defineProperty(exports, "WorkflowIdReusePolicy", ({ enumerable: true, get: function () { return common_1.WorkflowIdReusePolicy; } }));\nObject.defineProperty(exports, "ActivityFailure", ({ enumerable: true, get: function () { return common_1.ActivityFailure; } }));\nObject.defineProperty(exports, "ApplicationFailure", ({ enumerable: true, get: function () { return common_1.ApplicationFailure; } }));\nObject.defineProperty(exports, "CancelledFailure", ({ enumerable: true, get: function () { return common_1.CancelledFailure; } }));\nObject.defineProperty(exports, "ChildWorkflowFailure", ({ enumerable: true, get: function () { return common_1.ChildWorkflowFailure; } }));\nObject.defineProperty(exports, "ServerFailure", ({ enumerable: true, get: function () { return common_1.ServerFailure; } }));\nObject.defineProperty(exports, "TemporalFailure", ({ enumerable: true, get: function () { return common_1.TemporalFailure; } }));\nObject.defineProperty(exports, "TerminatedFailure", ({ enumerable: true, get: function () { return common_1.TerminatedFailure; } }));\nObject.defineProperty(exports, "TimeoutFailure", ({ enumerable: true, get: function () { return common_1.TimeoutFailure; } }));\nObject.defineProperty(exports, "ValueError", ({ enumerable: true, get: function () { return common_1.ValueError; } }));\nvar interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/workflow/lib/interfaces.js");\nObject.defineProperty(exports, "ChildWorkflowCancellationType", ({ enumerable: true, get: function () { return interfaces_1.ChildWorkflowCancellationType; } }));\nObject.defineProperty(exports, "ParentClosePolicy", ({ enumerable: true, get: function () { return interfaces_1.ParentClosePolicy; } }));\n__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/@temporalio/workflow/lib/errors.js"), exports);\n__exportStar(__webpack_require__(/*! ./workflow */ "./node_modules/@temporalio/workflow/lib/workflow.js"), exports);\n__exportStar(__webpack_require__(/*! ./interceptors */ "./node_modules/@temporalio/workflow/lib/interceptors.js"), exports);\nvar cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");\nObject.defineProperty(exports, "AsyncLocalStorage", ({ enumerable: true, get: function () { return cancellation_scope_1.AsyncLocalStorage; } }));\nObject.defineProperty(exports, "ROOT_SCOPE", ({ enumerable: true, get: function () { return cancellation_scope_1.ROOT_SCOPE; } }));\nObject.defineProperty(exports, "CancellationScope", ({ enumerable: true, get: function () { return cancellation_scope_1.CancellationScope; } }));\nvar trigger_1 = __webpack_require__(/*! ./trigger */ "./node_modules/@temporalio/workflow/lib/trigger.js");\nObject.defineProperty(exports, "Trigger", ({ enumerable: true, get: function () { return trigger_1.Trigger; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLGFBQWE7QUFDcEs7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxxQ0FBcUMsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyxpQkFBaUIsR0FBRyxnQ0FBZ0M7QUFDL2hCLGVBQWUsbUJBQU8sQ0FBQywwRUFBb0I7QUFDM0MsNERBQTJELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ2hKLDZDQUE0QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNsSCxxREFBb0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbEksd0RBQXVELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3hJLHlEQUF3RCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUMxSSxtREFBa0QsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDOUgsc0RBQXFELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ3BJLG9EQUFtRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUNoSSx3REFBdUQsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDeEksaURBQWdELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzFILG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCxxREFBb0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbEksa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBYztBQUN6QyxpRUFBZ0UsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDOUoscURBQW9ELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3RJLGFBQWEsbUJBQU8sQ0FBQyxtRUFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLCtFQUFnQjtBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQywyRkFBc0I7QUFDekQscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDhDQUE2QyxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNoSSxxREFBb0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDOUksZ0JBQWdCLG1CQUFPLENBQUMscUVBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYi9pbmRleC5qcz82M2YzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGlzIGxpYnJhcnkgcHJvdmlkZXMgdG9vbHMgcmVxdWlyZWQgZm9yIGF1dGhvcmluZyB3b3JrZmxvd3MuXG4gKlxuICogIyMgVXNhZ2VcbiAqIFNlZSB0aGUgW3R1dG9yaWFsXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L2hlbGxvLXdvcmxkI3dvcmtmbG93cykgZm9yIHdyaXRpbmcgeW91ciBmaXJzdCB3b3JrZmxvdy5cbiAqXG4gKiAjIyMgVGltZXJzXG4gKlxuICogVGhlIHJlY29tbWVuZGVkIHdheSBvZiBzY2hlZHVsaW5nIHRpbWVycyBpcyBieSB1c2luZyB0aGUge0BsaW5rIHNsZWVwfSBmdW5jdGlvbi5cbiAqIFdlJ3ZlIHJlcGxhY2VkIGBzZXRUaW1lb3V0YCBhbmQgYGNsZWFyVGltZW91dGAgd2l0aCBkZXRlcm1pbmlzdGljIHZlcnNpb25zIHNvIHRoZXNlIGFyZSBhbHNvIHVzYWJsZSBidXQgaGF2ZSBhIGxpbWl0YXRpb24gdGhhdCB0aGV5IGRvbid0IHBsYXkgd2VsbCB3aXRoIFtjYW5jZWxsYXRpb24gc2NvcGVzXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3dvcmtmbG93LXNjb3Blcy1hbmQtY2FuY2VsbGF0aW9uKS5cbiAqXG4gKiA8IS0tU05JUFNUQVJUIHR5cGVzY3JpcHQtc2xlZXAtd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIEFjdGl2aXRpZXNcbiAqXG4gKiBUbyBzY2hlZHVsZSBBY3Rpdml0aWVzLCB1c2Uge0BsaW5rIHByb3h5QWN0aXZpdGllc30gdG8gb2J0YWluIGFuIEFjdGl2aXR5IGZ1bmN0aW9uIGFuZCBjYWxsLlxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC1zY2hlZHVsZS1hY3Rpdml0eS13b3JrZmxvdy0tPlxuICogPCEtLVNOSVBFTkQtLT5cbiAqXG4gKiAjIyMgU2lnbmFscyBhbmQgUXVlcmllc1xuICpcbiAqIFRvIGFkZCBzaWduYWwgaGFuZGxlcnMgdG8gYSBXb3JrZmxvdywgYWRkIGEgc2lnbmFscyBwcm9wZXJ0eSB0byB0aGUgZXhwb3J0ZWQgYHdvcmtmbG93YCBvYmplY3QuXG4gKiBTaWduYWwgaGFuZGxlcnMgY2FuIHJldHVybiBlaXRoZXIgYHZvaWRgIG9yIGBQcm9taXNlPHZvaWQ+YCwgeW91IG1heSBzY2hlZHVsZSBhY3Rpdml0aWVzIGFuZCB0aW1lcnMgZnJvbSBhIHNpZ25hbCBoYW5kbGVyLlxuICpcbiAqIFRvIGFkZCBxdWVyeSBoYW5kbGVycyB0byBhIFdvcmtmbG93LCBhZGQgYSBxdWVyaWVzIHByb3BlcnR5IHRvIHRoZSBleHBvcnRlZCBgd29ya2Zsb3dgIG9iamVjdC5cbiAqIFF1ZXJ5IGhhbmRsZXJzIG11c3QgKipub3QqKiBtdXRhdGUgYW55IHZhcmlhYmxlcyBvciBnZW5lcmF0ZSBhbnkgY29tbWFuZHMgKGxpa2UgQWN0aXZpdGllcyBvciBUaW1lcnMpLCB0aGV5IHJ1biBzeW5jaHJvbm91c2x5IGFuZCB0aHVzICoqbXVzdCoqIHJldHVybiBhIGBQcm9taXNlYC5cbiAqXG4gKiAjIyMjIEludGVyZmFjZVxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC13b3JrZmxvdy1zaWduYWwtaW50ZXJmYWNlLS0+XG4gKiA8IS0tU05JUEVORC0tPlxuICpcbiAqICMjIyMgSW1wbGVtZW50YXRpb25cbiAqXG4gKiA8IS0tU05JUFNUQVJUIHR5cGVzY3JpcHQtd29ya2Zsb3ctc2lnbmFsLWltcGxlbWVudGF0aW9uLS0+XG4gKiA8IS0tU05JUEVORC0tPlxuICpcbiAqICMjIyBEZXRlcm1pbmlzdGljIGJ1aWx0LWluc1xuICogSXQgaXMgc2FmZSB0byBjYWxsIGBNYXRoLnJhbmRvbSgpYCBhbmQgYERhdGUoKWAgaW4gd29ya2Zsb3cgY29kZSBhcyB0aGV5IGFyZSByZXBsYWNlZCB3aXRoIGRldGVybWluaXN0aWMgdmVyc2lvbnMuIFdlIGFsc28gcHJvdmlkZSBhIGRldGVybWluaXN0aWMge0BsaW5rIHV1aWQ0fSBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogIyMjIFtDYW5jZWxsYXRpb24gYW5kIHNjb3Blc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2RvY3MvdHlwZXNjcmlwdC93b3JrZmxvdy1zY29wZXMtYW5kLWNhbmNlbGxhdGlvbilcbiAqIC0ge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfVxuICogLSB7QGxpbmsgVHJpZ2dlcn1cbiAqXG4gKiAjIyMgW1NpbmtzXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3NpbmtzKVxuICogLSB7QGxpbmsgU2lua3N9XG4gKlxuICogQG1vZHVsZVxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJpZ2dlciA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2NvcGUgPSBleHBvcnRzLlJPT1RfU0NPUEUgPSBleHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlID0gZXhwb3J0cy5QYXJlbnRDbG9zZVBvbGljeSA9IGV4cG9ydHMuQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUgPSBleHBvcnRzLlZhbHVlRXJyb3IgPSBleHBvcnRzLlRpbWVvdXRGYWlsdXJlID0gZXhwb3J0cy5UZXJtaW5hdGVkRmFpbHVyZSA9IGV4cG9ydHMuVGVtcG9yYWxGYWlsdXJlID0gZXhwb3J0cy5TZXJ2ZXJGYWlsdXJlID0gZXhwb3J0cy5DaGlsZFdvcmtmbG93RmFpbHVyZSA9IGV4cG9ydHMuQ2FuY2VsbGVkRmFpbHVyZSA9IGV4cG9ydHMuQXBwbGljYXRpb25GYWlsdXJlID0gZXhwb3J0cy5BY3Rpdml0eUZhaWx1cmUgPSBleHBvcnRzLldvcmtmbG93SWRSZXVzZVBvbGljeSA9IGV4cG9ydHMuZGVmYXVsdERhdGFDb252ZXJ0ZXIgPSBleHBvcnRzLklsbGVnYWxTdGF0ZUVycm9yID0gZXhwb3J0cy5yb290Q2F1c2UgPSBleHBvcnRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSA9IHZvaWQgMDtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCJAdGVtcG9yYWxpby9jb21tb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJvb3RDYXVzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEucm9vdENhdXNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWxsZWdhbFN0YXRlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLklsbGVnYWxTdGF0ZUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdERhdGFDb252ZXJ0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLmRlZmF1bHREYXRhQ29udmVydGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2Zsb3dJZFJldXNlUG9saWN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5Xb3JrZmxvd0lkUmV1c2VQb2xpY3k7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY3Rpdml0eUZhaWx1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLkFjdGl2aXR5RmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcGxpY2F0aW9uRmFpbHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEuQXBwbGljYXRpb25GYWlsdXJlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGVkRmFpbHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEuQ2FuY2VsbGVkRmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkV29ya2Zsb3dGYWlsdXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5DaGlsZFdvcmtmbG93RmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlckZhaWx1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLlNlcnZlckZhaWx1cmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZW1wb3JhbEZhaWx1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLlRlbXBvcmFsRmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRlcm1pbmF0ZWRGYWlsdXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5UZXJtaW5hdGVkRmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVvdXRGYWlsdXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5UaW1lb3V0RmFpbHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLlZhbHVlRXJyb3I7IH0gfSk7XG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VzXzEuQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJlbnRDbG9zZVBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlc18xLlBhcmVudENsb3NlUG9saWN5OyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd29ya2Zsb3dcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVyY2VwdG9yc1wiKSwgZXhwb3J0cyk7XG52YXIgY2FuY2VsbGF0aW9uX3Njb3BlXzEgPSByZXF1aXJlKFwiLi9jYW5jZWxsYXRpb24tc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc3luY0xvY2FsU3RvcmFnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uX3Njb3BlXzEuQXN5bmNMb2NhbFN0b3JhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJST09UX1NDT1BFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fc2NvcGVfMS5ST09UX1NDT1BFOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl9zY29wZV8xLkNhbmNlbGxhdGlvblNjb3BlOyB9IH0pO1xudmFyIHRyaWdnZXJfMSA9IHJlcXVpcmUoXCIuL3RyaWdnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmlnZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmlnZ2VyXzEuVHJpZ2dlcjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/index.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/interceptors.js':
      /*!***************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/interceptors.js ***!
  \***************************************************************/
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        eval(
          '\n/**\n * Type definitions and generic helpers for interceptors.\n *\n * The Workflow specific interceptors are defined here.\n *\n * @module\n */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2ludGVyY2VwdG9ycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYi9pbnRlcmNlcHRvcnMuanM/YWIyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVHlwZSBkZWZpbml0aW9ucyBhbmQgZ2VuZXJpYyBoZWxwZXJzIGZvciBpbnRlcmNlcHRvcnMuXG4gKlxuICogVGhlIFdvcmtmbG93IHNwZWNpZmljIGludGVyY2VwdG9ycyBhcmUgZGVmaW5lZCBoZXJlLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/interceptors.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/interfaces.js':
      /*!*************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/interfaces.js ***!
  \*************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ParentClosePolicy = exports.ChildWorkflowCancellationType = exports.ContinueAsNew = void 0;\nconst type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");\n/**\n * Not an actual error, used by the Workflow runtime to abort execution when {@link continueAsNew} is called\n */\nclass ContinueAsNew extends Error {\n    constructor(command) {\n        super();\n        this.command = command;\n        this.type = \'ContinueAsNew\';\n    }\n}\nexports.ContinueAsNew = ContinueAsNew;\nvar ChildWorkflowCancellationType;\n(function (ChildWorkflowCancellationType) {\n    ChildWorkflowCancellationType[ChildWorkflowCancellationType["ABANDON"] = 0] = "ABANDON";\n    ChildWorkflowCancellationType[ChildWorkflowCancellationType["TRY_CANCEL"] = 1] = "TRY_CANCEL";\n    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_COMPLETED"] = 2] = "WAIT_CANCELLATION_COMPLETED";\n    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_REQUESTED"] = 3] = "WAIT_CANCELLATION_REQUESTED";\n})(ChildWorkflowCancellationType = exports.ChildWorkflowCancellationType || (exports.ChildWorkflowCancellationType = {}));\n(0, type_helpers_1.checkExtends)();\nvar ParentClosePolicy;\n(function (ParentClosePolicy) {\n    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_UNSPECIFIED"] = 0] = "PARENT_CLOSE_POLICY_UNSPECIFIED";\n    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_TERMINATE"] = 1] = "PARENT_CLOSE_POLICY_TERMINATE";\n    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_ABANDON"] = 2] = "PARENT_CLOSE_POLICY_ABANDON";\n    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_REQUEST_CANCEL"] = 3] = "PARENT_CLOSE_POLICY_REQUEST_CANCEL";\n})(ParentClosePolicy = exports.ParentClosePolicy || (exports.ParentClosePolicy = {}));\n(0, type_helpers_1.checkExtends)();\n//# sourceMappingURL=interfaces.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2ludGVyZmFjZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcscUNBQXFDLEdBQUcscUJBQXFCO0FBQ3pGLHVCQUF1QixtQkFBTyxDQUFDLGtHQUFxQztBQUNwRTtBQUNBLDhFQUE4RSxxQkFBcUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRFQUE0RSxxQ0FBcUMsS0FBSztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELHlCQUF5QixLQUFLO0FBQ25GO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2ludGVyZmFjZXMuanM/MDhlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyZW50Q2xvc2VQb2xpY3kgPSBleHBvcnRzLkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlID0gZXhwb3J0cy5Db250aW51ZUFzTmV3ID0gdm9pZCAwO1xuY29uc3QgdHlwZV9oZWxwZXJzXzEgPSByZXF1aXJlKFwiQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90eXBlLWhlbHBlcnNcIik7XG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgZXJyb3IsIHVzZWQgYnkgdGhlIFdvcmtmbG93IHJ1bnRpbWUgdG8gYWJvcnQgZXhlY3V0aW9uIHdoZW4ge0BsaW5rIGNvbnRpbnVlQXNOZXd9IGlzIGNhbGxlZFxuICovXG5jbGFzcyBDb250aW51ZUFzTmV3IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgdGhpcy50eXBlID0gJ0NvbnRpbnVlQXNOZXcnO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udGludWVBc05ldyA9IENvbnRpbnVlQXNOZXc7XG52YXIgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGU7XG4oZnVuY3Rpb24gKENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlKSB7XG4gICAgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGVbQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGVbXCJBQkFORE9OXCJdID0gMF0gPSBcIkFCQU5ET05cIjtcbiAgICBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZVtDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZVtcIlRSWV9DQU5DRUxcIl0gPSAxXSA9IFwiVFJZX0NBTkNFTFwiO1xuICAgIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlW0NoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlW1wiV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEXCJdID0gMl0gPSBcIldBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRFwiO1xuICAgIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlW0NoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlW1wiV0FJVF9DQU5DRUxMQVRJT05fUkVRVUVTVEVEXCJdID0gM10gPSBcIldBSVRfQ0FOQ0VMTEFUSU9OX1JFUVVFU1RFRFwiO1xufSkoQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUgPSBleHBvcnRzLkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlIHx8IChleHBvcnRzLkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlID0ge30pKTtcbigwLCB0eXBlX2hlbHBlcnNfMS5jaGVja0V4dGVuZHMpKCk7XG52YXIgUGFyZW50Q2xvc2VQb2xpY3k7XG4oZnVuY3Rpb24gKFBhcmVudENsb3NlUG9saWN5KSB7XG4gICAgUGFyZW50Q2xvc2VQb2xpY3lbUGFyZW50Q2xvc2VQb2xpY3lbXCJQQVJFTlRfQ0xPU0VfUE9MSUNZX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlBBUkVOVF9DTE9TRV9QT0xJQ1lfVU5TUEVDSUZJRURcIjtcbiAgICBQYXJlbnRDbG9zZVBvbGljeVtQYXJlbnRDbG9zZVBvbGljeVtcIlBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFXCJdID0gMV0gPSBcIlBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFXCI7XG4gICAgUGFyZW50Q2xvc2VQb2xpY3lbUGFyZW50Q2xvc2VQb2xpY3lbXCJQQVJFTlRfQ0xPU0VfUE9MSUNZX0FCQU5ET05cIl0gPSAyXSA9IFwiUEFSRU5UX0NMT1NFX1BPTElDWV9BQkFORE9OXCI7XG4gICAgUGFyZW50Q2xvc2VQb2xpY3lbUGFyZW50Q2xvc2VQb2xpY3lbXCJQQVJFTlRfQ0xPU0VfUE9MSUNZX1JFUVVFU1RfQ0FOQ0VMXCJdID0gM10gPSBcIlBBUkVOVF9DTE9TRV9QT0xJQ1lfUkVRVUVTVF9DQU5DRUxcIjtcbn0pKFBhcmVudENsb3NlUG9saWN5ID0gZXhwb3J0cy5QYXJlbnRDbG9zZVBvbGljeSB8fCAoZXhwb3J0cy5QYXJlbnRDbG9zZVBvbGljeSA9IHt9KSk7XG4oMCwgdHlwZV9oZWxwZXJzXzEuY2hlY2tFeHRlbmRzKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/interfaces.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/internals.js':
      /*!************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/internals.js ***!
  \************************************************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          "\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _State_now;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.consumeCompletion = exports.handleWorkflowFailure = exports.state = exports.State = exports.Activator = void 0;\nconst common_1 = __webpack_require__(/*! @temporalio/common */ \"./node_modules/@temporalio/common/lib/index.js\");\nconst type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ \"./node_modules/@temporalio/common/lib/type-helpers.js\");\nconst alea_1 = __webpack_require__(/*! ./alea */ \"./node_modules/@temporalio/workflow/lib/alea.js\");\nconst interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./node_modules/@temporalio/workflow/lib/interfaces.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/@temporalio/workflow/lib/errors.js\");\nconst cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ \"./node_modules/@temporalio/workflow/lib/cancellation-scope.js\");\nvar StartChildWorkflowExecutionFailedCause;\n(function (StartChildWorkflowExecutionFailedCause) {\n    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause[\"START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\"] = 0] = \"START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\";\n    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause[\"START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\"] = 1] = \"START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\";\n})(StartChildWorkflowExecutionFailedCause || (StartChildWorkflowExecutionFailedCause = {}));\n(0, type_helpers_1.checkExtends)();\nclass Activator {\n    constructor() {\n        this.workflowFunctionWasCalled = false;\n    }\n    async startWorkflowNextHandler({ args }) {\n        const { workflow } = exports.state;\n        if (workflow === undefined) {\n            throw new common_1.IllegalStateError('Workflow uninitialized');\n        }\n        let promise;\n        try {\n            promise = workflow(...args);\n        }\n        finally {\n            // Guarantee this runs even if there was an exception when invoking the Workflow function\n            // Otherwise this Workflow will now be queryable.\n            this.workflowFunctionWasCalled = true;\n            // Empty the buffer\n            const buffer = exports.state.bufferedQueries.splice(0);\n            for (const activation of buffer) {\n                this.queryWorkflow(activation);\n            }\n        }\n        return await promise;\n    }\n    startWorkflow(activation) {\n        const { info } = exports.state;\n        if (info === undefined) {\n            throw new common_1.IllegalStateError('Workflow has not been initialized');\n        }\n        const execute = (0, common_1.composeInterceptors)(exports.state.interceptors.inbound, 'execute', this.startWorkflowNextHandler.bind(this));\n        execute({\n            headers: activation.headers ?? {},\n            args: (0, common_1.arrayFromPayloadsSync)(exports.state.dataConverter, activation.arguments),\n        })\n            .then(completeWorkflow)\n            .catch(handleWorkflowFailure);\n    }\n    cancelWorkflow(_activation) {\n        exports.state.cancelled = true;\n        cancellation_scope_1.ROOT_SCOPE.cancel();\n    }\n    fireTimer(activation) {\n        const { resolve } = consumeCompletion('timer', getSeq(activation));\n        resolve(undefined);\n    }\n    async resolveActivity(activation) {\n        if (!activation.result) {\n            throw new TypeError('Got ResolveActivity activation with no result');\n        }\n        const { resolve, reject } = consumeCompletion('activity', getSeq(activation));\n        if (activation.result.completed) {\n            const completed = activation.result.completed;\n            const result = completed.result ? exports.state.dataConverter.fromPayloadSync(completed.result) : undefined;\n            resolve(result);\n        }\n        else if (activation.result.failed) {\n            const { failure } = activation.result.failed;\n            const err = await (0, common_1.optionalFailureToOptionalError)(failure, exports.state.dataConverter);\n            reject(err);\n        }\n        else if (activation.result.cancelled) {\n            const { failure } = activation.result.cancelled;\n            const err = await (0, common_1.optionalFailureToOptionalError)(failure, exports.state.dataConverter);\n            reject(err);\n        }\n    }\n    async resolveChildWorkflowExecutionStart(activation) {\n        const { resolve, reject } = consumeCompletion('childWorkflowStart', getSeq(activation));\n        if (activation.succeeded) {\n            resolve(activation.succeeded.runId);\n        }\n        else if (activation.failed) {\n            if (activation.failed.cause !==\n                StartChildWorkflowExecutionFailedCause.START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS) {\n                throw new common_1.IllegalStateError('Got unknown StartChildWorkflowExecutionFailedCause');\n            }\n            if (!(activation.seq && activation.failed.workflowId && activation.failed.workflowType)) {\n                throw new TypeError('Missing attributes in activation job');\n            }\n            reject(new errors_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', activation.failed.workflowId, activation.failed.workflowType));\n        }\n        else if (activation.cancelled) {\n            if (!activation.cancelled.failure) {\n                throw new TypeError('Got no failure in cancelled variant');\n            }\n            reject(await (0, common_1.failureToError)(activation.cancelled.failure, exports.state.dataConverter));\n        }\n        else {\n            throw new TypeError('Got ResolveChildWorkflowExecutionStart with no status');\n        }\n    }\n    async resolveChildWorkflowExecution(activation) {\n        if (!activation.result) {\n            throw new TypeError('Got ResolveChildWorkflowExecution activation with no result');\n        }\n        const { resolve, reject } = consumeCompletion('childWorkflowComplete', getSeq(activation));\n        if (activation.result.completed) {\n            const completed = activation.result.completed;\n            const result = completed.result ? await exports.state.dataConverter.fromPayload(completed.result) : undefined;\n            resolve(result);\n        }\n        else if (activation.result.failed) {\n            const { failure } = activation.result.failed;\n            if (failure === undefined || failure === null) {\n                throw new TypeError('Got failed result with no failure attribute');\n            }\n            reject(await (0, common_1.failureToError)(failure, exports.state.dataConverter));\n        }\n        else if (activation.result.cancelled) {\n            const { failure } = activation.result.cancelled;\n            if (failure === undefined || failure === null) {\n                throw new TypeError('Got cancelled result with no failure attribute');\n            }\n            reject(await (0, common_1.failureToError)(failure, exports.state.dataConverter));\n        }\n    }\n    async queryWorkflowNextHandler({ queryName, args }) {\n        const fn = exports.state.queryHandlers.get(queryName);\n        if (fn === undefined) {\n            // Fail the query\n            throw new ReferenceError(`Workflow did not register a handler for ${queryName}`);\n        }\n        const ret = fn(...args);\n        if (ret instanceof Promise) {\n            throw new errors_1.DeterminismViolationError('Query handlers should not return a Promise');\n        }\n        return ret;\n    }\n    queryWorkflow(activation) {\n        if (!this.workflowFunctionWasCalled) {\n            exports.state.bufferedQueries.push(activation);\n            return;\n        }\n        const { queryType, queryId } = activation;\n        if (!(queryType && queryId)) {\n            throw new TypeError('Missing query activation attributes');\n        }\n        const execute = (0, common_1.composeInterceptors)(exports.state.interceptors.inbound, 'handleQuery', this.queryWorkflowNextHandler.bind(this));\n        execute({\n            queryName: queryType,\n            args: (0, common_1.arrayFromPayloadsSync)(exports.state.dataConverter, activation.arguments),\n            queryId,\n        }).then((result) => completeQuery(queryId, result), (reason) => failQuery(queryId, reason));\n    }\n    async signalWorkflowNextHandler({ signalName, args }) {\n        const fn = exports.state.signalHandlers.get(signalName);\n        if (fn === undefined) {\n            throw new common_1.IllegalStateError(`No registered signal handler for signal ${signalName}`);\n        }\n        return fn(...args);\n    }\n    signalWorkflow(activation) {\n        const { signalName } = activation;\n        if (!signalName) {\n            throw new TypeError('Missing activation signalName');\n        }\n        const fn = exports.state.signalHandlers.get(signalName);\n        if (fn === undefined) {\n            let buffer = exports.state.bufferedSignals.get(signalName);\n            if (buffer === undefined) {\n                buffer = [];\n                exports.state.bufferedSignals.set(signalName, buffer);\n            }\n            buffer.push(activation);\n            return;\n        }\n        const execute = (0, common_1.composeInterceptors)(exports.state.interceptors.inbound, 'handleSignal', this.signalWorkflowNextHandler.bind(this));\n        execute({\n            args: (0, common_1.arrayFromPayloadsSync)(exports.state.dataConverter, activation.input),\n            signalName,\n        }).catch(handleWorkflowFailure);\n    }\n    async resolveSignalExternalWorkflow(activation) {\n        const { resolve, reject } = consumeCompletion('signalWorkflow', getSeq(activation));\n        if (activation.failure) {\n            reject(await (0, common_1.failureToError)(activation.failure, exports.state.dataConverter));\n        }\n        else {\n            resolve(undefined);\n        }\n    }\n    async resolveRequestCancelExternalWorkflow(activation) {\n        const { resolve, reject } = consumeCompletion('cancelWorkflow', getSeq(activation));\n        if (activation.failure) {\n            reject(await (0, common_1.failureToError)(activation.failure, exports.state.dataConverter));\n        }\n        else {\n            resolve(undefined);\n        }\n    }\n    updateRandomSeed(activation) {\n        if (!activation.randomnessSeed) {\n            throw new TypeError('Expected activation with randomnessSeed attribute');\n        }\n        exports.state.random = (0, alea_1.alea)(activation.randomnessSeed.toBytes());\n    }\n    notifyHasPatch(activation) {\n        if (!activation.patchId) {\n            throw new TypeError('Notify has patch missing patch name');\n        }\n        exports.state.knownPresentPatches.add(activation.patchId);\n    }\n    removeFromCache() {\n        throw new common_1.IllegalStateError('removeFromCache activation job should not reach workflow');\n    }\n}\nexports.Activator = Activator;\n/**\n * Keeps all of the Workflow runtime state like pending completions for activities and timers and the scope stack.\n *\n * State mutates each time the Workflow is activated.\n */\nclass State {\n    constructor() {\n        /**\n         * Activator executes activation jobs\n         */\n        this.activator = new Activator();\n        /**\n         * Map of task sequence to a Completion\n         */\n        this.completions = {\n            timer: new Map(),\n            activity: new Map(),\n            childWorkflowStart: new Map(),\n            childWorkflowComplete: new Map(),\n            signalWorkflow: new Map(),\n            cancelWorkflow: new Map(),\n        };\n        /**\n         * Holds buffered signal calls until a handler is registered\n         */\n        this.bufferedSignals = new Map();\n        /**\n         * Holds buffered query calls until a handler is registered.\n         *\n         * **IMPORTANT** queries are only buffered until workflow is started.\n         * This is required because async interceptors might block workflow function invocation\n         * which delays query handler registration.\n         */\n        this.bufferedQueries = Array();\n        /**\n         * Mapping of signal name to handler\n         */\n        this.signalHandlers = new Map();\n        /**\n         * Mapping of signal name to handler\n         */\n        this.queryHandlers = new Map();\n        /**\n         * Loaded in {@link initRuntime}\n         */\n        this.interceptors = { inbound: [], outbound: [], internals: [] };\n        /**\n         * Buffer that stores all generated commands, reset after each activation\n         */\n        this.commands = [];\n        /**\n        /**\n         * Stores all {@link condition}s that haven't been unblocked yet\n         */\n        this.blockedConditions = new Map();\n        /**\n         * Is this Workflow completed?\n         *\n         * A Workflow will be considered completed if it generates a command that the\n         * system considers as a final Workflow command (e.g.\n         * completeWorkflowExecution or failWorkflowExecution).\n         */\n        this.completed = false;\n        /**\n         * Was this Workflow cancelled?\n         */\n        this.cancelled = false;\n        /**\n         * The next (incremental) sequence to assign when generating completable commands\n         */\n        this.nextSeqs = {\n            timer: 1,\n            activity: 1,\n            childWorkflow: 1,\n            signalWorkflow: 1,\n            cancelWorkflow: 1,\n            condition: 1,\n        };\n        /**\n         * This is set every time the workflow executes an activation\n         */\n        _State_now.set(this, void 0);\n        /**\n         * A deterministic RNG, used by the isolate's overridden Math.random\n         */\n        this.random = function () {\n            throw new common_1.IllegalStateError('Tried to use Math.random before Workflow has been initialized');\n        };\n        this.dataConverter = common_1.defaultDataConverter;\n        /**\n         * Patches we know the status of for this workflow, as in {@link patched}\n         */\n        this.knownPresentPatches = new Set();\n        /**\n         * Patches we sent to core {@link patched}\n         */\n        this.sentPatches = new Set();\n        this.sinkCalls = Array();\n    }\n    get now() {\n        if (__classPrivateFieldGet(this, _State_now, \"f\") === undefined) {\n            throw new common_1.IllegalStateError('Tried to get Date before Workflow has been initialized');\n        }\n        return __classPrivateFieldGet(this, _State_now, \"f\");\n    }\n    set now(value) {\n        __classPrivateFieldSet(this, _State_now, value, \"f\");\n    }\n    getAndResetSinkCalls() {\n        const { sinkCalls } = this;\n        this.sinkCalls = [];\n        return sinkCalls;\n    }\n    /**\n     * Buffer a Workflow command to be collected at the end of the current activation.\n     *\n     * Prevents commands from being added after Workflow completion.\n     */\n    pushCommand(cmd, complete = false) {\n        // Only query responses may be sent after completion\n        if (this.completed && !cmd.respondToQuery)\n            return;\n        this.commands.push(cmd);\n        if (complete) {\n            this.completed = true;\n        }\n    }\n}\nexports.State = State;\n_State_now = new WeakMap();\nexports.state = new State();\nfunction completeWorkflow(result) {\n    exports.state.pushCommand({\n        completeWorkflowExecution: {\n            result: exports.state.dataConverter.toPayloadSync(result),\n        },\n    }, true);\n}\n/**\n * Transforms failures into a command to be sent to the server.\n * Used to handle any failure emitted by the Workflow.\n */\nasync function handleWorkflowFailure(error) {\n    if (exports.state.cancelled && (0, errors_1.isCancellation)(error)) {\n        exports.state.pushCommand({ cancelWorkflowExecution: {} }, true);\n    }\n    else if (error instanceof interfaces_1.ContinueAsNew) {\n        exports.state.pushCommand({ continueAsNewWorkflowExecution: error.command }, true);\n    }\n    else {\n        if (!(error instanceof common_1.TemporalFailure)) {\n            // This results in an unhandled rejection which will fail the activation\n            // preventing it from completing.\n            throw error;\n        }\n        exports.state.pushCommand({\n            failWorkflowExecution: {\n                failure: await (0, common_1.errorToFailure)(error, exports.state.dataConverter),\n            },\n        }, true);\n    }\n}\nexports.handleWorkflowFailure = handleWorkflowFailure;\nfunction completeQuery(queryId, result) {\n    exports.state.pushCommand({\n        respondToQuery: { queryId, succeeded: { response: exports.state.dataConverter.toPayloadSync(result) } },\n    });\n}\nasync function failQuery(queryId, error) {\n    exports.state.pushCommand({\n        respondToQuery: { queryId, failed: await (0, common_1.errorToFailure)((0, common_1.ensureTemporalFailure)(error), exports.state.dataConverter) },\n    });\n}\nfunction consumeCompletion(type, taskSeq) {\n    const completion = exports.state.completions[type].get(taskSeq);\n    if (completion === undefined) {\n        throw new common_1.IllegalStateError(`No completion for taskSeq ${taskSeq}`);\n    }\n    exports.state.completions[type].delete(taskSeq);\n    return completion;\n}\nexports.consumeCompletion = consumeCompletion;\nfunction getSeq(activation) {\n    const seq = activation.seq;\n    if (seq === undefined || seq === null) {\n        throw new TypeError(`Got activation with no seq attribute`);\n    }\n    return seq;\n}\n//# sourceMappingURL=internals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2ludGVybmFscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGlCQUFpQjtBQUM3RyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDN0MsdUJBQXVCLG1CQUFPLENBQUMsa0dBQXFDO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQywrREFBUTtBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQywyRUFBYztBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQywyRkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdGQUF3RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0MsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixVQUFVO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBLDRGQUE0RixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBLG9DQUFvQywrQ0FBK0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0IsK0RBQStEO0FBQy9HLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEhBQThIO0FBQ3hKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL2ludGVybmFscy5qcz8zOTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9TdGF0ZV9ub3c7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN1bWVDb21wbGV0aW9uID0gZXhwb3J0cy5oYW5kbGVXb3JrZmxvd0ZhaWx1cmUgPSBleHBvcnRzLnN0YXRlID0gZXhwb3J0cy5TdGF0ZSA9IGV4cG9ydHMuQWN0aXZhdG9yID0gdm9pZCAwO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiQHRlbXBvcmFsaW8vY29tbW9uXCIpO1xuY29uc3QgdHlwZV9oZWxwZXJzXzEgPSByZXF1aXJlKFwiQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90eXBlLWhlbHBlcnNcIik7XG5jb25zdCBhbGVhXzEgPSByZXF1aXJlKFwiLi9hbGVhXCIpO1xuY29uc3QgaW50ZXJmYWNlc18xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgY2FuY2VsbGF0aW9uX3Njb3BlXzEgPSByZXF1aXJlKFwiLi9jYW5jZWxsYXRpb24tc2NvcGVcIik7XG52YXIgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2U7XG4oZnVuY3Rpb24gKFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlKSB7XG4gICAgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2VbU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2VbXCJTVEFSVF9DSElMRF9XT1JLRkxPV19FWEVDVVRJT05fRkFJTEVEX0NBVVNFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlNUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfVU5TUEVDSUZJRURcIjtcbiAgICBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZVtTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZVtcIlNUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfV09SS0ZMT1dfQUxSRUFEWV9FWElTVFNcIl0gPSAxXSA9IFwiU1RBUlRfQ0hJTERfV09SS0ZMT1dfRVhFQ1VUSU9OX0ZBSUxFRF9DQVVTRV9XT1JLRkxPV19BTFJFQURZX0VYSVNUU1wiO1xufSkoU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UgfHwgKFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlID0ge30pKTtcbigwLCB0eXBlX2hlbHBlcnNfMS5jaGVja0V4dGVuZHMpKCk7XG5jbGFzcyBBY3RpdmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndvcmtmbG93RnVuY3Rpb25XYXNDYWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnRXb3JrZmxvd05leHRIYW5kbGVyKHsgYXJncyB9KSB7XG4gICAgICAgIGNvbnN0IHsgd29ya2Zsb3cgfSA9IGV4cG9ydHMuc3RhdGU7XG4gICAgICAgIGlmICh3b3JrZmxvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoJ1dvcmtmbG93IHVuaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UgPSB3b3JrZmxvdyguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEd1YXJhbnRlZSB0aGlzIHJ1bnMgZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXhjZXB0aW9uIHdoZW4gaW52b2tpbmcgdGhlIFdvcmtmbG93IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhpcyBXb3JrZmxvdyB3aWxsIG5vdyBiZSBxdWVyeWFibGUuXG4gICAgICAgICAgICB0aGlzLndvcmtmbG93RnVuY3Rpb25XYXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gRW1wdHkgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZXhwb3J0cy5zdGF0ZS5idWZmZXJlZFF1ZXJpZXMuc3BsaWNlKDApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY3RpdmF0aW9uIG9mIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlXb3JrZmxvdyhhY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgc3RhcnRXb3JrZmxvdyhhY3RpdmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgaW5mbyB9ID0gZXhwb3J0cy5zdGF0ZTtcbiAgICAgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl8xLklsbGVnYWxTdGF0ZUVycm9yKCdXb3JrZmxvdyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRlID0gKDAsIGNvbW1vbl8xLmNvbXBvc2VJbnRlcmNlcHRvcnMpKGV4cG9ydHMuc3RhdGUuaW50ZXJjZXB0b3JzLmluYm91bmQsICdleGVjdXRlJywgdGhpcy5zdGFydFdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIGV4ZWN1dGUoe1xuICAgICAgICAgICAgaGVhZGVyczogYWN0aXZhdGlvbi5oZWFkZXJzID8/IHt9LFxuICAgICAgICAgICAgYXJnczogKDAsIGNvbW1vbl8xLmFycmF5RnJvbVBheWxvYWRzU3luYykoZXhwb3J0cy5zdGF0ZS5kYXRhQ29udmVydGVyLCBhY3RpdmF0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihjb21wbGV0ZVdvcmtmbG93KVxuICAgICAgICAgICAgLmNhdGNoKGhhbmRsZVdvcmtmbG93RmFpbHVyZSk7XG4gICAgfVxuICAgIGNhbmNlbFdvcmtmbG93KF9hY3RpdmF0aW9uKSB7XG4gICAgICAgIGV4cG9ydHMuc3RhdGUuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY2FuY2VsbGF0aW9uX3Njb3BlXzEuUk9PVF9TQ09QRS5jYW5jZWwoKTtcbiAgICB9XG4gICAgZmlyZVRpbWVyKGFjdGl2YXRpb24pIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlIH0gPSBjb25zdW1lQ29tcGxldGlvbigndGltZXInLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVBY3Rpdml0eShhY3RpdmF0aW9uKSB7XG4gICAgICAgIGlmICghYWN0aXZhdGlvbi5yZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBSZXNvbHZlQWN0aXZpdHkgYWN0aXZhdGlvbiB3aXRoIG5vIHJlc3VsdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjb25zdW1lQ29tcGxldGlvbignYWN0aXZpdHknLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgICAgICBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZWQgPSBhY3RpdmF0aW9uLnJlc3VsdC5jb21wbGV0ZWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0ID8gZXhwb3J0cy5zdGF0ZS5kYXRhQ29udmVydGVyLmZyb21QYXlsb2FkU3luYyhjb21wbGV0ZWQucmVzdWx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkO1xuICAgICAgICAgICAgY29uc3QgZXJyID0gYXdhaXQgKDAsIGNvbW1vbl8xLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcikoZmFpbHVyZSwgZXhwb3J0cy5zdGF0ZS5kYXRhQ29udmVydGVyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQ7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBhd2FpdCAoMCwgY29tbW9uXzEub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKShmYWlsdXJlLCBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb25TdGFydChhY3RpdmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjb25zdW1lQ29tcGxldGlvbignY2hpbGRXb3JrZmxvd1N0YXJ0JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24uc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFjdGl2YXRpb24uc3VjY2VlZGVkLnJ1bklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3RpdmF0aW9uLmZhaWxlZCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2YXRpb24uZmFpbGVkLmNhdXNlICE9PVxuICAgICAgICAgICAgICAgIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlLlNUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfV09SS0ZMT1dfQUxSRUFEWV9FWElTVFMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoJ0dvdCB1bmtub3duIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShhY3RpdmF0aW9uLnNlcSAmJiBhY3RpdmF0aW9uLmZhaWxlZC53b3JrZmxvd0lkICYmIGFjdGl2YXRpb24uZmFpbGVkLndvcmtmbG93VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGF0dHJpYnV0ZXMgaW4gYWN0aXZhdGlvbiBqb2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JzXzEuV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yKCdXb3JrZmxvdyBleGVjdXRpb24gYWxyZWFkeSBzdGFydGVkJywgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dJZCwgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aXZhdGlvbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGlmICghYWN0aXZhdGlvbi5jYW5jZWxsZWQuZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBubyBmYWlsdXJlIGluIGNhbmNlbGxlZCB2YXJpYW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QoYXdhaXQgKDAsIGNvbW1vbl8xLmZhaWx1cmVUb0Vycm9yKShhY3RpdmF0aW9uLmNhbmNlbGxlZC5mYWlsdXJlLCBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblN0YXJ0IHdpdGggbm8gc3RhdHVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb24oYWN0aXZhdGlvbikge1xuICAgICAgICBpZiAoIWFjdGl2YXRpb24ucmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgUmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb24gYWN0aXZhdGlvbiB3aXRoIG5vIHJlc3VsdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjb25zdW1lQ29tcGxldGlvbignY2hpbGRXb3JrZmxvd0NvbXBsZXRlJywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgY29uc3QgY29tcGxldGVkID0gYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdCA/IGF3YWl0IGV4cG9ydHMuc3RhdGUuZGF0YUNvbnZlcnRlci5mcm9tUGF5bG9hZChjb21wbGV0ZWQucmVzdWx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUgPT09IHVuZGVmaW5lZCB8fCBmYWlsdXJlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGZhaWxlZCByZXN1bHQgd2l0aCBubyBmYWlsdXJlIGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KGF3YWl0ICgwLCBjb21tb25fMS5mYWlsdXJlVG9FcnJvcikoZmFpbHVyZSwgZXhwb3J0cy5zdGF0ZS5kYXRhQ29udmVydGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZhaWx1cmUgfSA9IGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZDtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlID09PSB1bmRlZmluZWQgfHwgZmFpbHVyZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBjYW5jZWxsZWQgcmVzdWx0IHdpdGggbm8gZmFpbHVyZSBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChhd2FpdCAoMCwgY29tbW9uXzEuZmFpbHVyZVRvRXJyb3IpKGZhaWx1cmUsIGV4cG9ydHMuc3RhdGUuZGF0YUNvbnZlcnRlcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHF1ZXJ5V29ya2Zsb3dOZXh0SGFuZGxlcih7IHF1ZXJ5TmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGNvbnN0IGZuID0gZXhwb3J0cy5zdGF0ZS5xdWVyeUhhbmRsZXJzLmdldChxdWVyeU5hbWUpO1xuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gRmFpbCB0aGUgcXVlcnlcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgV29ya2Zsb3cgZGlkIG5vdCByZWdpc3RlciBhIGhhbmRsZXIgZm9yICR7cXVlcnlOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkRldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1F1ZXJ5IGhhbmRsZXJzIHNob3VsZCBub3QgcmV0dXJuIGEgUHJvbWlzZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHF1ZXJ5V29ya2Zsb3coYWN0aXZhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMud29ya2Zsb3dGdW5jdGlvbldhc0NhbGxlZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5zdGF0ZS5idWZmZXJlZFF1ZXJpZXMucHVzaChhY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHF1ZXJ5VHlwZSwgcXVlcnlJZCB9ID0gYWN0aXZhdGlvbjtcbiAgICAgICAgaWYgKCEocXVlcnlUeXBlICYmIHF1ZXJ5SWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIHF1ZXJ5IGFjdGl2YXRpb24gYXR0cmlidXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWN1dGUgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoZXhwb3J0cy5zdGF0ZS5pbnRlcmNlcHRvcnMuaW5ib3VuZCwgJ2hhbmRsZVF1ZXJ5JywgdGhpcy5xdWVyeVdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIGV4ZWN1dGUoe1xuICAgICAgICAgICAgcXVlcnlOYW1lOiBxdWVyeVR5cGUsXG4gICAgICAgICAgICBhcmdzOiAoMCwgY29tbW9uXzEuYXJyYXlGcm9tUGF5bG9hZHNTeW5jKShleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIsIGFjdGl2YXRpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHF1ZXJ5SWQsXG4gICAgICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4gY29tcGxldGVRdWVyeShxdWVyeUlkLCByZXN1bHQpLCAocmVhc29uKSA9PiBmYWlsUXVlcnkocXVlcnlJZCwgcmVhc29uKSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIoeyBzaWduYWxOYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgY29uc3QgZm4gPSBleHBvcnRzLnN0YXRlLnNpZ25hbEhhbmRsZXJzLmdldChzaWduYWxOYW1lKTtcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcihgTm8gcmVnaXN0ZXJlZCBzaWduYWwgaGFuZGxlciBmb3Igc2lnbmFsICR7c2lnbmFsTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4oLi4uYXJncyk7XG4gICAgfVxuICAgIHNpZ25hbFdvcmtmbG93KGFjdGl2YXRpb24pIHtcbiAgICAgICAgY29uc3QgeyBzaWduYWxOYW1lIH0gPSBhY3RpdmF0aW9uO1xuICAgICAgICBpZiAoIXNpZ25hbE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZhdGlvbiBzaWduYWxOYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm4gPSBleHBvcnRzLnN0YXRlLnNpZ25hbEhhbmRsZXJzLmdldChzaWduYWxOYW1lKTtcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBleHBvcnRzLnN0YXRlLmJ1ZmZlcmVkU2lnbmFscy5nZXQoc2lnbmFsTmFtZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN0YXRlLmJ1ZmZlcmVkU2lnbmFscy5zZXQoc2lnbmFsTmFtZSwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWN1dGUgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoZXhwb3J0cy5zdGF0ZS5pbnRlcmNlcHRvcnMuaW5ib3VuZCwgJ2hhbmRsZVNpZ25hbCcsIHRoaXMuc2lnbmFsV29ya2Zsb3dOZXh0SGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgZXhlY3V0ZSh7XG4gICAgICAgICAgICBhcmdzOiAoMCwgY29tbW9uXzEuYXJyYXlGcm9tUGF5bG9hZHNTeW5jKShleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIsIGFjdGl2YXRpb24uaW5wdXQpLFxuICAgICAgICAgICAgc2lnbmFsTmFtZSxcbiAgICAgICAgfSkuY2F0Y2goaGFuZGxlV29ya2Zsb3dGYWlsdXJlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZVNpZ25hbEV4dGVybmFsV29ya2Zsb3coYWN0aXZhdGlvbikge1xuICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gY29uc3VtZUNvbXBsZXRpb24oJ3NpZ25hbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24uZmFpbHVyZSkge1xuICAgICAgICAgICAgcmVqZWN0KGF3YWl0ICgwLCBjb21tb25fMS5mYWlsdXJlVG9FcnJvcikoYWN0aXZhdGlvbi5mYWlsdXJlLCBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXNvbHZlUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3coYWN0aXZhdGlvbikge1xuICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gY29uc3VtZUNvbXBsZXRpb24oJ2NhbmNlbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24uZmFpbHVyZSkge1xuICAgICAgICAgICAgcmVqZWN0KGF3YWl0ICgwLCBjb21tb25fMS5mYWlsdXJlVG9FcnJvcikoYWN0aXZhdGlvbi5mYWlsdXJlLCBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSYW5kb21TZWVkKGFjdGl2YXRpb24pIHtcbiAgICAgICAgaWYgKCFhY3RpdmF0aW9uLnJhbmRvbW5lc3NTZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhY3RpdmF0aW9uIHdpdGggcmFuZG9tbmVzc1NlZWQgYXR0cmlidXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5zdGF0ZS5yYW5kb20gPSAoMCwgYWxlYV8xLmFsZWEpKGFjdGl2YXRpb24ucmFuZG9tbmVzc1NlZWQudG9CeXRlcygpKTtcbiAgICB9XG4gICAgbm90aWZ5SGFzUGF0Y2goYWN0aXZhdGlvbikge1xuICAgICAgICBpZiAoIWFjdGl2YXRpb24ucGF0Y2hJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90aWZ5IGhhcyBwYXRjaCBtaXNzaW5nIHBhdGNoIG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnN0YXRlLmtub3duUHJlc2VudFBhdGNoZXMuYWRkKGFjdGl2YXRpb24ucGF0Y2hJZCk7XG4gICAgfVxuICAgIHJlbW92ZUZyb21DYWNoZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl8xLklsbGVnYWxTdGF0ZUVycm9yKCdyZW1vdmVGcm9tQ2FjaGUgYWN0aXZhdGlvbiBqb2Igc2hvdWxkIG5vdCByZWFjaCB3b3JrZmxvdycpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWN0aXZhdG9yID0gQWN0aXZhdG9yO1xuLyoqXG4gKiBLZWVwcyBhbGwgb2YgdGhlIFdvcmtmbG93IHJ1bnRpbWUgc3RhdGUgbGlrZSBwZW5kaW5nIGNvbXBsZXRpb25zIGZvciBhY3Rpdml0aWVzIGFuZCB0aW1lcnMgYW5kIHRoZSBzY29wZSBzdGFjay5cbiAqXG4gKiBTdGF0ZSBtdXRhdGVzIGVhY2ggdGltZSB0aGUgV29ya2Zsb3cgaXMgYWN0aXZhdGVkLlxuICovXG5jbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RpdmF0b3IgZXhlY3V0ZXMgYWN0aXZhdGlvbiBqb2JzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBvZiB0YXNrIHNlcXVlbmNlIHRvIGEgQ29tcGxldGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wbGV0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpbWVyOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBhY3Rpdml0eTogbmV3IE1hcCgpLFxuICAgICAgICAgICAgY2hpbGRXb3JrZmxvd1N0YXJ0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICBjaGlsZFdvcmtmbG93Q29tcGxldGU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHNpZ25hbFdvcmtmbG93OiBuZXcgTWFwKCksXG4gICAgICAgICAgICBjYW5jZWxXb3JrZmxvdzogbmV3IE1hcCgpLFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgYnVmZmVyZWQgc2lnbmFsIGNhbGxzIHVudGlsIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkU2lnbmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIGJ1ZmZlcmVkIHF1ZXJ5IGNhbGxzIHVudGlsIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKklNUE9SVEFOVCoqIHF1ZXJpZXMgYXJlIG9ubHkgYnVmZmVyZWQgdW50aWwgd29ya2Zsb3cgaXMgc3RhcnRlZC5cbiAgICAgICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIGFzeW5jIGludGVyY2VwdG9ycyBtaWdodCBibG9jayB3b3JrZmxvdyBmdW5jdGlvbiBpbnZvY2F0aW9uXG4gICAgICAgICAqIHdoaWNoIGRlbGF5cyBxdWVyeSBoYW5kbGVyIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyZWRRdWVyaWVzID0gQXJyYXkoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHBpbmcgb2Ygc2lnbmFsIG5hbWUgdG8gaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduYWxIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHBpbmcgb2Ygc2lnbmFsIG5hbWUgdG8gaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZGVkIGluIHtAbGluayBpbml0UnVudGltZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0geyBpbmJvdW5kOiBbXSwgb3V0Ym91bmQ6IFtdLCBpbnRlcm5hbHM6IFtdIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgdGhhdCBzdG9yZXMgYWxsIGdlbmVyYXRlZCBjb21tYW5kcywgcmVzZXQgYWZ0ZXIgZWFjaCBhY3RpdmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGFsbCB7QGxpbmsgY29uZGl0aW9ufXMgdGhhdCBoYXZlbid0IGJlZW4gdW5ibG9ja2VkIHlldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja2VkQ29uZGl0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoaXMgV29ya2Zsb3cgY29tcGxldGVkP1xuICAgICAgICAgKlxuICAgICAgICAgKiBBIFdvcmtmbG93IHdpbGwgYmUgY29uc2lkZXJlZCBjb21wbGV0ZWQgaWYgaXQgZ2VuZXJhdGVzIGEgY29tbWFuZCB0aGF0IHRoZVxuICAgICAgICAgKiBzeXN0ZW0gY29uc2lkZXJzIGFzIGEgZmluYWwgV29ya2Zsb3cgY29tbWFuZCAoZS5nLlxuICAgICAgICAgKiBjb21wbGV0ZVdvcmtmbG93RXhlY3V0aW9uIG9yIGZhaWxXb3JrZmxvd0V4ZWN1dGlvbikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2FzIHRoaXMgV29ya2Zsb3cgY2FuY2VsbGVkP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuZXh0IChpbmNyZW1lbnRhbCkgc2VxdWVuY2UgdG8gYXNzaWduIHdoZW4gZ2VuZXJhdGluZyBjb21wbGV0YWJsZSBjb21tYW5kc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0U2VxcyA9IHtcbiAgICAgICAgICAgIHRpbWVyOiAxLFxuICAgICAgICAgICAgYWN0aXZpdHk6IDEsXG4gICAgICAgICAgICBjaGlsZFdvcmtmbG93OiAxLFxuICAgICAgICAgICAgc2lnbmFsV29ya2Zsb3c6IDEsXG4gICAgICAgICAgICBjYW5jZWxXb3JrZmxvdzogMSxcbiAgICAgICAgICAgIGNvbmRpdGlvbjogMSxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgc2V0IGV2ZXJ5IHRpbWUgdGhlIHdvcmtmbG93IGV4ZWN1dGVzIGFuIGFjdGl2YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIF9TdGF0ZV9ub3cuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRldGVybWluaXN0aWMgUk5HLCB1c2VkIGJ5IHRoZSBpc29sYXRlJ3Mgb3ZlcnJpZGRlbiBNYXRoLnJhbmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoJ1RyaWVkIHRvIHVzZSBNYXRoLnJhbmRvbSBiZWZvcmUgV29ya2Zsb3cgaGFzIGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ29udmVydGVyID0gY29tbW9uXzEuZGVmYXVsdERhdGFDb252ZXJ0ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHdlIGtub3cgdGhlIHN0YXR1cyBvZiBmb3IgdGhpcyB3b3JrZmxvdywgYXMgaW4ge0BsaW5rIHBhdGNoZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtub3duUHJlc2VudFBhdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHdlIHNlbnQgdG8gY29yZSB7QGxpbmsgcGF0Y2hlZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VudFBhdGNoZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc2lua0NhbGxzID0gQXJyYXkoKTtcbiAgICB9XG4gICAgZ2V0IG5vdygpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YXRlX25vdywgXCJmXCIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignVHJpZWQgdG8gZ2V0IERhdGUgYmVmb3JlIFdvcmtmbG93IGhhcyBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YXRlX25vdywgXCJmXCIpO1xuICAgIH1cbiAgICBzZXQgbm93KHZhbHVlKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YXRlX25vdywgdmFsdWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0QW5kUmVzZXRTaW5rQ2FsbHMoKSB7XG4gICAgICAgIGNvbnN0IHsgc2lua0NhbGxzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnNpbmtDYWxscyA9IFtdO1xuICAgICAgICByZXR1cm4gc2lua0NhbGxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWZmZXIgYSBXb3JrZmxvdyBjb21tYW5kIHRvIGJlIGNvbGxlY3RlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGFjdGl2YXRpb24uXG4gICAgICpcbiAgICAgKiBQcmV2ZW50cyBjb21tYW5kcyBmcm9tIGJlaW5nIGFkZGVkIGFmdGVyIFdvcmtmbG93IGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgcHVzaENvbW1hbmQoY21kLCBjb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIE9ubHkgcXVlcnkgcmVzcG9uc2VzIG1heSBiZSBzZW50IGFmdGVyIGNvbXBsZXRpb25cbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVkICYmICFjbWQucmVzcG9uZFRvUXVlcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChjbWQpO1xuICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZTtcbl9TdGF0ZV9ub3cgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0cy5zdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuZnVuY3Rpb24gY29tcGxldGVXb3JrZmxvdyhyZXN1bHQpIHtcbiAgICBleHBvcnRzLnN0YXRlLnB1c2hDb21tYW5kKHtcbiAgICAgICAgY29tcGxldGVXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgcmVzdWx0OiBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIudG9QYXlsb2FkU3luYyhyZXN1bHQpLFxuICAgICAgICB9LFxuICAgIH0sIHRydWUpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGZhaWx1cmVzIGludG8gYSBjb21tYW5kIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqIFVzZWQgdG8gaGFuZGxlIGFueSBmYWlsdXJlIGVtaXR0ZWQgYnkgdGhlIFdvcmtmbG93LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXb3JrZmxvd0ZhaWx1cmUoZXJyb3IpIHtcbiAgICBpZiAoZXhwb3J0cy5zdGF0ZS5jYW5jZWxsZWQgJiYgKDAsIGVycm9yc18xLmlzQ2FuY2VsbGF0aW9uKShlcnJvcikpIHtcbiAgICAgICAgZXhwb3J0cy5zdGF0ZS5wdXNoQ29tbWFuZCh7IGNhbmNlbFdvcmtmbG93RXhlY3V0aW9uOiB7fSB9LCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBpbnRlcmZhY2VzXzEuQ29udGludWVBc05ldykge1xuICAgICAgICBleHBvcnRzLnN0YXRlLnB1c2hDb21tYW5kKHsgY29udGludWVBc05ld1dvcmtmbG93RXhlY3V0aW9uOiBlcnJvci5jb21tYW5kIH0sIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBjb21tb25fMS5UZW1wb3JhbEZhaWx1cmUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIHJlamVjdGlvbiB3aGljaCB3aWxsIGZhaWwgdGhlIGFjdGl2YXRpb25cbiAgICAgICAgICAgIC8vIHByZXZlbnRpbmcgaXQgZnJvbSBjb21wbGV0aW5nLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5zdGF0ZS5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICBmYWlsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiBhd2FpdCAoMCwgY29tbW9uXzEuZXJyb3JUb0ZhaWx1cmUpKGVycm9yLCBleHBvcnRzLnN0YXRlLmRhdGFDb252ZXJ0ZXIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5oYW5kbGVXb3JrZmxvd0ZhaWx1cmUgPSBoYW5kbGVXb3JrZmxvd0ZhaWx1cmU7XG5mdW5jdGlvbiBjb21wbGV0ZVF1ZXJ5KHF1ZXJ5SWQsIHJlc3VsdCkge1xuICAgIGV4cG9ydHMuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICByZXNwb25kVG9RdWVyeTogeyBxdWVyeUlkLCBzdWNjZWVkZWQ6IHsgcmVzcG9uc2U6IGV4cG9ydHMuc3RhdGUuZGF0YUNvbnZlcnRlci50b1BheWxvYWRTeW5jKHJlc3VsdCkgfSB9LFxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZmFpbFF1ZXJ5KHF1ZXJ5SWQsIGVycm9yKSB7XG4gICAgZXhwb3J0cy5zdGF0ZS5wdXNoQ29tbWFuZCh7XG4gICAgICAgIHJlc3BvbmRUb1F1ZXJ5OiB7IHF1ZXJ5SWQsIGZhaWxlZDogYXdhaXQgKDAsIGNvbW1vbl8xLmVycm9yVG9GYWlsdXJlKSgoMCwgY29tbW9uXzEuZW5zdXJlVGVtcG9yYWxGYWlsdXJlKShlcnJvciksIGV4cG9ydHMuc3RhdGUuZGF0YUNvbnZlcnRlcikgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVDb21wbGV0aW9uKHR5cGUsIHRhc2tTZXEpIHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gZXhwb3J0cy5zdGF0ZS5jb21wbGV0aW9uc1t0eXBlXS5nZXQodGFza1NlcSk7XG4gICAgaWYgKGNvbXBsZXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoYE5vIGNvbXBsZXRpb24gZm9yIHRhc2tTZXEgJHt0YXNrU2VxfWApO1xuICAgIH1cbiAgICBleHBvcnRzLnN0YXRlLmNvbXBsZXRpb25zW3R5cGVdLmRlbGV0ZSh0YXNrU2VxKTtcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmV4cG9ydHMuY29uc3VtZUNvbXBsZXRpb24gPSBjb25zdW1lQ29tcGxldGlvbjtcbmZ1bmN0aW9uIGdldFNlcShhY3RpdmF0aW9uKSB7XG4gICAgY29uc3Qgc2VxID0gYWN0aXZhdGlvbi5zZXE7XG4gICAgaWYgKHNlcSA9PT0gdW5kZWZpbmVkIHx8IHNlcSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBHb3QgYWN0aXZhdGlvbiB3aXRoIG5vIHNlcSBhdHRyaWJ1dGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/internals.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/trigger.js':
      /*!**********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/trigger.js ***!
  \**********************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Trigger = void 0;\nconst cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");\n/**\n * A `PromiseLike` helper which exposes its `resolve` and `reject` methods.\n *\n * Trigger is CancellationScope aware, it is linked to the current scope on\n * construction and throws when that scope is cancelled.\n *\n * Useful for e.g. waiting for unblocking a Workflow from a signal.\n *\n * @example\n * <!--SNIPSTART typescript-blocked-workflow-->\n * <!--SNIPEND-->\n */\nclass Trigger {\n    constructor() {\n        const promise = new Promise((resolve, reject) => {\n            const scope = cancellation_scope_1.CancellationScope.current();\n            if (scope.consideredCancelled || scope.cancellable) {\n                scope.cancelRequested.catch(reject);\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.resolve = resolve;\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.reject = reject;\n        });\n        // Avoid unhandled rejections\n        promise.catch(() => undefined);\n        this.then = promise.then.bind(promise);\n    }\n}\nexports.Trigger = Trigger;\n//# sourceMappingURL=trigger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL3RyaWdnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLDZCQUE2QixtQkFBTyxDQUFDLDJGQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYi90cmlnZ2VyLmpzPzNhYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyaWdnZXIgPSB2b2lkIDA7XG5jb25zdCBjYW5jZWxsYXRpb25fc2NvcGVfMSA9IHJlcXVpcmUoXCIuL2NhbmNlbGxhdGlvbi1zY29wZVwiKTtcbi8qKlxuICogQSBgUHJvbWlzZUxpa2VgIGhlbHBlciB3aGljaCBleHBvc2VzIGl0cyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIG1ldGhvZHMuXG4gKlxuICogVHJpZ2dlciBpcyBDYW5jZWxsYXRpb25TY29wZSBhd2FyZSwgaXQgaXMgbGlua2VkIHRvIHRoZSBjdXJyZW50IHNjb3BlIG9uXG4gKiBjb25zdHJ1Y3Rpb24gYW5kIHRocm93cyB3aGVuIHRoYXQgc2NvcGUgaXMgY2FuY2VsbGVkLlxuICpcbiAqIFVzZWZ1bCBmb3IgZS5nLiB3YWl0aW5nIGZvciB1bmJsb2NraW5nIGEgV29ya2Zsb3cgZnJvbSBhIHNpZ25hbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPCEtLVNOSVBTVEFSVCB0eXBlc2NyaXB0LWJsb2NrZWQtd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKi9cbmNsYXNzIFRyaWdnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBjYW5jZWxsYXRpb25fc2NvcGVfMS5DYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICAgICAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCB8fCBzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICB9XG59XG5leHBvcnRzLlRyaWdnZXIgPSBUcmlnZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/trigger.js\n'
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/worker-interface.js':
      /*!*******************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/worker-interface.js ***!
  \*******************************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dispose = exports.tryUnblockConditions = exports.getAndResetSinkCalls = exports.concludeActivation = exports.activate = exports.initRuntime = exports.overrideGlobals = exports.setImportFuncs = void 0;\n/**\n * Exported functions for the Worker to interact with the Workflow isolate\n *\n * @module\n */\nconst common_1 = __webpack_require__(/*! @temporalio/common */ \"./node_modules/@temporalio/common/lib/index.js\");\nconst internals_1 = __webpack_require__(/*! ./internals */ \"./node_modules/@temporalio/workflow/lib/internals.js\");\nconst cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ \"./node_modules/@temporalio/workflow/lib/cancellation-scope.js\");\nconst alea_1 = __webpack_require__(/*! ./alea */ \"./node_modules/@temporalio/workflow/lib/alea.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/@temporalio/workflow/lib/errors.js\");\nfunction setImportFuncs({ importWorkflows, importInterceptors }) {\n    internals_1.state.importWorkflows = importWorkflows;\n    internals_1.state.importInterceptors = importInterceptors;\n}\nexports.setImportFuncs = setImportFuncs;\nfunction overrideGlobals() {\n    const global = globalThis;\n    // Mock any weak reference because GC is non-deterministic and the effect is observable from the Workflow.\n    // WeakRef is implemented in V8 8.4 which is embedded in node >=14.6.0.\n    // Workflow developer will get a meaningful exception if they try to use these.\n    global.WeakRef = function () {\n        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in workflows because v8 GC is non-deterministic');\n    };\n    global.FinalizationRegistry = function () {\n        throw new errors_1.DeterminismViolationError('FinalizationRegistry cannot be used in workflows because v8 GC is non-deterministic');\n    };\n    const OriginalDate = globalThis.Date;\n    global.Date = function (...args) {\n        if (args.length > 0) {\n            return new OriginalDate(...args);\n        }\n        return new OriginalDate(internals_1.state.now);\n    };\n    global.Date.now = function () {\n        return internals_1.state.now;\n    };\n    global.Date.parse = OriginalDate.parse.bind(OriginalDate);\n    global.Date.UTC = OriginalDate.UTC.bind(OriginalDate);\n    global.Date.prototype = OriginalDate.prototype;\n    /**\n     * @param ms sleep duration -  number of milliseconds. If given a negative number, value will be set to 1.\n     */\n    global.setTimeout = function (cb, ms, ...args) {\n        ms = Math.max(1, ms);\n        const seq = internals_1.state.nextSeqs.timer++;\n        // Create a Promise for AsyncLocalStorage to be able to track this completion using promise hooks.\n        new Promise((resolve, reject) => {\n            internals_1.state.completions.timer.set(seq, { resolve, reject });\n            internals_1.state.pushCommand({\n                startTimer: {\n                    seq,\n                    startToFireTimeout: (0, common_1.msToTs)(ms),\n                },\n            });\n        }).then(() => cb(...args), () => undefined /* ignore cancellation */);\n        return seq;\n    };\n    global.clearTimeout = function (handle) {\n        internals_1.state.nextSeqs.timer++;\n        internals_1.state.completions.timer.delete(handle);\n        internals_1.state.pushCommand({\n            cancelTimer: {\n                seq: handle,\n            },\n        });\n    };\n    // state.random is mutable, don't hardcode its reference\n    Math.random = () => internals_1.state.random();\n}\nexports.overrideGlobals = overrideGlobals;\n/**\n * Initialize the isolate runtime.\n *\n * Sets required internal state and instantiates the workflow and interceptors.\n */\nasync function initRuntime({ info, randomnessSeed, now, patches }) {\n    // Set the runId globally on the context so it can be retrieved in the case\n    // of an unhandled promise rejection.\n    globalThis.__TEMPORAL__.runId = info.runId;\n    // Globals are overridden while building the isolate before loading user code.\n    // For some reason the `WeakRef` mock is not restored properly when creating an isolate from snapshot in node 14 (at least on ubuntu), override again.\n    globalThis.WeakRef = function () {\n        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in workflows because v8 GC is non-deterministic');\n    };\n    internals_1.state.info = info;\n    internals_1.state.now = now;\n    internals_1.state.random = (0, alea_1.alea)(randomnessSeed);\n    if (info.isReplaying) {\n        for (const patch of patches) {\n            internals_1.state.knownPresentPatches.add(patch);\n        }\n    }\n    const { importWorkflows, importInterceptors } = internals_1.state;\n    if (importWorkflows === undefined || importInterceptors === undefined) {\n        throw new common_1.IllegalStateError('Workflow has not been initialized');\n    }\n    const interceptors = await importInterceptors();\n    for (const mod of interceptors) {\n        const factory = mod.interceptors;\n        if (factory !== undefined) {\n            if (typeof factory !== 'function') {\n                throw new TypeError(`interceptors must be a function, got: ${factory}`);\n            }\n            const interceptors = factory();\n            internals_1.state.interceptors.inbound.push(...(interceptors.inbound ?? []));\n            internals_1.state.interceptors.outbound.push(...(interceptors.outbound ?? []));\n            internals_1.state.interceptors.internals.push(...(interceptors.internals ?? []));\n        }\n    }\n    let workflow;\n    try {\n        const mod = await importWorkflows();\n        workflow = mod[info.workflowType];\n        if (typeof workflow !== 'function') {\n            throw new TypeError(`'${info.workflowType}' is not a function`);\n        }\n    }\n    catch (err) {\n        const failure = common_1.ApplicationFailure.nonRetryable((0, common_1.errorMessage)(err), 'ReferenceError');\n        failure.stack = failure.stack?.split('\\n')[0];\n        (0, internals_1.handleWorkflowFailure)(failure);\n        return;\n    }\n    internals_1.state.workflow = workflow;\n}\nexports.initRuntime = initRuntime;\n/**\n * Run a chunk of activation jobs\n * @returns a boolean indicating whether job was processed or ignored\n */\nasync function activate(activation, batchIndex) {\n    const intercept = (0, common_1.composeInterceptors)(internals_1.state.interceptors.internals, 'activate', async ({ activation, batchIndex }) => {\n        if (batchIndex === 0) {\n            if (internals_1.state.info === undefined) {\n                throw new common_1.IllegalStateError('Workflow has not been initialized');\n            }\n            if (!activation.jobs) {\n                throw new TypeError('Got activation with no jobs');\n            }\n            if (activation.timestamp != null) {\n                // timestamp will not be updated for activation that contain only queries\n                internals_1.state.now = (0, common_1.tsToMs)(activation.timestamp);\n            }\n            internals_1.state.info.isReplaying = activation.isReplaying ?? false;\n        }\n        // Cast from the interface to the class which has the `variant` attribute.\n        // This is safe because we know that activation is a proto class.\n        const jobs = activation.jobs;\n        await Promise.all(jobs.map(async (job) => {\n            if (job.variant === undefined) {\n                throw new TypeError('Expected job.variant to be defined');\n            }\n            const variant = job[job.variant];\n            if (!variant) {\n                throw new TypeError(`Expected job.${job.variant} to be set`);\n            }\n            // The only job that can be executed on a completed workflow is a query.\n            // We might get other jobs after completion for instance when a single\n            // activation contains multiple jobs and the first one completes the workflow.\n            if (internals_1.state.completed && job.variant !== 'queryWorkflow') {\n                return;\n            }\n            await internals_1.state.activator[job.variant](variant /* TS can't infer this type */);\n            tryUnblockConditions();\n        }));\n    });\n    await intercept({\n        activation,\n        batchIndex,\n    });\n    return {\n        numBlockedConditions: internals_1.state.blockedConditions.size,\n    };\n}\nexports.activate = activate;\n/**\n * Conclude a single activation.\n * Should be called after processing all activation jobs and queued microtasks.\n *\n * Activation failures are handled in the main Node.js isolate.\n */\nfunction concludeActivation() {\n    const intercept = (0, common_1.composeInterceptors)(internals_1.state.interceptors.internals, 'concludeActivation', (input) => input);\n    const { info } = internals_1.state;\n    const { commands } = intercept({ commands: internals_1.state.commands });\n    internals_1.state.commands = [];\n    return {\n        runId: info?.runId,\n        successful: { commands },\n    };\n}\nexports.concludeActivation = concludeActivation;\nfunction getAndResetSinkCalls() {\n    return internals_1.state.getAndResetSinkCalls();\n}\nexports.getAndResetSinkCalls = getAndResetSinkCalls;\n/**\n * Loop through all blocked conditions, evaluate and unblock if possible.\n *\n * @returns number of unblocked conditions.\n */\nfunction tryUnblockConditions() {\n    let numUnblocked = 0;\n    for (;;) {\n        const prevUnblocked = numUnblocked;\n        for (const [seq, cond] of internals_1.state.blockedConditions.entries()) {\n            if (cond.fn()) {\n                cond.resolve();\n                numUnblocked++;\n                // It is safe to delete elements during map iteration\n                internals_1.state.blockedConditions.delete(seq);\n            }\n        }\n        if (prevUnblocked === numUnblocked) {\n            break;\n        }\n    }\n    return numUnblocked;\n}\nexports.tryUnblockConditions = tryUnblockConditions;\nasync function dispose() {\n    const dispose = (0, common_1.composeInterceptors)(internals_1.state.interceptors.internals, 'dispose', async () => {\n        cancellation_scope_1.storage.disable();\n    });\n    await dispose({});\n}\nexports.dispose = dispose;\n//# sourceMappingURL=worker-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL3dvcmtlci1pbnRlcmZhY2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHNCQUFzQjtBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQW9CO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDJGQUFzQjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsK0RBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsUUFBUTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsd0JBQXdCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFdBQVcsY0FBYyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7QUFDcEI7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL3dvcmtlci1pbnRlcmZhY2UuanM/MDVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGlzcG9zZSA9IGV4cG9ydHMudHJ5VW5ibG9ja0NvbmRpdGlvbnMgPSBleHBvcnRzLmdldEFuZFJlc2V0U2lua0NhbGxzID0gZXhwb3J0cy5jb25jbHVkZUFjdGl2YXRpb24gPSBleHBvcnRzLmFjdGl2YXRlID0gZXhwb3J0cy5pbml0UnVudGltZSA9IGV4cG9ydHMub3ZlcnJpZGVHbG9iYWxzID0gZXhwb3J0cy5zZXRJbXBvcnRGdW5jcyA9IHZvaWQgMDtcbi8qKlxuICogRXhwb3J0ZWQgZnVuY3Rpb25zIGZvciB0aGUgV29ya2VyIHRvIGludGVyYWN0IHdpdGggdGhlIFdvcmtmbG93IGlzb2xhdGVcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkB0ZW1wb3JhbGlvL2NvbW1vblwiKTtcbmNvbnN0IGludGVybmFsc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzXCIpO1xuY29uc3QgY2FuY2VsbGF0aW9uX3Njb3BlXzEgPSByZXF1aXJlKFwiLi9jYW5jZWxsYXRpb24tc2NvcGVcIik7XG5jb25zdCBhbGVhXzEgPSByZXF1aXJlKFwiLi9hbGVhXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBzZXRJbXBvcnRGdW5jcyh7IGltcG9ydFdvcmtmbG93cywgaW1wb3J0SW50ZXJjZXB0b3JzIH0pIHtcbiAgICBpbnRlcm5hbHNfMS5zdGF0ZS5pbXBvcnRXb3JrZmxvd3MgPSBpbXBvcnRXb3JrZmxvd3M7XG4gICAgaW50ZXJuYWxzXzEuc3RhdGUuaW1wb3J0SW50ZXJjZXB0b3JzID0gaW1wb3J0SW50ZXJjZXB0b3JzO1xufVxuZXhwb3J0cy5zZXRJbXBvcnRGdW5jcyA9IHNldEltcG9ydEZ1bmNzO1xuZnVuY3Rpb24gb3ZlcnJpZGVHbG9iYWxzKCkge1xuICAgIGNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG4gICAgLy8gTW9jayBhbnkgd2VhayByZWZlcmVuY2UgYmVjYXVzZSBHQyBpcyBub24tZGV0ZXJtaW5pc3RpYyBhbmQgdGhlIGVmZmVjdCBpcyBvYnNlcnZhYmxlIGZyb20gdGhlIFdvcmtmbG93LlxuICAgIC8vIFdlYWtSZWYgaXMgaW1wbGVtZW50ZWQgaW4gVjggOC40IHdoaWNoIGlzIGVtYmVkZGVkIGluIG5vZGUgPj0xNC42LjAuXG4gICAgLy8gV29ya2Zsb3cgZGV2ZWxvcGVyIHdpbGwgZ2V0IGEgbWVhbmluZ2Z1bCBleGNlcHRpb24gaWYgdGhleSB0cnkgdG8gdXNlIHRoZXNlLlxuICAgIGdsb2JhbC5XZWFrUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvcignV2Vha1JlZiBjYW5ub3QgYmUgdXNlZCBpbiB3b3JrZmxvd3MgYmVjYXVzZSB2OCBHQyBpcyBub24tZGV0ZXJtaW5pc3RpYycpO1xuICAgIH07XG4gICAgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvcignRmluYWxpemF0aW9uUmVnaXN0cnkgY2Fubm90IGJlIHVzZWQgaW4gd29ya2Zsb3dzIGJlY2F1c2UgdjggR0MgaXMgbm9uLWRldGVybWluaXN0aWMnKTtcbiAgICB9O1xuICAgIGNvbnN0IE9yaWdpbmFsRGF0ZSA9IGdsb2JhbFRoaXMuRGF0ZTtcbiAgICBnbG9iYWwuRGF0ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3JpZ2luYWxEYXRlKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT3JpZ2luYWxEYXRlKGludGVybmFsc18xLnN0YXRlLm5vdyk7XG4gICAgfTtcbiAgICBnbG9iYWwuRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHNfMS5zdGF0ZS5ub3c7XG4gICAgfTtcbiAgICBnbG9iYWwuRGF0ZS5wYXJzZSA9IE9yaWdpbmFsRGF0ZS5wYXJzZS5iaW5kKE9yaWdpbmFsRGF0ZSk7XG4gICAgZ2xvYmFsLkRhdGUuVVRDID0gT3JpZ2luYWxEYXRlLlVUQy5iaW5kKE9yaWdpbmFsRGF0ZSk7XG4gICAgZ2xvYmFsLkRhdGUucHJvdG90eXBlID0gT3JpZ2luYWxEYXRlLnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbXMgc2xlZXAgZHVyYXRpb24gLSAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gSWYgZ2l2ZW4gYSBuZWdhdGl2ZSBudW1iZXIsIHZhbHVlIHdpbGwgYmUgc2V0IHRvIDEuXG4gICAgICovXG4gICAgZ2xvYmFsLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoY2IsIG1zLCAuLi5hcmdzKSB7XG4gICAgICAgIG1zID0gTWF0aC5tYXgoMSwgbXMpO1xuICAgICAgICBjb25zdCBzZXEgPSBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy50aW1lcisrO1xuICAgICAgICAvLyBDcmVhdGUgYSBQcm9taXNlIGZvciBBc3luY0xvY2FsU3RvcmFnZSB0byBiZSBhYmxlIHRvIHRyYWNrIHRoaXMgY29tcGxldGlvbiB1c2luZyBwcm9taXNlIGhvb2tzLlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy50aW1lci5zZXQoc2VxLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUb0ZpcmVUaW1lb3V0OiAoMCwgY29tbW9uXzEubXNUb1RzKShtcyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKCgpID0+IGNiKC4uLmFyZ3MpLCAoKSA9PiB1bmRlZmluZWQgLyogaWdub3JlIGNhbmNlbGxhdGlvbiAqLyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfTtcbiAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy50aW1lcisrO1xuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaGFuZGxlKTtcbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgY2FuY2VsVGltZXI6IHtcbiAgICAgICAgICAgICAgICBzZXE6IGhhbmRsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gc3RhdGUucmFuZG9tIGlzIG11dGFibGUsIGRvbid0IGhhcmRjb2RlIGl0cyByZWZlcmVuY2VcbiAgICBNYXRoLnJhbmRvbSA9ICgpID0+IGludGVybmFsc18xLnN0YXRlLnJhbmRvbSgpO1xufVxuZXhwb3J0cy5vdmVycmlkZUdsb2JhbHMgPSBvdmVycmlkZUdsb2JhbHM7XG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGlzb2xhdGUgcnVudGltZS5cbiAqXG4gKiBTZXRzIHJlcXVpcmVkIGludGVybmFsIHN0YXRlIGFuZCBpbnN0YW50aWF0ZXMgdGhlIHdvcmtmbG93IGFuZCBpbnRlcmNlcHRvcnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXRSdW50aW1lKHsgaW5mbywgcmFuZG9tbmVzc1NlZWQsIG5vdywgcGF0Y2hlcyB9KSB7XG4gICAgLy8gU2V0IHRoZSBydW5JZCBnbG9iYWxseSBvbiB0aGUgY29udGV4dCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGluIHRoZSBjYXNlXG4gICAgLy8gb2YgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLlxuICAgIGdsb2JhbFRoaXMuX19URU1QT1JBTF9fLnJ1bklkID0gaW5mby5ydW5JZDtcbiAgICAvLyBHbG9iYWxzIGFyZSBvdmVycmlkZGVuIHdoaWxlIGJ1aWxkaW5nIHRoZSBpc29sYXRlIGJlZm9yZSBsb2FkaW5nIHVzZXIgY29kZS5cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdGhlIGBXZWFrUmVmYCBtb2NrIGlzIG5vdCByZXN0b3JlZCBwcm9wZXJseSB3aGVuIGNyZWF0aW5nIGFuIGlzb2xhdGUgZnJvbSBzbmFwc2hvdCBpbiBub2RlIDE0IChhdCBsZWFzdCBvbiB1YnVudHUpLCBvdmVycmlkZSBhZ2Fpbi5cbiAgICBnbG9iYWxUaGlzLldlYWtSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5EZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yKCdXZWFrUmVmIGNhbm5vdCBiZSB1c2VkIGluIHdvcmtmbG93cyBiZWNhdXNlIHY4IEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljJyk7XG4gICAgfTtcbiAgICBpbnRlcm5hbHNfMS5zdGF0ZS5pbmZvID0gaW5mbztcbiAgICBpbnRlcm5hbHNfMS5zdGF0ZS5ub3cgPSBub3c7XG4gICAgaW50ZXJuYWxzXzEuc3RhdGUucmFuZG9tID0gKDAsIGFsZWFfMS5hbGVhKShyYW5kb21uZXNzU2VlZCk7XG4gICAgaWYgKGluZm8uaXNSZXBsYXlpbmcpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5rbm93blByZXNlbnRQYXRjaGVzLmFkZChwYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBpbXBvcnRXb3JrZmxvd3MsIGltcG9ydEludGVyY2VwdG9ycyB9ID0gaW50ZXJuYWxzXzEuc3RhdGU7XG4gICAgaWYgKGltcG9ydFdvcmtmbG93cyA9PT0gdW5kZWZpbmVkIHx8IGltcG9ydEludGVyY2VwdG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGF3YWl0IGltcG9ydEludGVyY2VwdG9ycygpO1xuICAgIGZvciAoY29uc3QgbW9kIG9mIGludGVyY2VwdG9ycykge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gbW9kLmludGVyY2VwdG9ycztcbiAgICAgICAgaWYgKGZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW50ZXJjZXB0b3JzIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiAke2ZhY3Rvcnl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5pbnRlcmNlcHRvcnMuaW5ib3VuZC5wdXNoKC4uLihpbnRlcmNlcHRvcnMuaW5ib3VuZCA/PyBbXSkpO1xuICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLm91dGJvdW5kLnB1c2goLi4uKGludGVyY2VwdG9ycy5vdXRib3VuZCA/PyBbXSkpO1xuICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLmludGVybmFscy5wdXNoKC4uLihpbnRlcmNlcHRvcnMuaW50ZXJuYWxzID8/IFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdvcmtmbG93O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydFdvcmtmbG93cygpO1xuICAgICAgICB3b3JrZmxvdyA9IG1vZFtpbmZvLndvcmtmbG93VHlwZV07XG4gICAgICAgIGlmICh0eXBlb2Ygd29ya2Zsb3cgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCcke2luZm8ud29ya2Zsb3dUeXBlfScgaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGZhaWx1cmUgPSBjb21tb25fMS5BcHBsaWNhdGlvbkZhaWx1cmUubm9uUmV0cnlhYmxlKCgwLCBjb21tb25fMS5lcnJvck1lc3NhZ2UpKGVyciksICdSZWZlcmVuY2VFcnJvcicpO1xuICAgICAgICBmYWlsdXJlLnN0YWNrID0gZmFpbHVyZS5zdGFjaz8uc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAoMCwgaW50ZXJuYWxzXzEuaGFuZGxlV29ya2Zsb3dGYWlsdXJlKShmYWlsdXJlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnRlcm5hbHNfMS5zdGF0ZS53b3JrZmxvdyA9IHdvcmtmbG93O1xufVxuZXhwb3J0cy5pbml0UnVudGltZSA9IGluaXRSdW50aW1lO1xuLyoqXG4gKiBSdW4gYSBjaHVuayBvZiBhY3RpdmF0aW9uIGpvYnNcbiAqIEByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgam9iIHdhcyBwcm9jZXNzZWQgb3IgaWdub3JlZFxuICovXG5hc3luYyBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0aW9uLCBiYXRjaEluZGV4KSB7XG4gICAgY29uc3QgaW50ZXJjZXB0ID0gKDAsIGNvbW1vbl8xLmNvbXBvc2VJbnRlcmNlcHRvcnMpKGludGVybmFsc18xLnN0YXRlLmludGVyY2VwdG9ycy5pbnRlcm5hbHMsICdhY3RpdmF0ZScsIGFzeW5jICh7IGFjdGl2YXRpb24sIGJhdGNoSW5kZXggfSkgPT4ge1xuICAgICAgICBpZiAoYmF0Y2hJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGludGVybmFsc18xLnN0YXRlLmluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFjdGl2YXRpb24uam9icykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBhY3RpdmF0aW9uIHdpdGggbm8gam9icycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2YXRpb24udGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZCBmb3IgYWN0aXZhdGlvbiB0aGF0IGNvbnRhaW4gb25seSBxdWVyaWVzXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUubm93ID0gKDAsIGNvbW1vbl8xLnRzVG9NcykoYWN0aXZhdGlvbi50aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuaW5mby5pc1JlcGxheWluZyA9IGFjdGl2YXRpb24uaXNSZXBsYXlpbmcgPz8gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FzdCBmcm9tIHRoZSBpbnRlcmZhY2UgdG8gdGhlIGNsYXNzIHdoaWNoIGhhcyB0aGUgYHZhcmlhbnRgIGF0dHJpYnV0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFjdGl2YXRpb24gaXMgYSBwcm90byBjbGFzcy5cbiAgICAgICAgY29uc3Qgam9icyA9IGFjdGl2YXRpb24uam9icztcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icy5tYXAoYXN5bmMgKGpvYikgPT4ge1xuICAgICAgICAgICAgaWYgKGpvYi52YXJpYW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBqb2IudmFyaWFudCB0byBiZSBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50ID0gam9iW2pvYi52YXJpYW50XTtcbiAgICAgICAgICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGpvYi4ke2pvYi52YXJpYW50fSB0byBiZSBzZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBvbmx5IGpvYiB0aGF0IGNhbiBiZSBleGVjdXRlZCBvbiBhIGNvbXBsZXRlZCB3b3JrZmxvdyBpcyBhIHF1ZXJ5LlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgZ2V0IG90aGVyIGpvYnMgYWZ0ZXIgY29tcGxldGlvbiBmb3IgaW5zdGFuY2Ugd2hlbiBhIHNpbmdsZVxuICAgICAgICAgICAgLy8gYWN0aXZhdGlvbiBjb250YWlucyBtdWx0aXBsZSBqb2JzIGFuZCB0aGUgZmlyc3Qgb25lIGNvbXBsZXRlcyB0aGUgd29ya2Zsb3cuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGVkICYmIGpvYi52YXJpYW50ICE9PSAncXVlcnlXb3JrZmxvdycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBpbnRlcm5hbHNfMS5zdGF0ZS5hY3RpdmF0b3Jbam9iLnZhcmlhbnRdKHZhcmlhbnQgLyogVFMgY2FuJ3QgaW5mZXIgdGhpcyB0eXBlICovKTtcbiAgICAgICAgICAgIHRyeVVuYmxvY2tDb25kaXRpb25zKCk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBhd2FpdCBpbnRlcmNlcHQoe1xuICAgICAgICBhY3RpdmF0aW9uLFxuICAgICAgICBiYXRjaEluZGV4LFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG51bUJsb2NrZWRDb25kaXRpb25zOiBpbnRlcm5hbHNfMS5zdGF0ZS5ibG9ja2VkQ29uZGl0aW9ucy5zaXplLFxuICAgIH07XG59XG5leHBvcnRzLmFjdGl2YXRlID0gYWN0aXZhdGU7XG4vKipcbiAqIENvbmNsdWRlIGEgc2luZ2xlIGFjdGl2YXRpb24uXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHByb2Nlc3NpbmcgYWxsIGFjdGl2YXRpb24gam9icyBhbmQgcXVldWVkIG1pY3JvdGFza3MuXG4gKlxuICogQWN0aXZhdGlvbiBmYWlsdXJlcyBhcmUgaGFuZGxlZCBpbiB0aGUgbWFpbiBOb2RlLmpzIGlzb2xhdGUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNsdWRlQWN0aXZhdGlvbigpIHtcbiAgICBjb25zdCBpbnRlcmNlcHQgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLmludGVybmFscywgJ2NvbmNsdWRlQWN0aXZhdGlvbicsIChpbnB1dCkgPT4gaW5wdXQpO1xuICAgIGNvbnN0IHsgaW5mbyB9ID0gaW50ZXJuYWxzXzEuc3RhdGU7XG4gICAgY29uc3QgeyBjb21tYW5kcyB9ID0gaW50ZXJjZXB0KHsgY29tbWFuZHM6IGludGVybmFsc18xLnN0YXRlLmNvbW1hbmRzIH0pO1xuICAgIGludGVybmFsc18xLnN0YXRlLmNvbW1hbmRzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuSWQ6IGluZm8/LnJ1bklkLFxuICAgICAgICBzdWNjZXNzZnVsOiB7IGNvbW1hbmRzIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuY29uY2x1ZGVBY3RpdmF0aW9uID0gY29uY2x1ZGVBY3RpdmF0aW9uO1xuZnVuY3Rpb24gZ2V0QW5kUmVzZXRTaW5rQ2FsbHMoKSB7XG4gICAgcmV0dXJuIGludGVybmFsc18xLnN0YXRlLmdldEFuZFJlc2V0U2lua0NhbGxzKCk7XG59XG5leHBvcnRzLmdldEFuZFJlc2V0U2lua0NhbGxzID0gZ2V0QW5kUmVzZXRTaW5rQ2FsbHM7XG4vKipcbiAqIExvb3AgdGhyb3VnaCBhbGwgYmxvY2tlZCBjb25kaXRpb25zLCBldmFsdWF0ZSBhbmQgdW5ibG9jayBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcmV0dXJucyBudW1iZXIgb2YgdW5ibG9ja2VkIGNvbmRpdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRyeVVuYmxvY2tDb25kaXRpb25zKCkge1xuICAgIGxldCBudW1VbmJsb2NrZWQgPSAwO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgcHJldlVuYmxvY2tlZCA9IG51bVVuYmxvY2tlZDtcbiAgICAgICAgZm9yIChjb25zdCBbc2VxLCBjb25kXSBvZiBpbnRlcm5hbHNfMS5zdGF0ZS5ibG9ja2VkQ29uZGl0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjb25kLmZuKCkpIHtcbiAgICAgICAgICAgICAgICBjb25kLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBudW1VbmJsb2NrZWQrKztcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBzYWZlIHRvIGRlbGV0ZSBlbGVtZW50cyBkdXJpbmcgbWFwIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLmJsb2NrZWRDb25kaXRpb25zLmRlbGV0ZShzZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2VW5ibG9ja2VkID09PSBudW1VbmJsb2NrZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW1VbmJsb2NrZWQ7XG59XG5leHBvcnRzLnRyeVVuYmxvY2tDb25kaXRpb25zID0gdHJ5VW5ibG9ja0NvbmRpdGlvbnM7XG5hc3luYyBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLmludGVybmFscywgJ2Rpc3Bvc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbmNlbGxhdGlvbl9zY29wZV8xLnN0b3JhZ2UuZGlzYWJsZSgpO1xuICAgIH0pO1xuICAgIGF3YWl0IGRpc3Bvc2Uoe30pO1xufVxuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/worker-interface.js\n"
        );

        /***/
      },

    /***/ './node_modules/@temporalio/workflow/lib/workflow.js':
      /*!***********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/workflow.js ***!
  \***********************************************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setHandler = exports.defineQuery = exports.defineSignal = exports.condition = exports.deprecatePatch = exports.patched = exports.uuid4 = exports.continueAsNew = exports.makeContinueAsNewFunc = exports.proxySinks = exports.workflowInfo = exports.executeChild = exports.startChild = exports.getExternalWorkflowHandle = exports.proxyActivities = exports.scheduleActivity = exports.validateActivityOptions = exports.sleep = exports.addDefaultWorkflowOptions = void 0;\nconst common_1 = __webpack_require__(/*! @temporalio/common */ \"./node_modules/@temporalio/common/lib/index.js\");\nconst interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./node_modules/@temporalio/workflow/lib/interfaces.js\");\nconst internals_1 = __webpack_require__(/*! ./internals */ \"./node_modules/@temporalio/workflow/lib/internals.js\");\nconst cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ \"./node_modules/@temporalio/workflow/lib/cancellation-scope.js\");\n// Avoid a circular dependency\n(0, cancellation_scope_1.registerSleepImplementation)(sleep);\n/**\n * Adds default values to `workflowId` and `workflowIdReusePolicy` to given workflow options.\n */\nfunction addDefaultWorkflowOptions(opts) {\n    const { args, workflowId, ...rest } = opts;\n    return {\n        workflowId: workflowId ?? uuid4(),\n        args: args ?? [],\n        cancellationType: interfaces_1.ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        ...rest,\n    };\n}\nexports.addDefaultWorkflowOptions = addDefaultWorkflowOptions;\n/**\n * Push a startTimer command into state accumulator and register completion\n */\nfunction timerNextHandler(input) {\n    return new Promise((resolve, reject) => {\n        const scope = cancellation_scope_1.CancellationScope.current();\n        if (scope.consideredCancelled) {\n            scope.cancelRequested.catch(reject);\n            return;\n        }\n        if (scope.cancellable) {\n            scope.cancelRequested.catch((err) => {\n                if (!internals_1.state.completions.timer.delete(input.seq)) {\n                    return; // Already resolved\n                }\n                internals_1.state.pushCommand({\n                    cancelTimer: {\n                        seq: input.seq,\n                    },\n                });\n                reject(err);\n            });\n        }\n        internals_1.state.completions.timer.set(input.seq, {\n            resolve,\n            reject,\n        });\n        internals_1.state.pushCommand({\n            startTimer: {\n                seq: input.seq,\n                startToFireTimeout: (0, common_1.msToTs)(input.durationMs),\n            },\n        });\n    });\n}\n/**\n * Asynchronous sleep.\n *\n * Schedules a timer on the Temporal service.\n *\n * @param ms sleep duration - {@link https://www.npmjs.com/package/ms | ms} formatted string or number of milliseconds. If given a negative number, value will be set to 1.\n *\n */\nfunction sleep(ms) {\n    const seq = internals_1.state.nextSeqs.timer++;\n    const execute = (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'startTimer', timerNextHandler);\n    const durationMs = Math.max(1, (0, common_1.msToNumber)(ms));\n    return execute({\n        durationMs,\n        seq,\n    });\n}\nexports.sleep = sleep;\n/**\n * @hidden\n */\nfunction validateActivityOptions(options) {\n    if (options.scheduleToCloseTimeout === undefined && options.startToCloseTimeout === undefined) {\n        throw new TypeError('Required either scheduleToCloseTimeout or startToCloseTimeout');\n    }\n}\nexports.validateActivityOptions = validateActivityOptions;\n/**\n * Push a scheduleActivity command into state accumulator and register completion\n */\nasync function scheduleActivityNextHandler({ options, args, headers, seq, activityType, }) {\n    validateActivityOptions(options);\n    return new Promise((resolve, reject) => {\n        const scope = cancellation_scope_1.CancellationScope.current();\n        if (scope.consideredCancelled) {\n            scope.cancelRequested.catch(reject);\n            return;\n        }\n        if (scope.cancellable) {\n            scope.cancelRequested.catch(() => {\n                if (!internals_1.state.completions.activity.has(seq)) {\n                    return; // Already resolved\n                }\n                internals_1.state.pushCommand({\n                    requestCancelActivity: {\n                        seq,\n                    },\n                });\n            });\n        }\n        internals_1.state.completions.activity.set(seq, {\n            resolve,\n            reject,\n        });\n        internals_1.state.pushCommand({\n            scheduleActivity: {\n                seq,\n                activityId: options.activityId ?? `${seq}`,\n                activityType,\n                arguments: internals_1.state.dataConverter.toPayloadsSync(...args),\n                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,\n                taskQueue: options.taskQueue || internals_1.state.info?.taskQueue,\n                heartbeatTimeout: (0, common_1.msOptionalToTs)(options.heartbeatTimeout),\n                scheduleToCloseTimeout: (0, common_1.msOptionalToTs)(options.scheduleToCloseTimeout),\n                startToCloseTimeout: (0, common_1.msOptionalToTs)(options.startToCloseTimeout),\n                scheduleToStartTimeout: (0, common_1.msOptionalToTs)(options.scheduleToStartTimeout),\n                namespace: options.namespace,\n                headerFields: headers,\n                cancellationType: options.cancellationType,\n            },\n        });\n    });\n}\n/**\n * Schedule an activity and run outbound interceptors\n * @hidden\n */\nfunction scheduleActivity(activityType, args, options) {\n    if (options === undefined) {\n        throw new TypeError('Got empty activity options');\n    }\n    const seq = internals_1.state.nextSeqs.activity++;\n    const execute = (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'scheduleActivity', scheduleActivityNextHandler);\n    return execute({\n        activityType,\n        headers: {},\n        options,\n        args,\n        seq,\n    });\n}\nexports.scheduleActivity = scheduleActivity;\nasync function startChildWorkflowExecutionNextHandler({ options, headers, workflowType, seq, }) {\n    const workflowId = options.workflowId ?? uuid4();\n    const startPromise = new Promise((resolve, reject) => {\n        const scope = cancellation_scope_1.CancellationScope.current();\n        if (scope.consideredCancelled) {\n            scope.cancelRequested.catch(reject);\n            return;\n        }\n        if (scope.cancellable) {\n            scope.cancelRequested.catch(() => {\n                const complete = !internals_1.state.completions.childWorkflowComplete.has(seq);\n                const started = !internals_1.state.completions.childWorkflowStart.has(seq);\n                if (started && !complete) {\n                    const cancelSeq = internals_1.state.nextSeqs.cancelWorkflow++;\n                    internals_1.state.pushCommand({\n                        requestCancelExternalWorkflowExecution: {\n                            seq: cancelSeq,\n                            childWorkflowId: workflowId,\n                        },\n                    });\n                    // Not interested in this completion\n                    internals_1.state.completions.cancelWorkflow.set(cancelSeq, { resolve: () => undefined, reject: () => undefined });\n                }\n                else if (!started) {\n                    internals_1.state.pushCommand({\n                        cancelUnstartedChildWorkflowExecution: { childWorkflowSeq: seq },\n                    });\n                }\n                // Nothing to cancel otherwise\n            });\n        }\n        internals_1.state.completions.childWorkflowStart.set(seq, {\n            resolve,\n            reject,\n        });\n        internals_1.state.pushCommand({\n            startChildWorkflowExecution: {\n                seq,\n                workflowId,\n                workflowType,\n                input: internals_1.state.dataConverter.toPayloadsSync(...options.args),\n                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,\n                taskQueue: options.taskQueue || internals_1.state.info?.taskQueue,\n                workflowExecutionTimeout: (0, common_1.msOptionalToTs)(options.workflowExecutionTimeout),\n                workflowRunTimeout: (0, common_1.msOptionalToTs)(options.workflowRunTimeout),\n                workflowTaskTimeout: (0, common_1.msOptionalToTs)(options.workflowTaskTimeout),\n                namespace: workflowInfo().namespace,\n                header: headers,\n                cancellationType: options.cancellationType,\n                workflowIdReusePolicy: options.workflowIdReusePolicy,\n                parentClosePolicy: options.parentClosePolicy,\n                cronSchedule: options.cronSchedule,\n                searchAttributes: options.searchAttributes\n                    ? (0, common_1.mapToPayloadsSync)(internals_1.state.dataConverter, options.searchAttributes)\n                    : undefined,\n                memo: options.memo && (0, common_1.mapToPayloadsSync)(internals_1.state.dataConverter, options.memo),\n            },\n        });\n    });\n    // We construct a Promise for the completion of the child Workflow before we know\n    // if the Workflow code will await it to capture the result in case it does.\n    const completePromise = new Promise((resolve, reject) => {\n        // Chain start Promise rejection to the complete Promise.\n        startPromise.catch(reject);\n        internals_1.state.completions.childWorkflowComplete.set(seq, {\n            resolve,\n            reject,\n        });\n    });\n    // Prevent unhandled rejection because the completion might not be awaited\n    completePromise.catch(() => undefined);\n    return [startPromise, completePromise];\n}\nfunction signalWorkflowNextHandler({ seq, signalName, args, target }) {\n    return new Promise((resolve, reject) => {\n        if (internals_1.state.info === undefined) {\n            throw new common_1.IllegalStateError('Workflow uninitialized');\n        }\n        const scope = cancellation_scope_1.CancellationScope.current();\n        if (scope.consideredCancelled) {\n            scope.cancelRequested.catch(reject);\n            return;\n        }\n        if (scope.cancellable) {\n            scope.cancelRequested.catch(() => {\n                if (!internals_1.state.completions.signalWorkflow.has(seq)) {\n                    return;\n                }\n                internals_1.state.pushCommand({ cancelSignalWorkflow: { seq } });\n            });\n        }\n        internals_1.state.pushCommand({\n            signalExternalWorkflowExecution: {\n                seq,\n                args: internals_1.state.dataConverter.toPayloadsSync(...args),\n                signalName,\n                ...(target.type === 'external'\n                    ? {\n                        workflowExecution: {\n                            namespace: internals_1.state.info.namespace,\n                            ...target.workflowExecution,\n                        },\n                    }\n                    : {\n                        childWorkflowId: target.childWorkflowId,\n                    }),\n            },\n        });\n        internals_1.state.completions.signalWorkflow.set(seq, { resolve, reject });\n    });\n}\n/**\n * Configure Activity functions with given {@link ActivityOptions}.\n *\n * This method may be called multiple times to setup Activities with different options.\n *\n * @return a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n *         for which each attribute is a callable Activity function\n *\n * @typeparam A An {@link ActivityInterface} - mapping of name to function\n *\n * @example\n * ```ts\n * import { proxyActivities, ActivityInterface } from '@temporalio/workflow';\n * import * as activities from '../activities';\n *\n * // Setup Activities from module exports\n * const { httpGet, otherActivity } = proxyActivities<typeof activities>({\n *   startToCloseTimeout: '30 minutes',\n * });\n *\n * // Setup Activities from an explicit interface (e.g. when defined by another SDK)\n * interface JavaActivities extends ActivityInterface {\n *   httpGetFromJava(url: string): Promise<string>\n *   someOtherJavaActivity(arg1: number, arg2: string): Promise<string>;\n * }\n *\n * const {\n *   httpGetFromJava,\n *   someOtherJavaActivity\n * } = proxyActivities<JavaActivities>({\n *   taskQueue: 'java-worker-taskQueue',\n *   startToCloseTimeout: '5m',\n * });\n *\n * export function execute(): Promise<void> {\n *   const response = await httpGet('http://example.com');\n *   // ...\n * }\n * ```\n */\nfunction proxyActivities(options) {\n    if (options === undefined) {\n        throw new TypeError('options must be defined');\n    }\n    // Validate as early as possible for immediate user feedback\n    validateActivityOptions(options);\n    return new Proxy({}, {\n        get(_, activityType) {\n            if (typeof activityType !== 'string') {\n                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);\n            }\n            return (...args) => {\n                return scheduleActivity(activityType, args, options);\n            };\n        },\n    });\n}\nexports.proxyActivities = proxyActivities;\n/**\n * Returns a client-side handle that can be used to signal and cancel an existing Workflow execution.\n * It takes a Workflow ID and optional run ID.\n */\nfunction getExternalWorkflowHandle(workflowId, runId) {\n    return {\n        workflowId,\n        runId,\n        cancel() {\n            return new Promise((resolve, reject) => {\n                if (internals_1.state.info === undefined) {\n                    throw new common_1.IllegalStateError('Uninitialized workflow');\n                }\n                const seq = internals_1.state.nextSeqs.cancelWorkflow++;\n                internals_1.state.pushCommand({\n                    requestCancelExternalWorkflowExecution: {\n                        seq,\n                        workflowExecution: {\n                            namespace: internals_1.state.info.namespace,\n                            workflowId,\n                            runId,\n                        },\n                    },\n                });\n                internals_1.state.completions.cancelWorkflow.set(seq, { resolve, reject });\n            });\n        },\n        async signal(def, ...args) {\n            return (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({\n                seq: internals_1.state.nextSeqs.signalWorkflow++,\n                signalName: typeof def === 'string' ? def : def.name,\n                args,\n                target: {\n                    type: 'external',\n                    workflowExecution: { workflowId, runId },\n                },\n            });\n        },\n    };\n}\nexports.getExternalWorkflowHandle = getExternalWorkflowHandle;\nasync function startChild(workflowTypeOrFunc, options) {\n    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});\n    const workflowType = typeof workflowTypeOrFunc === 'string' ? workflowTypeOrFunc : workflowTypeOrFunc.name;\n    const execute = (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);\n    const [started, completed] = await execute({\n        seq: internals_1.state.nextSeqs.childWorkflow++,\n        options: optionsWithDefaults,\n        headers: {},\n        workflowType,\n    });\n    const originalRunId = await started;\n    return {\n        workflowId: optionsWithDefaults.workflowId,\n        originalRunId,\n        result() {\n            if (completed === undefined) {\n                throw new common_1.IllegalStateError('Child Workflow was not started');\n            }\n            return completed;\n        },\n        async signal(def, ...args) {\n            if (started === undefined) {\n                throw new common_1.IllegalStateError('Workflow execution not started');\n            }\n            return (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({\n                seq: internals_1.state.nextSeqs.signalWorkflow++,\n                signalName: typeof def === 'string' ? def : def.name,\n                args,\n                target: {\n                    type: 'child',\n                    childWorkflowId: optionsWithDefaults.workflowId,\n                },\n            });\n        },\n    };\n}\nexports.startChild = startChild;\nasync function executeChild(workflowTypeOrFunc, options) {\n    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});\n    const workflowType = typeof workflowTypeOrFunc === 'string' ? workflowTypeOrFunc : workflowTypeOrFunc.name;\n    const execute = (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);\n    const [_started, completed] = await execute({\n        seq: internals_1.state.nextSeqs.childWorkflow++,\n        options: optionsWithDefaults,\n        headers: {},\n        workflowType,\n    });\n    return (await completed);\n}\nexports.executeChild = executeChild;\n/**\n * Get information about the current Workflow\n */\nfunction workflowInfo() {\n    if (internals_1.state.info === undefined) {\n        throw new common_1.IllegalStateError('Workflow uninitialized');\n    }\n    return internals_1.state.info;\n}\nexports.workflowInfo = workflowInfo;\n/**\n * Get a reference to Sinks for exporting data out of the Workflow.\n *\n * These Sinks **must** be registered with the Worker in order for this\n * mechanism to work.\n *\n * @example\n * ```ts\n * import { proxySinks, Sinks } from '@temporalio/workflow';\n *\n * interface MySinks extends Sinks {\n *   logger: {\n *     info(message: string): void;\n *     error(message: string): void;\n *   };\n * }\n *\n * const { logger } = proxySinks<MyDependencies>();\n * logger.info('setting up');\n *\n * export function myWorkflow() {\n *   return {\n *     async execute() {\n *       logger.info('hey ho');\n *       logger.error('lets go');\n *     }\n *   };\n * }\n * ```\n */\nfunction proxySinks() {\n    return new Proxy({}, {\n        get(_, ifaceName) {\n            return new Proxy({}, {\n                get(_, fnName) {\n                    return (...args) => {\n                        internals_1.state.sinkCalls.push({\n                            ifaceName: ifaceName,\n                            fnName: fnName,\n                            args,\n                        });\n                    };\n                },\n            });\n        },\n    });\n}\nexports.proxySinks = proxySinks;\n/**\n * Returns a function `f` that will cause the current Workflow to ContinueAsNew when called.\n *\n * `f` takes the same arguments as the Workflow execute function supplied to typeparam `F`.\n *\n * Once `f` is called, Workflow execution immediately completes.\n */\nfunction makeContinueAsNewFunc(options) {\n    const info = workflowInfo();\n    const { workflowType, taskQueue, ...rest } = options ?? {};\n    const requiredOptions = {\n        workflowType: workflowType ?? info.workflowType,\n        taskQueue: taskQueue ?? info.taskQueue,\n        ...rest,\n    };\n    return (...args) => {\n        const fn = (0, common_1.composeInterceptors)(internals_1.state.interceptors.outbound, 'continueAsNew', async (input) => {\n            const { headers, args, options } = input;\n            throw new interfaces_1.ContinueAsNew({\n                workflowType: options.workflowType,\n                arguments: await internals_1.state.dataConverter.toPayloads(...args),\n                header: headers,\n                taskQueue: options.taskQueue,\n                memo: options.memo,\n                searchAttributes: options.searchAttributes,\n                workflowRunTimeout: (0, common_1.msOptionalToTs)(options.workflowRunTimeout),\n                workflowTaskTimeout: (0, common_1.msOptionalToTs)(options.workflowTaskTimeout),\n            });\n        });\n        return fn({\n            args,\n            headers: {},\n            options: requiredOptions,\n        });\n    };\n}\nexports.makeContinueAsNewFunc = makeContinueAsNewFunc;\n/**\n * Continues current Workflow execution as new with default options.\n *\n * Shorthand for `makeContinueAsNewFunc<F>()(...args)`.\n *\n * @example\n *\n * ```ts\n * import { continueAsNew } from '@temporalio/workflow';\n *\n * export function myWorkflow(n: number) {\n *   return {\n *     async execute() {\n *       // ... Workflow logic\n *       await continueAsNew<typeof myWorkflow>(n + 1);\n *     }\n *   };\n * }\n * ```\n */\nfunction continueAsNew(...args) {\n    return makeContinueAsNewFunc()(...args);\n}\nexports.continueAsNew = continueAsNew;\n/**\n * Generate an RFC compliant V4 uuid.\n * Uses the workflow's deterministic PRNG making it safe for use within a workflow.\n * This function is cryptographically insecure.\n * See the {@link https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid | stackoverflow discussion}.\n */\nfunction uuid4() {\n    // Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`\n    const ho = (n, p) => n.toString(16).padStart(p, '0');\n    // Create a view backed by a 16-byte buffer\n    const view = new DataView(new ArrayBuffer(16));\n    // Fill buffer with random values\n    view.setUint32(0, (Math.random() * 0x100000000) >>> 0);\n    view.setUint32(4, (Math.random() * 0x100000000) >>> 0);\n    view.setUint32(8, (Math.random() * 0x100000000) >>> 0);\n    view.setUint32(12, (Math.random() * 0x100000000) >>> 0);\n    // Patch the 6th byte to reflect a version 4 UUID\n    view.setUint8(6, (view.getUint8(6) & 0xf) | 0x40);\n    // Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)\n    view.setUint8(8, (view.getUint8(8) & 0x3f) | 0x80);\n    // Compile the canonical textual form from the array data\n    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`;\n}\nexports.uuid4 = uuid4;\n/**\n * Patch or upgrade workflow code by checking or stating that this workflow has a certain patch.\n *\n * See [docs page](https://docs.temporal.io/docs/typescript/versioning) for info.\n *\n * If the workflow is replaying an existing history, then this function returns true if that\n * history was produced by a worker which also had a `patched` call with the same `patchId`.\n * If the history was produced by a worker *without* such a call, then it will return false.\n *\n * If the workflow is not currently replaying, then this call *always* returns true.\n *\n * Your workflow code should run the \"new\" code if this returns true, if it returns false, you\n * should run the \"old\" code. By doing this, you can maintain determinism.\n *\n * @param patchId An identifier that should be unique to this patch. It is OK to use multiple\n * calls with the same ID, which means all such calls will always return the same value.\n */\nfunction patched(patchId) {\n    return patchInternal(patchId, false);\n}\nexports.patched = patched;\n/**\n * Indicate that a patch is being phased out.\n *\n * See [docs page](https://docs.temporal.io/docs/typescript/versioning) for info.\n *\n * Workflows with this call may be deployed alongside workflows with a {@link patched} call, but\n * they must *not* be deployed while any workers still exist running old code without a\n * {@link patched} call, or any runs with histories produced by such workers exist. If either kind\n * of worker encounters a history produced by the other, their behavior is undefined.\n *\n * Once all live workflow runs have been produced by workers with this call, you can deploy workers\n * which are free of either kind of patch call for this ID. Workers with and without this call\n * may coexist, as long as they are both running the \"new\" code.\n *\n * @param patchId An identifier that should be unique to this patch. It is OK to use multiple\n * calls with the same ID, which means all such calls will always return the same value.\n */\nfunction deprecatePatch(patchId) {\n    patchInternal(patchId, true);\n}\nexports.deprecatePatch = deprecatePatch;\nfunction patchInternal(patchId, deprecated) {\n    // Patch operation does not support interception at the moment, if it did,\n    // this would be the place to start the interception chain\n    const { isReplaying } = workflowInfo();\n    if (internals_1.state.workflow === undefined) {\n        throw new common_1.IllegalStateError('Patches cannot be used before Workflow starts');\n    }\n    const usePatch = !isReplaying || internals_1.state.knownPresentPatches.has(patchId);\n    // Avoid sending commands for patches core already knows about.\n    // This optimization enables development of automatic patching tools.\n    if (usePatch && !internals_1.state.sentPatches.has(patchId)) {\n        internals_1.state.pushCommand({\n            setPatchMarker: { patchId, deprecated },\n        });\n        internals_1.state.sentPatches.add(patchId);\n    }\n    return usePatch;\n}\nasync function condition(fn, timeout) {\n    if (timeout) {\n        return await cancellation_scope_1.CancellationScope.cancellable(async () => {\n            try {\n                return await Promise.race([sleep(timeout).then(() => false), conditionInner(fn).then(() => true)]);\n            }\n            finally {\n                cancellation_scope_1.CancellationScope.current().cancel();\n            }\n        });\n    }\n    return conditionInner(fn);\n}\nexports.condition = condition;\nfunction conditionInner(fn) {\n    return new Promise((resolve, reject) => {\n        const scope = cancellation_scope_1.CancellationScope.current();\n        if (scope.consideredCancelled) {\n            scope.cancelRequested.catch(reject);\n            return;\n        }\n        const seq = internals_1.state.nextSeqs.condition++;\n        if (scope.cancellable) {\n            scope.cancelRequested.catch((err) => {\n                internals_1.state.blockedConditions.delete(seq);\n                reject(err);\n            });\n        }\n        // Eager evaluation\n        if (fn()) {\n            resolve();\n            return;\n        }\n        internals_1.state.blockedConditions.set(seq, { fn, resolve });\n    });\n}\n/**\n * Define a signal method for a Workflow.\n *\n * Definitions are used to register handler in the Workflow via {@link setHandler} and to signal Workflows using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.\n * Definitions can be reused in multiple Workflows.\n */\nfunction defineSignal(name) {\n    return {\n        type: 'signal',\n        name,\n    };\n}\nexports.defineSignal = defineSignal;\n/**\n * Define a query method for a Workflow.\n *\n * Definitions are used to register handler in the Workflow via {@link setHandler} and to query Workflows using a {@link WorkflowHandle}.\n * Definitions can be reused in multiple Workflows.\n */\nfunction defineQuery(name) {\n    return {\n        type: 'query',\n        name,\n    };\n}\nexports.defineQuery = defineQuery;\n/**\n * Set a handler function for a Workflow query or signal.\n *\n * If this function is called multiple times for a given signal or query name the last handler will overwrite any previous calls.\n *\n * @param def a {@link SignalDefinition} or {@link QueryDefinition} as returned by {@link defineSignal} or {@link defineQuery} respectively.\n * @param handler  a compatible handler function for the given definition.\n */\nfunction setHandler(def, handler) {\n    if (def.type === 'signal') {\n        internals_1.state.signalHandlers.set(def.name, handler);\n        const bufferedSignals = internals_1.state.bufferedSignals.get(def.name);\n        if (bufferedSignals !== undefined) {\n            for (const signal of bufferedSignals) {\n                internals_1.state.activator.signalWorkflow(signal);\n            }\n            internals_1.state.bufferedSignals.delete(def.name);\n        }\n    }\n    else if (def.type === 'query') {\n        internals_1.state.queryHandlers.set(def.name, handler);\n    }\n    else {\n        throw new TypeError(`Invalid definition type: ${def.type}`);\n    }\n}\nexports.setHandler = setHandler;\n//# sourceMappingURL=workflow.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL3dvcmtmbG93LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcscUJBQXFCLEdBQUcsNkJBQTZCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsYUFBYSxHQUFHLGlDQUFpQztBQUM3YyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsMkVBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMseUVBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsMkZBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRDQUE0QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEIsd0RBQXdELHNDQUFzQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGtGQUFrRixtREFBbUQ7QUFDckk7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQkFBK0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3QkFBd0IsT0FBTztBQUMvRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiLFNBQVM7QUFDVCxnRUFBZ0UsaUJBQWlCO0FBQ2pGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJGQUEyRixxQkFBcUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHdFQUF3RSxpQkFBaUI7QUFDekYsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNHQUFzRztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEVBQUUsMEJBQTBCO0FBQ3BMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQixpQ0FBaUMscUJBQXFCLEdBQUcsMkJBQTJCLElBQUksNkJBQTZCO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQixnQ0FBZ0MscUJBQXFCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0IsSUFBSSx1QkFBdUIsZ0JBQWdCLG9CQUFvQixJQUFJLG1CQUFtQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9saWIvd29ya2Zsb3cuanM/ZDQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0SGFuZGxlciA9IGV4cG9ydHMuZGVmaW5lUXVlcnkgPSBleHBvcnRzLmRlZmluZVNpZ25hbCA9IGV4cG9ydHMuY29uZGl0aW9uID0gZXhwb3J0cy5kZXByZWNhdGVQYXRjaCA9IGV4cG9ydHMucGF0Y2hlZCA9IGV4cG9ydHMudXVpZDQgPSBleHBvcnRzLmNvbnRpbnVlQXNOZXcgPSBleHBvcnRzLm1ha2VDb250aW51ZUFzTmV3RnVuYyA9IGV4cG9ydHMucHJveHlTaW5rcyA9IGV4cG9ydHMud29ya2Zsb3dJbmZvID0gZXhwb3J0cy5leGVjdXRlQ2hpbGQgPSBleHBvcnRzLnN0YXJ0Q2hpbGQgPSBleHBvcnRzLmdldEV4dGVybmFsV29ya2Zsb3dIYW5kbGUgPSBleHBvcnRzLnByb3h5QWN0aXZpdGllcyA9IGV4cG9ydHMuc2NoZWR1bGVBY3Rpdml0eSA9IGV4cG9ydHMudmFsaWRhdGVBY3Rpdml0eU9wdGlvbnMgPSBleHBvcnRzLnNsZWVwID0gZXhwb3J0cy5hZGREZWZhdWx0V29ya2Zsb3dPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiQHRlbXBvcmFsaW8vY29tbW9uXCIpO1xuY29uc3QgaW50ZXJmYWNlc18xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlc1wiKTtcbmNvbnN0IGludGVybmFsc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzXCIpO1xuY29uc3QgY2FuY2VsbGF0aW9uX3Njb3BlXzEgPSByZXF1aXJlKFwiLi9jYW5jZWxsYXRpb24tc2NvcGVcIik7XG4vLyBBdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbigwLCBjYW5jZWxsYXRpb25fc2NvcGVfMS5yZWdpc3RlclNsZWVwSW1wbGVtZW50YXRpb24pKHNsZWVwKTtcbi8qKlxuICogQWRkcyBkZWZhdWx0IHZhbHVlcyB0byBgd29ya2Zsb3dJZGAgYW5kIGB3b3JrZmxvd0lkUmV1c2VQb2xpY3lgIHRvIGdpdmVuIHdvcmtmbG93IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFkZERlZmF1bHRXb3JrZmxvd09wdGlvbnMob3B0cykge1xuICAgIGNvbnN0IHsgYXJncywgd29ya2Zsb3dJZCwgLi4ucmVzdCB9ID0gb3B0cztcbiAgICByZXR1cm4ge1xuICAgICAgICB3b3JrZmxvd0lkOiB3b3JrZmxvd0lkID8/IHV1aWQ0KCksXG4gICAgICAgIGFyZ3M6IGFyZ3MgPz8gW10sXG4gICAgICAgIGNhbmNlbGxhdGlvblR5cGU6IGludGVyZmFjZXNfMS5DaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZS5XQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUQsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9ucyA9IGFkZERlZmF1bHRXb3JrZmxvd09wdGlvbnM7XG4vKipcbiAqIFB1c2ggYSBzdGFydFRpbWVyIGNvbW1hbmQgaW50byBzdGF0ZSBhY2N1bXVsYXRvciBhbmQgcmVnaXN0ZXIgY29tcGxldGlvblxuICovXG5mdW5jdGlvbiB0aW1lck5leHRIYW5kbGVyKGlucHV0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBjYW5jZWxsYXRpb25fc2NvcGVfMS5DYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaW5wdXQuc2VxKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxUaW1lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxOiBpbnB1dC5zZXEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy50aW1lci5zZXQoaW5wdXQuc2VxLCB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgc3RhcnRUaW1lcjoge1xuICAgICAgICAgICAgICAgIHNlcTogaW5wdXQuc2VxLFxuICAgICAgICAgICAgICAgIHN0YXJ0VG9GaXJlVGltZW91dDogKDAsIGNvbW1vbl8xLm1zVG9UcykoaW5wdXQuZHVyYXRpb25NcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzIHNsZWVwLlxuICpcbiAqIFNjaGVkdWxlcyBhIHRpbWVyIG9uIHRoZSBUZW1wb3JhbCBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSBtcyBzbGVlcCBkdXJhdGlvbiAtIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zfSBmb3JtYXR0ZWQgc3RyaW5nIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMuIElmIGdpdmVuIGEgbmVnYXRpdmUgbnVtYmVyLCB2YWx1ZSB3aWxsIGJlIHNldCB0byAxLlxuICpcbiAqL1xuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICBjb25zdCBzZXEgPSBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy50aW1lcisrO1xuICAgIGNvbnN0IGV4ZWN1dGUgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLm91dGJvdW5kLCAnc3RhcnRUaW1lcicsIHRpbWVyTmV4dEhhbmRsZXIpO1xuICAgIGNvbnN0IGR1cmF0aW9uTXMgPSBNYXRoLm1heCgxLCAoMCwgY29tbW9uXzEubXNUb051bWJlcikobXMpKTtcbiAgICByZXR1cm4gZXhlY3V0ZSh7XG4gICAgICAgIGR1cmF0aW9uTXMsXG4gICAgICAgIHNlcSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2xlZXAgPSBzbGVlcDtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuc2NoZWR1bGVUb0Nsb3NlVGltZW91dCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc3RhcnRUb0Nsb3NlVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVpcmVkIGVpdGhlciBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0IG9yIHN0YXJ0VG9DbG9zZVRpbWVvdXQnKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQWN0aXZpdHlPcHRpb25zID0gdmFsaWRhdGVBY3Rpdml0eU9wdGlvbnM7XG4vKipcbiAqIFB1c2ggYSBzY2hlZHVsZUFjdGl2aXR5IGNvbW1hbmQgaW50byBzdGF0ZSBhY2N1bXVsYXRvciBhbmQgcmVnaXN0ZXIgY29tcGxldGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzY2hlZHVsZUFjdGl2aXR5TmV4dEhhbmRsZXIoeyBvcHRpb25zLCBhcmdzLCBoZWFkZXJzLCBzZXEsIGFjdGl2aXR5VHlwZSwgfSkge1xuICAgIHZhbGlkYXRlQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gY2FuY2VsbGF0aW9uX3Njb3BlXzEuQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuYWN0aXZpdHkuaGFzKHNlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENhbmNlbEFjdGl2aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy5hY3Rpdml0eS5zZXQoc2VxLCB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgc2NoZWR1bGVBY3Rpdml0eToge1xuICAgICAgICAgICAgICAgIHNlcSxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eUlkOiBvcHRpb25zLmFjdGl2aXR5SWQgPz8gYCR7c2VxfWAsXG4gICAgICAgICAgICAgICAgYWN0aXZpdHlUeXBlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogaW50ZXJuYWxzXzEuc3RhdGUuZGF0YUNvbnZlcnRlci50b1BheWxvYWRzU3luYyguLi5hcmdzKSxcbiAgICAgICAgICAgICAgICByZXRyeVBvbGljeTogb3B0aW9ucy5yZXRyeSA/ICgwLCBjb21tb25fMS5jb21waWxlUmV0cnlQb2xpY3kpKG9wdGlvbnMucmV0cnkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUgfHwgaW50ZXJuYWxzXzEuc3RhdGUuaW5mbz8udGFza1F1ZXVlLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0KSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0OiAoMCwgY29tbW9uXzEubXNPcHRpb25hbFRvVHMpKG9wdGlvbnMuc2NoZWR1bGVUb0Nsb3NlVGltZW91dCksXG4gICAgICAgICAgICAgICAgc3RhcnRUb0Nsb3NlVGltZW91dDogKDAsIGNvbW1vbl8xLm1zT3B0aW9uYWxUb1RzKShvcHRpb25zLnN0YXJ0VG9DbG9zZVRpbWVvdXQpLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVG9TdGFydFRpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy5zY2hlZHVsZVRvU3RhcnRUaW1lb3V0KSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG9wdGlvbnMubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25UeXBlOiBvcHRpb25zLmNhbmNlbGxhdGlvblR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogU2NoZWR1bGUgYW4gYWN0aXZpdHkgYW5kIHJ1biBvdXRib3VuZCBpbnRlcmNlcHRvcnNcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc2NoZWR1bGVBY3Rpdml0eShhY3Rpdml0eVR5cGUsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBlbXB0eSBhY3Rpdml0eSBvcHRpb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlcSA9IGludGVybmFsc18xLnN0YXRlLm5leHRTZXFzLmFjdGl2aXR5Kys7XG4gICAgY29uc3QgZXhlY3V0ZSA9ICgwLCBjb21tb25fMS5jb21wb3NlSW50ZXJjZXB0b3JzKShpbnRlcm5hbHNfMS5zdGF0ZS5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdzY2hlZHVsZUFjdGl2aXR5Jywgc2NoZWR1bGVBY3Rpdml0eU5leHRIYW5kbGVyKTtcbiAgICByZXR1cm4gZXhlY3V0ZSh7XG4gICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHNlcSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2NoZWR1bGVBY3Rpdml0eSA9IHNjaGVkdWxlQWN0aXZpdHk7XG5hc3luYyBmdW5jdGlvbiBzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25OZXh0SGFuZGxlcih7IG9wdGlvbnMsIGhlYWRlcnMsIHdvcmtmbG93VHlwZSwgc2VxLCB9KSB7XG4gICAgY29uc3Qgd29ya2Zsb3dJZCA9IG9wdGlvbnMud29ya2Zsb3dJZCA/PyB1dWlkNCgpO1xuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBjYW5jZWxsYXRpb25fc2NvcGVfMS5DYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGUgPSAhaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd0NvbXBsZXRlLmhhcyhzZXEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSAhaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd1N0YXJ0LmhhcyhzZXEpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkICYmICFjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxTZXEgPSBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy5jYW5jZWxXb3JrZmxvdysrO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcTogY2FuY2VsU2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkV29ya2Zsb3dJZDogd29ya2Zsb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW50ZXJlc3RlZCBpbiB0aGlzIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuY2FuY2VsV29ya2Zsb3cuc2V0KGNhbmNlbFNlcSwgeyByZXNvbHZlOiAoKSA9PiB1bmRlZmluZWQsIHJlamVjdDogKCkgPT4gdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxVbnN0YXJ0ZWRDaGlsZFdvcmtmbG93RXhlY3V0aW9uOiB7IGNoaWxkV29ya2Zsb3dTZXE6IHNlcSB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBjYW5jZWwgb3RoZXJ3aXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5jb21wbGV0aW9ucy5jaGlsZFdvcmtmbG93U3RhcnQuc2V0KHNlcSwge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsc18xLnN0YXRlLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIHNlcSxcbiAgICAgICAgICAgICAgICB3b3JrZmxvd0lkLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93VHlwZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogaW50ZXJuYWxzXzEuc3RhdGUuZGF0YUNvbnZlcnRlci50b1BheWxvYWRzU3luYyguLi5vcHRpb25zLmFyZ3MpLFxuICAgICAgICAgICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zLnJldHJ5ID8gKDAsIGNvbW1vbl8xLmNvbXBpbGVSZXRyeVBvbGljeSkob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGFza1F1ZXVlOiBvcHRpb25zLnRhc2tRdWV1ZSB8fCBpbnRlcm5hbHNfMS5zdGF0ZS5pbmZvPy50YXNrUXVldWUsXG4gICAgICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0OiAoMCwgY29tbW9uXzEubXNPcHRpb25hbFRvVHMpKG9wdGlvbnMud29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0KSxcbiAgICAgICAgICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy53b3JrZmxvd1J1blRpbWVvdXQpLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93VGFza1RpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHdvcmtmbG93SW5mbygpLm5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVHlwZTogb3B0aW9ucy5jYW5jZWxsYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93SWRSZXVzZVBvbGljeTogb3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3ksXG4gICAgICAgICAgICAgICAgcGFyZW50Q2xvc2VQb2xpY3k6IG9wdGlvbnMucGFyZW50Q2xvc2VQb2xpY3ksXG4gICAgICAgICAgICAgICAgY3JvblNjaGVkdWxlOiBvcHRpb25zLmNyb25TY2hlZHVsZSxcbiAgICAgICAgICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29tbW9uXzEubWFwVG9QYXlsb2Fkc1N5bmMpKGludGVybmFsc18xLnN0YXRlLmRhdGFDb252ZXJ0ZXIsIG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWVtbzogb3B0aW9ucy5tZW1vICYmICgwLCBjb21tb25fMS5tYXBUb1BheWxvYWRzU3luYykoaW50ZXJuYWxzXzEuc3RhdGUuZGF0YUNvbnZlcnRlciwgb3B0aW9ucy5tZW1vKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFdlIGNvbnN0cnVjdCBhIFByb21pc2UgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBjaGlsZCBXb3JrZmxvdyBiZWZvcmUgd2Uga25vd1xuICAgIC8vIGlmIHRoZSBXb3JrZmxvdyBjb2RlIHdpbGwgYXdhaXQgaXQgdG8gY2FwdHVyZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgZG9lcy5cbiAgICBjb25zdCBjb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIENoYWluIHN0YXJ0IFByb21pc2UgcmVqZWN0aW9uIHRvIHRoZSBjb21wbGV0ZSBQcm9taXNlLlxuICAgICAgICBzdGFydFByb21pc2UuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd0NvbXBsZXRlLnNldChzZXEsIHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3QsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvbiBiZWNhdXNlIHRoZSBjb21wbGV0aW9uIG1pZ2h0IG5vdCBiZSBhd2FpdGVkXG4gICAgY29tcGxldGVQcm9taXNlLmNhdGNoKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIFtzdGFydFByb21pc2UsIGNvbXBsZXRlUHJvbWlzZV07XG59XG5mdW5jdGlvbiBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyKHsgc2VxLCBzaWduYWxOYW1lLCBhcmdzLCB0YXJnZXQgfSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbHNfMS5zdGF0ZS5pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjb3BlID0gY2FuY2VsbGF0aW9uX3Njb3BlXzEuQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzXzEuc3RhdGUuY29tcGxldGlvbnMuc2lnbmFsV29ya2Zsb3cuaGFzKHNlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5wdXNoQ29tbWFuZCh7IGNhbmNlbFNpZ25hbFdvcmtmbG93OiB7IHNlcSB9IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgc2lnbmFsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIHNlcSxcbiAgICAgICAgICAgICAgICBhcmdzOiBpbnRlcm5hbHNfMS5zdGF0ZS5kYXRhQ29udmVydGVyLnRvUGF5bG9hZHNTeW5jKC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIHNpZ25hbE5hbWUsXG4gICAgICAgICAgICAgICAgLi4uKHRhcmdldC50eXBlID09PSAnZXh0ZXJuYWwnXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGludGVybmFsc18xLnN0YXRlLmluZm8ubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldC53b3JrZmxvd0V4ZWN1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFdvcmtmbG93SWQ6IHRhcmdldC5jaGlsZFdvcmtmbG93SWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsc18xLnN0YXRlLmNvbXBsZXRpb25zLnNpZ25hbFdvcmtmbG93LnNldChzZXEsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb25maWd1cmUgQWN0aXZpdHkgZnVuY3Rpb25zIHdpdGggZ2l2ZW4ge0BsaW5rIEFjdGl2aXR5T3B0aW9uc30uXG4gKlxuICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBzZXR1cCBBY3Rpdml0aWVzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIFtQcm94eV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkpXG4gKiAgICAgICAgIGZvciB3aGljaCBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNhbGxhYmxlIEFjdGl2aXR5IGZ1bmN0aW9uXG4gKlxuICogQHR5cGVwYXJhbSBBIEFuIHtAbGluayBBY3Rpdml0eUludGVyZmFjZX0gLSBtYXBwaW5nIG9mIG5hbWUgdG8gZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHByb3h5QWN0aXZpdGllcywgQWN0aXZpdHlJbnRlcmZhY2UgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKiBpbXBvcnQgKiBhcyBhY3Rpdml0aWVzIGZyb20gJy4uL2FjdGl2aXRpZXMnO1xuICpcbiAqIC8vIFNldHVwIEFjdGl2aXRpZXMgZnJvbSBtb2R1bGUgZXhwb3J0c1xuICogY29uc3QgeyBodHRwR2V0LCBvdGhlckFjdGl2aXR5IH0gPSBwcm94eUFjdGl2aXRpZXM8dHlwZW9mIGFjdGl2aXRpZXM+KHtcbiAqICAgc3RhcnRUb0Nsb3NlVGltZW91dDogJzMwIG1pbnV0ZXMnLFxuICogfSk7XG4gKlxuICogLy8gU2V0dXAgQWN0aXZpdGllcyBmcm9tIGFuIGV4cGxpY2l0IGludGVyZmFjZSAoZS5nLiB3aGVuIGRlZmluZWQgYnkgYW5vdGhlciBTREspXG4gKiBpbnRlcmZhY2UgSmF2YUFjdGl2aXRpZXMgZXh0ZW5kcyBBY3Rpdml0eUludGVyZmFjZSB7XG4gKiAgIGh0dHBHZXRGcm9tSmF2YSh1cmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPlxuICogICBzb21lT3RoZXJKYXZhQWN0aXZpdHkoYXJnMTogbnVtYmVyLCBhcmcyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG4gKiB9XG4gKlxuICogY29uc3Qge1xuICogICBodHRwR2V0RnJvbUphdmEsXG4gKiAgIHNvbWVPdGhlckphdmFBY3Rpdml0eVxuICogfSA9IHByb3h5QWN0aXZpdGllczxKYXZhQWN0aXZpdGllcz4oe1xuICogICB0YXNrUXVldWU6ICdqYXZhLXdvcmtlci10YXNrUXVldWUnLFxuICogICBzdGFydFRvQ2xvc2VUaW1lb3V0OiAnNW0nLFxuICogfSk7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cEdldCgnaHR0cDovL2V4YW1wbGUuY29tJyk7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHByb3h5QWN0aXZpdGllcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgaW1tZWRpYXRlIHVzZXIgZmVlZGJhY2tcbiAgICB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGdldChfLCBhY3Rpdml0eVR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBBY3Rpdml0eSB0eXBlcywgZ290OiAke1N0cmluZyhhY3Rpdml0eVR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aXZpdHkoYWN0aXZpdHlUeXBlLCBhcmdzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnByb3h5QWN0aXZpdGllcyA9IHByb3h5QWN0aXZpdGllcztcbi8qKlxuICogUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHNpZ25hbCBhbmQgY2FuY2VsIGFuIGV4aXN0aW5nIFdvcmtmbG93IGV4ZWN1dGlvbi5cbiAqIEl0IHRha2VzIGEgV29ya2Zsb3cgSUQgYW5kIG9wdGlvbmFsIHJ1biBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSh3b3JrZmxvd0lkLCBydW5JZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgIHJ1bklkLFxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHNfMS5zdGF0ZS5pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl8xLklsbGVnYWxTdGF0ZUVycm9yKCdVbmluaXRpYWxpemVkIHdvcmtmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcSA9IGludGVybmFsc18xLnN0YXRlLm5leHRTZXFzLmNhbmNlbFdvcmtmbG93Kys7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGludGVybmFsc18xLnN0YXRlLmluZm8ubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLmNvbXBsZXRpb25zLmNhbmNlbFdvcmtmbG93LnNldChzZXEsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHNpZ25hbChkZWYsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLm91dGJvdW5kLCAnc2lnbmFsV29ya2Zsb3cnLCBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyKSh7XG4gICAgICAgICAgICAgICAgc2VxOiBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy5zaWduYWxXb3JrZmxvdysrLFxuICAgICAgICAgICAgICAgIHNpZ25hbE5hbWU6IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V4dGVybmFsJyxcbiAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IHsgd29ya2Zsb3dJZCwgcnVuSWQgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0RXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSA9IGdldEV4dGVybmFsV29ya2Zsb3dIYW5kbGU7XG5hc3luYyBmdW5jdGlvbiBzdGFydENoaWxkKHdvcmtmbG93VHlwZU9yRnVuYywgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBhZGREZWZhdWx0V29ya2Zsb3dPcHRpb25zKG9wdGlvbnMgPz8ge30pO1xuICAgIGNvbnN0IHdvcmtmbG93VHlwZSA9IHR5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmMgPT09ICdzdHJpbmcnID8gd29ya2Zsb3dUeXBlT3JGdW5jIDogd29ya2Zsb3dUeXBlT3JGdW5jLm5hbWU7XG4gICAgY29uc3QgZXhlY3V0ZSA9ICgwLCBjb21tb25fMS5jb21wb3NlSW50ZXJjZXB0b3JzKShpbnRlcm5hbHNfMS5zdGF0ZS5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb24nLCBzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25OZXh0SGFuZGxlcik7XG4gICAgY29uc3QgW3N0YXJ0ZWQsIGNvbXBsZXRlZF0gPSBhd2FpdCBleGVjdXRlKHtcbiAgICAgICAgc2VxOiBpbnRlcm5hbHNfMS5zdGF0ZS5uZXh0U2Vxcy5jaGlsZFdvcmtmbG93KyssXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRoRGVmYXVsdHMsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB3b3JrZmxvd1R5cGUsXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ2luYWxSdW5JZCA9IGF3YWl0IHN0YXJ0ZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd29ya2Zsb3dJZDogb3B0aW9uc1dpdGhEZWZhdWx0cy53b3JrZmxvd0lkLFxuICAgICAgICBvcmlnaW5hbFJ1bklkLFxuICAgICAgICByZXN1bHQoKSB7XG4gICAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuSWxsZWdhbFN0YXRlRXJyb3IoJ0NoaWxkIFdvcmtmbG93IHdhcyBub3Qgc3RhcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc2lnbmFsKGRlZiwgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgZXhlY3V0aW9uIG5vdCBzdGFydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvbW1vbl8xLmNvbXBvc2VJbnRlcmNlcHRvcnMpKGludGVybmFsc18xLnN0YXRlLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ3NpZ25hbFdvcmtmbG93Jywgc2lnbmFsV29ya2Zsb3dOZXh0SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgIHNlcTogaW50ZXJuYWxzXzEuc3RhdGUubmV4dFNlcXMuc2lnbmFsV29ya2Zsb3crKyxcbiAgICAgICAgICAgICAgICBzaWduYWxOYW1lOiB0eXBlb2YgZGVmID09PSAnc3RyaW5nJyA/IGRlZiA6IGRlZi5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGlsZCcsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkV29ya2Zsb3dJZDogb3B0aW9uc1dpdGhEZWZhdWx0cy53b3JrZmxvd0lkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5zdGFydENoaWxkID0gc3RhcnRDaGlsZDtcbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZCh3b3JrZmxvd1R5cGVPckZ1bmMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9ucyhvcHRpb25zID8/IHt9KTtcbiAgICBjb25zdCB3b3JrZmxvd1R5cGUgPSB0eXBlb2Ygd29ya2Zsb3dUeXBlT3JGdW5jID09PSAnc3RyaW5nJyA/IHdvcmtmbG93VHlwZU9yRnVuYyA6IHdvcmtmbG93VHlwZU9yRnVuYy5uYW1lO1xuICAgIGNvbnN0IGV4ZWN1dGUgPSAoMCwgY29tbW9uXzEuY29tcG9zZUludGVyY2VwdG9ycykoaW50ZXJuYWxzXzEuc3RhdGUuaW50ZXJjZXB0b3JzLm91dGJvdW5kLCAnc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uJywgc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uTmV4dEhhbmRsZXIpO1xuICAgIGNvbnN0IFtfc3RhcnRlZCwgY29tcGxldGVkXSA9IGF3YWl0IGV4ZWN1dGUoe1xuICAgICAgICBzZXE6IGludGVybmFsc18xLnN0YXRlLm5leHRTZXFzLmNoaWxkV29ya2Zsb3crKyxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1dpdGhEZWZhdWx0cyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHdvcmtmbG93VHlwZSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGF3YWl0IGNvbXBsZXRlZCk7XG59XG5leHBvcnRzLmV4ZWN1dGVDaGlsZCA9IGV4ZWN1dGVDaGlsZDtcbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IFdvcmtmbG93XG4gKi9cbmZ1bmN0aW9uIHdvcmtmbG93SW5mbygpIHtcbiAgICBpZiAoaW50ZXJuYWxzXzEuc3RhdGUuaW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZXJuYWxzXzEuc3RhdGUuaW5mbztcbn1cbmV4cG9ydHMud29ya2Zsb3dJbmZvID0gd29ya2Zsb3dJbmZvO1xuLyoqXG4gKiBHZXQgYSByZWZlcmVuY2UgdG8gU2lua3MgZm9yIGV4cG9ydGluZyBkYXRhIG91dCBvZiB0aGUgV29ya2Zsb3cuXG4gKlxuICogVGhlc2UgU2lua3MgKiptdXN0KiogYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBXb3JrZXIgaW4gb3JkZXIgZm9yIHRoaXNcbiAqIG1lY2hhbmlzbSB0byB3b3JrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcHJveHlTaW5rcywgU2lua3MgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKlxuICogaW50ZXJmYWNlIE15U2lua3MgZXh0ZW5kcyBTaW5rcyB7XG4gKiAgIGxvZ2dlcjoge1xuICogICAgIGluZm8obWVzc2FnZTogc3RyaW5nKTogdm9pZDtcbiAqICAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xuICogICB9O1xuICogfVxuICpcbiAqIGNvbnN0IHsgbG9nZ2VyIH0gPSBwcm94eVNpbmtzPE15RGVwZW5kZW5jaWVzPigpO1xuICogbG9nZ2VyLmluZm8oJ3NldHRpbmcgdXAnKTtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gbXlXb3JrZmxvdygpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBhc3luYyBleGVjdXRlKCkge1xuICogICAgICAgbG9nZ2VyLmluZm8oJ2hleSBobycpO1xuICogICAgICAgbG9nZ2VyLmVycm9yKCdsZXRzIGdvJyk7XG4gKiAgICAgfVxuICogICB9O1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHByb3h5U2lua3MoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQoXywgaWZhY2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICAgICAgZ2V0KF8sIGZuTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLnNpbmtDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZmFjZU5hbWU6IGlmYWNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5wcm94eVNpbmtzID0gcHJveHlTaW5rcztcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGBmYCB0aGF0IHdpbGwgY2F1c2UgdGhlIGN1cnJlbnQgV29ya2Zsb3cgdG8gQ29udGludWVBc05ldyB3aGVuIGNhbGxlZC5cbiAqXG4gKiBgZmAgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBXb3JrZmxvdyBleGVjdXRlIGZ1bmN0aW9uIHN1cHBsaWVkIHRvIHR5cGVwYXJhbSBgRmAuXG4gKlxuICogT25jZSBgZmAgaXMgY2FsbGVkLCBXb3JrZmxvdyBleGVjdXRpb24gaW1tZWRpYXRlbHkgY29tcGxldGVzLlxuICovXG5mdW5jdGlvbiBtYWtlQ29udGludWVBc05ld0Z1bmMob3B0aW9ucykge1xuICAgIGNvbnN0IGluZm8gPSB3b3JrZmxvd0luZm8oKTtcbiAgICBjb25zdCB7IHdvcmtmbG93VHlwZSwgdGFza1F1ZXVlLCAuLi5yZXN0IH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IHJlcXVpcmVkT3B0aW9ucyA9IHtcbiAgICAgICAgd29ya2Zsb3dUeXBlOiB3b3JrZmxvd1R5cGUgPz8gaW5mby53b3JrZmxvd1R5cGUsXG4gICAgICAgIHRhc2tRdWV1ZTogdGFza1F1ZXVlID8/IGluZm8udGFza1F1ZXVlLFxuICAgICAgICAuLi5yZXN0LFxuICAgIH07XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gKDAsIGNvbW1vbl8xLmNvbXBvc2VJbnRlcmNlcHRvcnMpKGludGVybmFsc18xLnN0YXRlLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2NvbnRpbnVlQXNOZXcnLCBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVycywgYXJncywgb3B0aW9ucyB9ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW50ZXJmYWNlc18xLkNvbnRpbnVlQXNOZXcoe1xuICAgICAgICAgICAgICAgIHdvcmtmbG93VHlwZTogb3B0aW9ucy53b3JrZmxvd1R5cGUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhd2FpdCBpbnRlcm5hbHNfMS5zdGF0ZS5kYXRhQ29udmVydGVyLnRvUGF5bG9hZHMoLi4uYXJncyksXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUsXG4gICAgICAgICAgICAgICAgbWVtbzogb3B0aW9ucy5tZW1vLFxuICAgICAgICAgICAgICAgIHNlYXJjaEF0dHJpYnV0ZXM6IG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy53b3JrZmxvd1J1blRpbWVvdXQpLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93VGFza1RpbWVvdXQ6ICgwLCBjb21tb25fMS5tc09wdGlvbmFsVG9Ucykob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuKHtcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHJlcXVpcmVkT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUNvbnRpbnVlQXNOZXdGdW5jID0gbWFrZUNvbnRpbnVlQXNOZXdGdW5jO1xuLyoqXG4gKiBDb250aW51ZXMgY3VycmVudCBXb3JrZmxvdyBleGVjdXRpb24gYXMgbmV3IHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIFNob3J0aGFuZCBmb3IgYG1ha2VDb250aW51ZUFzTmV3RnVuYzxGPigpKC4uLmFyZ3MpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb250aW51ZUFzTmV3IH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cnO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBteVdvcmtmbG93KG46IG51bWJlcikge1xuICogICByZXR1cm4ge1xuICogICAgIGFzeW5jIGV4ZWN1dGUoKSB7XG4gKiAgICAgICAvLyAuLi4gV29ya2Zsb3cgbG9naWNcbiAqICAgICAgIGF3YWl0IGNvbnRpbnVlQXNOZXc8dHlwZW9mIG15V29ya2Zsb3c+KG4gKyAxKTtcbiAqICAgICB9XG4gKiAgIH07XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29udGludWVBc05ldyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1ha2VDb250aW51ZUFzTmV3RnVuYygpKC4uLmFyZ3MpO1xufVxuZXhwb3J0cy5jb250aW51ZUFzTmV3ID0gY29udGludWVBc05ldztcbi8qKlxuICogR2VuZXJhdGUgYW4gUkZDIGNvbXBsaWFudCBWNCB1dWlkLlxuICogVXNlcyB0aGUgd29ya2Zsb3cncyBkZXRlcm1pbmlzdGljIFBSTkcgbWFraW5nIGl0IHNhZmUgZm9yIHVzZSB3aXRoaW4gYSB3b3JrZmxvdy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgY3J5cHRvZ3JhcGhpY2FsbHkgaW5zZWN1cmUuXG4gKiBTZWUgdGhlIHtAbGluayBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZCB8IHN0YWNrb3ZlcmZsb3cgZGlzY3Vzc2lvbn0uXG4gKi9cbmZ1bmN0aW9uIHV1aWQ0KCkge1xuICAgIC8vIFJldHVybiB0aGUgaGV4YWRlY2ltYWwgdGV4dCByZXByZXNlbnRhdGlvbiBvZiBudW1iZXIgYG5gLCBwYWRkZWQgd2l0aCB6ZXJvZXMgdG8gYmUgb2YgbGVuZ3RoIGBwYFxuICAgIGNvbnN0IGhvID0gKG4sIHApID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KHAsICcwJyk7XG4gICAgLy8gQ3JlYXRlIGEgdmlldyBiYWNrZWQgYnkgYSAxNi1ieXRlIGJ1ZmZlclxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDE2KSk7XG4gICAgLy8gRmlsbCBidWZmZXIgd2l0aCByYW5kb20gdmFsdWVzXG4gICAgdmlldy5zZXRVaW50MzIoMCwgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIHZpZXcuc2V0VWludDMyKDQsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB2aWV3LnNldFVpbnQzMig4LCAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgdmlldy5zZXRVaW50MzIoMTIsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAvLyBQYXRjaCB0aGUgNnRoIGJ5dGUgdG8gcmVmbGVjdCBhIHZlcnNpb24gNCBVVUlEXG4gICAgdmlldy5zZXRVaW50OCg2LCAodmlldy5nZXRVaW50OCg2KSAmIDB4ZikgfCAweDQwKTtcbiAgICAvLyBQYXRjaCB0aGUgOHRoIGJ5dGUgdG8gcmVmbGVjdCBhIHZhcmlhbnQgMSBVVUlEICh2ZXJzaW9uIDQgVVVJRHMgYXJlKVxuICAgIHZpZXcuc2V0VWludDgoOCwgKHZpZXcuZ2V0VWludDgoOCkgJiAweDNmKSB8IDB4ODApO1xuICAgIC8vIENvbXBpbGUgdGhlIGNhbm9uaWNhbCB0ZXh0dWFsIGZvcm0gZnJvbSB0aGUgYXJyYXkgZGF0YVxuICAgIHJldHVybiBgJHtobyh2aWV3LmdldFVpbnQzMigwKSwgOCl9LSR7aG8odmlldy5nZXRVaW50MTYoNCksIDQpfS0ke2hvKHZpZXcuZ2V0VWludDE2KDYpLCA0KX0tJHtobyh2aWV3LmdldFVpbnQxNig4KSwgNCl9LSR7aG8odmlldy5nZXRVaW50MzIoMTApLCA4KX0ke2hvKHZpZXcuZ2V0VWludDE2KDE0KSwgNCl9YDtcbn1cbmV4cG9ydHMudXVpZDQgPSB1dWlkNDtcbi8qKlxuICogUGF0Y2ggb3IgdXBncmFkZSB3b3JrZmxvdyBjb2RlIGJ5IGNoZWNraW5nIG9yIHN0YXRpbmcgdGhhdCB0aGlzIHdvcmtmbG93IGhhcyBhIGNlcnRhaW4gcGF0Y2guXG4gKlxuICogU2VlIFtkb2NzIHBhZ2VdKGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9kb2NzL3R5cGVzY3JpcHQvdmVyc2lvbmluZykgZm9yIGluZm8uXG4gKlxuICogSWYgdGhlIHdvcmtmbG93IGlzIHJlcGxheWluZyBhbiBleGlzdGluZyBoaXN0b3J5LCB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoYXRcbiAqIGhpc3Rvcnkgd2FzIHByb2R1Y2VkIGJ5IGEgd29ya2VyIHdoaWNoIGFsc28gaGFkIGEgYHBhdGNoZWRgIGNhbGwgd2l0aCB0aGUgc2FtZSBgcGF0Y2hJZGAuXG4gKiBJZiB0aGUgaGlzdG9yeSB3YXMgcHJvZHVjZWQgYnkgYSB3b3JrZXIgKndpdGhvdXQqIHN1Y2ggYSBjYWxsLCB0aGVuIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICpcbiAqIElmIHRoZSB3b3JrZmxvdyBpcyBub3QgY3VycmVudGx5IHJlcGxheWluZywgdGhlbiB0aGlzIGNhbGwgKmFsd2F5cyogcmV0dXJucyB0cnVlLlxuICpcbiAqIFlvdXIgd29ya2Zsb3cgY29kZSBzaG91bGQgcnVuIHRoZSBcIm5ld1wiIGNvZGUgaWYgdGhpcyByZXR1cm5zIHRydWUsIGlmIGl0IHJldHVybnMgZmFsc2UsIHlvdVxuICogc2hvdWxkIHJ1biB0aGUgXCJvbGRcIiBjb2RlLiBCeSBkb2luZyB0aGlzLCB5b3UgY2FuIG1haW50YWluIGRldGVybWluaXNtLlxuICpcbiAqIEBwYXJhbSBwYXRjaElkIEFuIGlkZW50aWZpZXIgdGhhdCBzaG91bGQgYmUgdW5pcXVlIHRvIHRoaXMgcGF0Y2guIEl0IGlzIE9LIHRvIHVzZSBtdWx0aXBsZVxuICogY2FsbHMgd2l0aCB0aGUgc2FtZSBJRCwgd2hpY2ggbWVhbnMgYWxsIHN1Y2ggY2FsbHMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXRjaGVkKHBhdGNoSWQpIHtcbiAgICByZXR1cm4gcGF0Y2hJbnRlcm5hbChwYXRjaElkLCBmYWxzZSk7XG59XG5leHBvcnRzLnBhdGNoZWQgPSBwYXRjaGVkO1xuLyoqXG4gKiBJbmRpY2F0ZSB0aGF0IGEgcGF0Y2ggaXMgYmVpbmcgcGhhc2VkIG91dC5cbiAqXG4gKiBTZWUgW2RvY3MgcGFnZV0oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2RvY3MvdHlwZXNjcmlwdC92ZXJzaW9uaW5nKSBmb3IgaW5mby5cbiAqXG4gKiBXb3JrZmxvd3Mgd2l0aCB0aGlzIGNhbGwgbWF5IGJlIGRlcGxveWVkIGFsb25nc2lkZSB3b3JrZmxvd3Mgd2l0aCBhIHtAbGluayBwYXRjaGVkfSBjYWxsLCBidXRcbiAqIHRoZXkgbXVzdCAqbm90KiBiZSBkZXBsb3llZCB3aGlsZSBhbnkgd29ya2VycyBzdGlsbCBleGlzdCBydW5uaW5nIG9sZCBjb2RlIHdpdGhvdXQgYVxuICoge0BsaW5rIHBhdGNoZWR9IGNhbGwsIG9yIGFueSBydW5zIHdpdGggaGlzdG9yaWVzIHByb2R1Y2VkIGJ5IHN1Y2ggd29ya2VycyBleGlzdC4gSWYgZWl0aGVyIGtpbmRcbiAqIG9mIHdvcmtlciBlbmNvdW50ZXJzIGEgaGlzdG9yeSBwcm9kdWNlZCBieSB0aGUgb3RoZXIsIHRoZWlyIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBPbmNlIGFsbCBsaXZlIHdvcmtmbG93IHJ1bnMgaGF2ZSBiZWVuIHByb2R1Y2VkIGJ5IHdvcmtlcnMgd2l0aCB0aGlzIGNhbGwsIHlvdSBjYW4gZGVwbG95IHdvcmtlcnNcbiAqIHdoaWNoIGFyZSBmcmVlIG9mIGVpdGhlciBraW5kIG9mIHBhdGNoIGNhbGwgZm9yIHRoaXMgSUQuIFdvcmtlcnMgd2l0aCBhbmQgd2l0aG91dCB0aGlzIGNhbGxcbiAqIG1heSBjb2V4aXN0LCBhcyBsb25nIGFzIHRoZXkgYXJlIGJvdGggcnVubmluZyB0aGUgXCJuZXdcIiBjb2RlLlxuICpcbiAqIEBwYXJhbSBwYXRjaElkIEFuIGlkZW50aWZpZXIgdGhhdCBzaG91bGQgYmUgdW5pcXVlIHRvIHRoaXMgcGF0Y2guIEl0IGlzIE9LIHRvIHVzZSBtdWx0aXBsZVxuICogY2FsbHMgd2l0aCB0aGUgc2FtZSBJRCwgd2hpY2ggbWVhbnMgYWxsIHN1Y2ggY2FsbHMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVQYXRjaChwYXRjaElkKSB7XG4gICAgcGF0Y2hJbnRlcm5hbChwYXRjaElkLCB0cnVlKTtcbn1cbmV4cG9ydHMuZGVwcmVjYXRlUGF0Y2ggPSBkZXByZWNhdGVQYXRjaDtcbmZ1bmN0aW9uIHBhdGNoSW50ZXJuYWwocGF0Y2hJZCwgZGVwcmVjYXRlZCkge1xuICAgIC8vIFBhdGNoIG9wZXJhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGludGVyY2VwdGlvbiBhdCB0aGUgbW9tZW50LCBpZiBpdCBkaWQsXG4gICAgLy8gdGhpcyB3b3VsZCBiZSB0aGUgcGxhY2UgdG8gc3RhcnQgdGhlIGludGVyY2VwdGlvbiBjaGFpblxuICAgIGNvbnN0IHsgaXNSZXBsYXlpbmcgfSA9IHdvcmtmbG93SW5mbygpO1xuICAgIGlmIChpbnRlcm5hbHNfMS5zdGF0ZS53b3JrZmxvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBjb21tb25fMS5JbGxlZ2FsU3RhdGVFcnJvcignUGF0Y2hlcyBjYW5ub3QgYmUgdXNlZCBiZWZvcmUgV29ya2Zsb3cgc3RhcnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHVzZVBhdGNoID0gIWlzUmVwbGF5aW5nIHx8IGludGVybmFsc18xLnN0YXRlLmtub3duUHJlc2VudFBhdGNoZXMuaGFzKHBhdGNoSWQpO1xuICAgIC8vIEF2b2lkIHNlbmRpbmcgY29tbWFuZHMgZm9yIHBhdGNoZXMgY29yZSBhbHJlYWR5IGtub3dzIGFib3V0LlxuICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGVuYWJsZXMgZGV2ZWxvcG1lbnQgb2YgYXV0b21hdGljIHBhdGNoaW5nIHRvb2xzLlxuICAgIGlmICh1c2VQYXRjaCAmJiAhaW50ZXJuYWxzXzEuc3RhdGUuc2VudFBhdGNoZXMuaGFzKHBhdGNoSWQpKSB7XG4gICAgICAgIGludGVybmFsc18xLnN0YXRlLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgIHNldFBhdGNoTWFya2VyOiB7IHBhdGNoSWQsIGRlcHJlY2F0ZWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsc18xLnN0YXRlLnNlbnRQYXRjaGVzLmFkZChwYXRjaElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVBhdGNoO1xufVxuYXN5bmMgZnVuY3Rpb24gY29uZGl0aW9uKGZuLCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbmNlbGxhdGlvbl9zY29wZV8xLkNhbmNlbGxhdGlvblNjb3BlLmNhbmNlbGxhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmFjZShbc2xlZXAodGltZW91dCkudGhlbigoKSA9PiBmYWxzZSksIGNvbmRpdGlvbklubmVyKGZuKS50aGVuKCgpID0+IHRydWUpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25fc2NvcGVfMS5DYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCkuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29uZGl0aW9uSW5uZXIoZm4pO1xufVxuZXhwb3J0cy5jb25kaXRpb24gPSBjb25kaXRpb247XG5mdW5jdGlvbiBjb25kaXRpb25Jbm5lcihmbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gY2FuY2VsbGF0aW9uX3Njb3BlXzEuQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VxID0gaW50ZXJuYWxzXzEuc3RhdGUubmV4dFNlcXMuY29uZGl0aW9uKys7XG4gICAgICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5ibG9ja2VkQ29uZGl0aW9ucy5kZWxldGUoc2VxKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVhZ2VyIGV2YWx1YXRpb25cbiAgICAgICAgaWYgKGZuKCkpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbHNfMS5zdGF0ZS5ibG9ja2VkQ29uZGl0aW9ucy5zZXQoc2VxLCB7IGZuLCByZXNvbHZlIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBzaWduYWwgbWV0aG9kIGZvciBhIFdvcmtmbG93LlxuICpcbiAqIERlZmluaXRpb25zIGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGhhbmRsZXIgaW4gdGhlIFdvcmtmbG93IHZpYSB7QGxpbmsgc2V0SGFuZGxlcn0gYW5kIHRvIHNpZ25hbCBXb3JrZmxvd3MgdXNpbmcgYSB7QGxpbmsgV29ya2Zsb3dIYW5kbGV9LCB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZX0gb3Ige0BsaW5rIEV4dGVybmFsV29ya2Zsb3dIYW5kbGV9LlxuICogRGVmaW5pdGlvbnMgY2FuIGJlIHJldXNlZCBpbiBtdWx0aXBsZSBXb3JrZmxvd3MuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVNpZ25hbChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3NpZ25hbCcsXG4gICAgICAgIG5hbWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmaW5lU2lnbmFsID0gZGVmaW5lU2lnbmFsO1xuLyoqXG4gKiBEZWZpbmUgYSBxdWVyeSBtZXRob2QgZm9yIGEgV29ya2Zsb3cuXG4gKlxuICogRGVmaW5pdGlvbnMgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgaGFuZGxlciBpbiB0aGUgV29ya2Zsb3cgdmlhIHtAbGluayBzZXRIYW5kbGVyfSBhbmQgdG8gcXVlcnkgV29ya2Zsb3dzIHVzaW5nIGEge0BsaW5rIFdvcmtmbG93SGFuZGxlfS5cbiAqIERlZmluaXRpb25zIGNhbiBiZSByZXVzZWQgaW4gbXVsdGlwbGUgV29ya2Zsb3dzLlxuICovXG5mdW5jdGlvbiBkZWZpbmVRdWVyeShuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3F1ZXJ5JyxcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZpbmVRdWVyeSA9IGRlZmluZVF1ZXJ5O1xuLyoqXG4gKiBTZXQgYSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhIFdvcmtmbG93IHF1ZXJ5IG9yIHNpZ25hbC5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiBzaWduYWwgb3IgcXVlcnkgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gZGVmIGEge0BsaW5rIFNpZ25hbERlZmluaXRpb259IG9yIHtAbGluayBRdWVyeURlZmluaXRpb259IGFzIHJldHVybmVkIGJ5IHtAbGluayBkZWZpbmVTaWduYWx9IG9yIHtAbGluayBkZWZpbmVRdWVyeX0gcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGhhbmRsZXIgIGEgY29tcGF0aWJsZSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2V0SGFuZGxlcihkZWYsIGhhbmRsZXIpIHtcbiAgICBpZiAoZGVmLnR5cGUgPT09ICdzaWduYWwnKSB7XG4gICAgICAgIGludGVybmFsc18xLnN0YXRlLnNpZ25hbEhhbmRsZXJzLnNldChkZWYubmFtZSwgaGFuZGxlcik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkU2lnbmFscyA9IGludGVybmFsc18xLnN0YXRlLmJ1ZmZlcmVkU2lnbmFscy5nZXQoZGVmLm5hbWUpO1xuICAgICAgICBpZiAoYnVmZmVyZWRTaWduYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIGJ1ZmZlcmVkU2lnbmFscykge1xuICAgICAgICAgICAgICAgIGludGVybmFsc18xLnN0YXRlLmFjdGl2YXRvci5zaWduYWxXb3JrZmxvdyhzaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUuYnVmZmVyZWRTaWduYWxzLmRlbGV0ZShkZWYubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLnR5cGUgPT09ICdxdWVyeScpIHtcbiAgICAgICAgaW50ZXJuYWxzXzEuc3RhdGUucXVlcnlIYW5kbGVycy5zZXQoZGVmLm5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkZWZpbml0aW9uIHR5cGU6ICR7ZGVmLnR5cGV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXRIYW5kbGVyID0gc2V0SGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtmbG93LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@temporalio/workflow/lib/workflow.js\n"
        );

        /***/
      },

    /***/ './node_modules/long/src/long.js':
      /*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
      /***/ (module) => {
        eval(
          "module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCLCtDQUErQztBQUNoRixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQiwrQ0FBK0M7QUFDaEYsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0I7QUFDN0Y7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYscUJBQXFCO0FBQ3RHO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHFCQUFxQjtBQUN0RztBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixvQkFBb0I7QUFDckc7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsMkJBQTJCO0FBQ3JIO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRix1QkFBdUI7QUFDM0c7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsOEJBQThCO0FBQzNIO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDhCQUE4QjtBQUMzSDtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxtQkFBbUI7QUFDNUY7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxvQkFBb0I7QUFDbkc7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLG9CQUFvQjtBQUNoRztBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixxQkFBcUI7QUFDbEg7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLHNCQUFzQjtBQUNuSTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLDhCQUE4QjtBQUN0STtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csOEJBQThCO0FBQ3RJO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzP2RhNWEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/long/src/long.js\n"
        );

        /***/
      },

    /***/ './node_modules/ms/index.js':
      /*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
      /***/ (module) => {
        eval(
          "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MTQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n"
        );

        /***/
      },

    /***/ './src/all-workflows.ts':
      /*!******************************!*\
  !*** ./src/all-workflows.ts ***!
  \******************************/
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        'use strict';
        eval(
          '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./canaray */ "./src/canaray/index.ts"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWxsLXdvcmtmbG93cy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxzRkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fX1RFTVBPUkFMX18vLi9zcmMvYWxsLXdvcmtmbG93cy50cz8zY2NkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vY2FuYXJheSciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/all-workflows.ts\n'
        );

        /***/
      },

    /***/ './src/canaray/index.ts':
      /*!******************************!*\
  !*** ./src/canaray/index.ts ***!
  \******************************/
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        eval(
          '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.canaryWf = void 0;\nconst workflow_1 = __webpack_require__(/*! @temporalio/workflow */ "./node_modules/@temporalio/workflow/lib/index.js");\nconst { greet } = (0, workflow_1.proxyActivities)({\n    startToCloseTimeout: \'1 minute\',\n});\nasync function canaryWf(name) {\n    return await greet(name);\n}\nexports.canaryWf = canaryWf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2FuYXJheS9pbmRleC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSx1SEFBdUQ7QUFHdkQsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLDhCQUFlLEVBQW9CO0lBQ25ELG1CQUFtQixFQUFFLFVBQVU7Q0FDaEMsQ0FBQyxDQUFDO0FBRUksS0FBSyxVQUFVLFFBQVEsQ0FBQyxJQUFZO0lBQ3pDLE9BQU8sTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQUZELDRCQUVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX19URU1QT1JBTF9fLy4vc3JjL2NhbmFyYXkvaW5kZXgudHM/ZDE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm94eUFjdGl2aXRpZXMgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG5pbXBvcnQgdHlwZSAqIGFzIGFjdGl2aXRpZXMgZnJvbSAnLi9hY3Rpdml0aWVzJztcblxuY29uc3QgeyBncmVldCB9ID0gcHJveHlBY3Rpdml0aWVzPHR5cGVvZiBhY3Rpdml0aWVzPih7XG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICcxIG1pbnV0ZScsXG59KTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbmFyeVdmKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBhd2FpdCBncmVldChuYW1lKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/canaray/index.ts\n'
        );

        /***/
      },

    /***/ '../../../../../../../../src/main.js':
      /*!*******************************************!*\
  !*** ../../../../../../../../src/main.js ***!
  \*******************************************/
      /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "api": () => (/* reexport module object */ _temporalio_workflow_lib_worker_interface_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _temporalio_workflow_lib_worker_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @temporalio/workflow/lib/worker-interface.js */ "./node_modules/@temporalio/workflow/lib/worker-interface.js");\n\n\n// Bundle all Workflows and interceptor modules for lazy evaluation\n_temporalio_workflow_lib_worker_interface_js__WEBPACK_IMPORTED_MODULE_0__.overrideGlobals();\n_temporalio_workflow_lib_worker_interface_js__WEBPACK_IMPORTED_MODULE_0__.setImportFuncs({ \n  importWorkflows: () => {\n    return Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./src/all-workflows.ts */ "./src/all-workflows.ts", 23));\n  },\n  importInterceptors: () => {\n    return Promise.all([\n      \n    ]);\n  }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0U7O0FBRXBFO0FBQ0EseUZBQW1CO0FBQ25CLHdGQUFrQjtBQUNsQjtBQUNBLFdBQVcsd0pBQWdLO0FBQzNLLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19fVEVNUE9SQUxfXy8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvbWFpbi5qcz81NGE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFwaSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdy9saWIvd29ya2VyLWludGVyZmFjZS5qcyc7XG5cbi8vIEJ1bmRsZSBhbGwgV29ya2Zsb3dzIGFuZCBpbnRlcmNlcHRvciBtb2R1bGVzIGZvciBsYXp5IGV2YWx1YXRpb25cbmFwaS5vdmVycmlkZUdsb2JhbHMoKTtcbmFwaS5zZXRJbXBvcnRGdW5jcyh7IFxuICBpbXBvcnRXb3JrZmxvd3M6ICgpID0+IHtcbiAgICByZXR1cm4gaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcGFzY2FsbGFlbmVuL0RvY3VtZW50cy9wcm9qZWN0cy9zcGlrZXMvc3Bpa2Utb3JjaGVzdHJhdGlvbi10ZW1wb3JhbC9wYWNrYWdlcy90ZW1wb3JhbC13b3JrZmxvd3Mvc3JjL2FsbC13b3JrZmxvd3MudHNcIik7XG4gIH0sXG4gIGltcG9ydEludGVyY2VwdG9yczogKCkgPT4ge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBcbiAgICBdKTtcbiAgfVxufSk7XG5cbmV4cG9ydCB7IGFwaSB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../../../../../src/main.js\n'
        );

        /***/
      }

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {}
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/create fake namespace object */
  /******/ (() => {
    /******/ var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
    /******/ var leafPrototypes;
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 16: return value when it's Promise-like
    /******/ // mode & 8|1: behave like require
    /******/ __webpack_require__.t = function (value, mode) {
      /******/ if (mode & 1) value = this(value);
      /******/ if (mode & 8) return value;
      /******/ if (typeof value === 'object' && value) {
        /******/ if (mode & 4 && value.__esModule) return value;
        /******/ if (mode & 16 && typeof value.then === 'function') return value;
        /******/
      }
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ var def = {};
      /******/ leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
      /******/ for (
        var current = mode & 2 && value;
        typeof current == 'object' && !~leafPrototypes.indexOf(current);
        current = getProto(current)
      ) {
        /******/ Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => value[key]));
        /******/
      }
      /******/ def['default'] = () => value;
      /******/ __webpack_require__.d(ns, def);
      /******/ return ns;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module can't be inlined because the eval-source-map devtool is used.
  /******/ var __webpack_exports__ = __webpack_require__('../../../../../../../../src/main.js');
  /******/ __TEMPORAL__ = __webpack_exports__;
  /******/
  /******/
})();
